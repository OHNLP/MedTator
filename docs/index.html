<!doctype html>
<html lang="en">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>MedTator</title>

<link href="./static/img/favicon.ico" rel="shortcut icon" type="image/x-icon" />

<!-- Font Awesome CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<!-- Metro UI style -->
<link rel="stylesheet" href="https://cdn.metroui.org.ua/v4.3.2/css/metro-all.min.css">

<!-- jquery UI style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css" />

<!-- code mirror style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css" />

<!-- for the metro UI -->
<meta name="metro4:init" content="false">

<style id="app_style">
.box {
    display: flex;
    flex-direction: column;
}

.box-header {
    width: 100%;
    padding: 3px 0;
    display: flex;
    flex-direction: row;
}

.box-header a {
    font-size: 1em;
}

.box-header h4 {
    padding: 0;
    margin: 0;
    font-size: 1.2em;
    height: 1.5em;
    line-height: 1.5em;
    margin: 3px 0;
}

.box-header button,
.box-body button,
.box-footer button {
    height: 1.6em;
    line-height: 1em;
    font-size: .9em;
    margin: 4px;
}

.box-header input,
.box-body input {
    height: 1.2em;
    line-height: 1.2em;
    font-size: 1em;
    margin: 4px 4px 0 4px;
    padding-bottom: 2px;
}

.box-header select {
    height: 1.6em;
    line-height: 1.2em;
    font-size: .9em;
    margin: 4px;
}

.box-header span {
    font-size: 1em;
}

.box-header-right {
    font-size: 1em;
    height: 1.6em;
    line-height: 1.6em;
    margin: 3px 0;
    text-align: right;
}

.box-body {
    width: 100%;
}

.box-body-item {
    padding: 5px 0 2px 0;
    display: flex;
    flex-direction: column;
    border-bottom: 1px dotted #cccccc;
}

.box-body-item ul {
    margin: 0;
}

.box-body-item ul input {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item ul label {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item-left {
    width: 73%;
}

.box-body-item-right {
    width: 24%;
    display: flex;
    flex-direction: row;
}

.box-body-item-label {
    width: 54%;
    font-size: 1em;
    line-height: 1.8em;
}

.box-body-item-value {
    width: 45%;
}

.box-body-item select {
    width: 100%;
}

.box-body h5 {
    padding: 0;
    margin: 0;
    font-size: 1em;
    height: 1.6em;
    line-height: 1.6em;
    margin: 3px 0;
}

.box-p {
    width: 100%;
    padding: 0;
    margin: 0;
    font-size: 1em;
}

.box-p-fixlen {
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
}

.box-footer {
    width: 100%;
    min-height: 20px;
    padding: 5px 0 5px 0;
}
html,body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-size: 12px;
}
.code {
    font-family: 'Courier New', Courier, monospace;
    background-color: #eeeeee;
    font-size: 12px;
}

/* a start screen for IE and hiding init */
#start-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    background: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
#ss-msg {
    width: 100%;
    padding: 10px 0;
    text-align: center;
}
.h-splitter {
    width: 5px;
    height: 100%;
    background-color: #e9e9e9;
}
.h-splitter-menu {
    width: 1px;
    height: 64px;
    background-color: #dadbdc;
}
.v-splitter {
    width: 100%;
    height: 5px;
    background-color: #e9e9e9;
}
#app_info {
    position: absolute;
    top: 2px;
    right: 10px;
    color: #777777;
    z-index: 988;
}
#app_info a {
    color: #777777;
}
#app_info a:hover {
    color: black;
}
#mui_filelist {
    overflow-y: hidden;
    width: 250px;
}
#mui_filelist_toolbar {
    height: 32px;
    border-bottom: 1px solid #cccccc;
}
#mui_filelist_list {
    height: calc(100% - 32px);
    overflow-y: auto;
}
#mui_texteditor {
    width: calc(100% - 250px); 
    height: 100%;
}
#mui_dtdlist {
    overflow-y: auto;
    width: 250px;
}
#mui_annlist {
    padding-left: 5px;
    overflow-y: auto; 
    width: calc(100% - 250px);
}
#mui_stat_summary {
    width: 250px;
    border-right: 1px solid #e9e9e9;
}
#mui_stat_details {
    width: calc(100% - 250px);
}
#mui_iaa_summary {
    width: 240px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_anns {
    width: 300px;
    padding-right: 5px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_tags {
    width: calc(100% - 550px);
    padding-right: 5px;
    /* border-right: 1px solid #e9e9e9; */
    overflow-y: auto;
}
#mui_ruleset_result {
    
}
#app_hotpot {
    margin-top: 2px;
}
.dropzone:hover {
  border-color: rgb(0, 89, 255);
  font-weight: bold;
}
.disabled-zone {
    opacity: .5;
}
.zone-text {
    margin-top: 9px; 
    line-height: 14px;
    padding-left: 5px;
    padding-right: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#dropzone_dtd {
    width: 150px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_ann {
    width: 150px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_txt {
    width: 176px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.dropzone-iaa {
    width: 176px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.tag-list-row {
    
}
.tag-list-row-actived {
    background-color: #efefef;
}
.badge-shortcut {
    padding: 1px 1px 1px 2px;
    font-size: 10px;
    font-family: 'Courier New', Courier, monospace;
    color: black;
    background-color: #EAEAEA;
    border: 1px solid #EFEFEF;
    border-right: 1px solid #cccccc;
    border-bottom: 1px solid #cccccc;
}
.mark-hint {
    cursor: pointer;
    border: 2px dotted #999999;
    position: relative;
    /* display: inline-block; */
}
.mark-hint:hover {
    font-weight: bold;
    border: 2px dotted #333333;
}
.mark-hint-info {
    margin: 0 5px 0 0;
    padding: 0px 4px;
    color: white;
}
.mark-hint-text {

}
.mark-hint .mark-hint-tooltip {
    visibility: hidden;
    min-width: 100px;
    width: auto;
    background-color: #cccccc;
    color: black;
    text-align: center;
    font-size: .9em;
    font-weight: normal;
    font-family: sans-serif;
    border-radius: 6px;
    padding: 1px 5px;
    position: absolute;
    z-index: 999;
    top: 135%;
    left: 50%;
    margin-left: -50%;
    opacity: 0;
    transition: opacity 0.3s;
}
.mark-hint .tooltiptext::after {
    content: "";
    position: absolute;
    top: 130%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent #cccccc transparent;
}
.mark-hint:hover .mark-hint-tooltip {
    visibility: visible;
    opacity: 1;
}
.mark-tag {
    border-radius: 3px;
    padding: 1px 3px;
    margin-right: 0;
    cursor: pointer;
    border: 1px solid white;
}
.mark-tag:hover{
    border-color: red;
}
.mark-tag-active {    
    /* border: 2px dotted red; */
    animation: glow 500ms ease-out infinite alternate;
}
@keyframes glow {
    0% {
        border-color: rgb(247, 247, 247);
        box-shadow: 0 0 5px rgba(255, 231, 231, 0.815);
    }
    100% {
        border-color: rgb(255, 125, 125);
        box-shadow: 0 0 10px rgba(255, 125, 125, 0.5);
    }
}
.mark-tag-info {
    font-size: .75em;
    margin: 0 5px 0 0;
    padding: 0px 2px;
    background: white;
    border-radius: 4px;
}
.mark-tag-info-inline {
}
.mark-tag-info-offset {
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: transparent;
    border-radius: .5em;
}
.mark-tag:hover .mark-tag-info-offset{
    display: inline;
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: grey;
    background-color: white;
}
.mark-tag:hover .mark-tag-info-offset:hover {
    color: black;
    background-color: white;
}
.mark-tag-text {
    margin-right: -.5em;
}
.mark-round {
    border-radius: 8px;
    padding: 0 1px 0 0;
    color: black !important;
}
#cm_editor {
    height: 100%;
}
.CodeMirror {
    height: 100%;
    font-size: 14px;
    line-height: 2em;
}
.CodeMirror-activeline-background {
    background-color: #e3f3fb;
}
.CodeMirror-plots {
    position: absolute;
    width: 100%;
    height: 100%;
}
#cm_svg_plots {
    width: 100%;
    height: 100%;
}
.tag-polyline {
	fill: none;
    stroke: black;
    stroke-width: 1;
    /* vector-effect: non-scaling-stroke; */
    /* stroke-dasharray: 2, 1; */
    opacity: .5;
}
.tag-polyline:hover {
    opacity: .95;
}
.tag-linkdot {
    font-size: 8px;
    padding: 0 1px;
    border-left: 1px solid;
    font-family: 'Courier New', Courier, monospace;
}
.tag-linktext {
    font-size: 9px;
    padding: 0 3px;
}
.tag-linktext-bg {
    stroke-width: 0;
    rx: 3px;
    opacity: 1;
}
/* for the pop menu */
#popmenu_tag {
    z-index: 998;
    position: absolute;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
/* for the context menu */
#ctxmenu_sel {
    z-index: 999;
    position: absolute;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
#ctxmenu_nce {
    z-index: 998;
    position: absolute;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
.ctxmenu-item {
    padding: 1px;
    cursor: pointer;
}
.ctxmenu-item:hover {
    background-color: rgb(221, 221, 221);
}
.ctxmenu-divider {
    height: 2px;
    margin: 2px 0;
    background-color: #dfdfdf;
}
.ui-widget-header {
    border: 0;
    height: 2em;
    line-height: 2em;
    text-indent: 0.5em;
    background-color: #EAEAEA;
}
.file-list {
    font-size: .9em;
    padding: 2px;
}
.file-list li {
    border-bottom: 1px dotted #eeeeee;
}
.file-list li.file-selected {
    font-weight: bold;
    background-color: #EFEFEF;
    border-left: 3px solid #1ba1e2;
    padding-left: 5px;
}
.file-list-item {
    margin-bottom: 1px;
}
.file-list-item:hover {
    background-color: #e9e8e8;
}
.file-list-item-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.file-list-item-name-unsaved {
    font-style: italic;
}
/* tag list */
.tag-list {
    font-size: 1em;
    padding: 2px;
}
.tag-list li {
    padding: 2px 0;
    border-bottom: 1px dotted #eeeeee;
}
.tag-list li:hover {
    background-color: #EAEAEA;
}
.tag-list-row-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;

    cursor: pointer;
    flex-grow: 1;
}
.tag-list-row-name-id-prefix {
    font-weight: bold;
    /* text-decoration: underline; */
}
.tag-list-row-count-0 {
    color: #bdbdbd;
    font-size: .95em;
}
.tag-table {
    font-size: .9em;
}
.tag-table th, 
.tag-table td {
    padding: 2px;
}
.tag-table th {
    border-bottom: 1px solid #999999;
    text-align: left;
}
.tag-table th.tag-name {
    max-width: 200px;
    width: 180px;
}
.tag-table th.tag-id {
    max-width: 100px;
    width: 60px;
}
.tag-table th.tag-spans {
    max-width: 200px;
    width: 120px;
}
.tag-table td {
    border-bottom: 1px dotted #aaaaaa;
}
.tag-table tr:hover {
    background-color: #EAEAEA;
}
.tag-table td.td-text {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.tag-attr-box {
    background-color: whitesmoke;
    border-radius: 3px;
    padding: 1px 5px;
    margin-bottom: 2px;
}
.tag-attr-box:hover{
    background-color: rgb(209, 209, 209);
}
.tag-attr-name {
    font-size: .9em;
}
input[type=text].tag-attr-input {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
select.tag-attr-select {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
.btn {
    padding: 2px 4px;
    border-top: 1px solid #EAEAEA;
    border-left: 1px solid #EAEAEA;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn:hover {
    border-top: 1px solid #aaaaaa;
    border-left: 1px solid #aaaaaa;
    border-right: 1px solid #858585;
    border-bottom: 1px solid #858585;
}
.btn:active {
    border-top: 1px solid #858585;
    border-left: 1px solid #858585;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn-xs {
    font-size: .9em;
}
.btn-red {
    color: #b99090;
}
.btn-red:hover {
    color: red;
}
input[type=text].ipt-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-md {
    font-size: 1.2em;
    line-height: 1.2em;
    height: 1.6em;
    padding: 2px 3px;
    max-width: 150px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-spinner-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
}
.icon-fg-unsaved {
    color: #daaf5f;
}
.icon-fg-unsaved:hover {
    color: #ffa600;
}

.ruleset-tag-item {
    cursor: pointer;
    border-bottom: 1px dotted #ececec;
}
.ruleset-tag-item:hover {
    background-color: whitesmoke;
}
.ruleset-tag-name {
    width: 180px;
    min-width: 180px;
    border-left: 5px solid;
}
.ruleset-tag-text {
    padding: 0px 2px;
}
.ruleset-tag-text-str {
    padding: 0px 3px;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-count {
    padding: 0px 5px;
    background-color: #dadada;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-filelist {
    padding: 1px 0 1px 4px;
    border-left: 1px solid #EFEFEF;
    border-bottom: 1px solid #EFEFEF;
    max-height: 115px;
    overflow-y: auto;
}
.ruleset-tag-text-filelist-item {
    cursor: pointer;
    color: #333333;
    padding: 2px 0;
}
.ruleset-tag-text-filelist-item:hover {
    color: rgb(1, 84, 207);
    background-color: #efefef;
}
.ruleset-tag-text-filelist-item-count {
    padding: 0px 2px;
    background-color: #eaeaea;
}
.iaa-row-header {
    font-weight: bold;
}
.iaa-row {
    border-bottom: 1px dotted #efefef;
    padding-top: 3px;
    padding-bottom: 3px;
    cursor: pointer;
}
.iaa-row-actived {
    background-color: #dfdfdf;
}
.iaa-row:hover {
    background-color: #efefef;
}
.iaa-bar {
    background-color: #1ba1e2;
    height: 1em;
}
.iaa-bar-box {
    width: 120px;
}
.iaa-bar-name-box {
    width: 100px;
}
.iaa-bar-filename {
    font-size: 0.8em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-bar-value {
    font-size: 0.9em;
    font-weight: bold;
}
.iaa-bar-filename-box {
    width: 150px;
}
.iaa-file-cm-box {
    font-size: 0.8em;
}
.iaa-file-gs-box {
    font-size: 0.8em;
}
.iaa-tag-name {
    text-align: center;
    padding-top: 5px;
    border-top: 2px dotted #dfdfdf;
    /* border-bottom: 1px dashed #dfdfdf; */
}
.iaa-tag-detail {
    /* border-bottom: 1px dashed #dfdfdf; */
    margin-top: 5px;
    margin-bottom: 5px;
}
.iaa-tag-detail:hover {
    background-color: #efefef;
}
.iaa-tag-detail-header {
    /* border-bottom: 1px dashed #dfdfdf; */
    font-weight: bold;
    text-align: center;
    font-size: 1.1em;
    margin-bottom: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-tag-detail-info {
    border: 1px;
    border-radius: 5px;
    padding: 5px;
}
.iaa-tag-detail-info-tp {
    border: 1px solid #61a51d;
}
.iaa-tag-detail-info-fp {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-fn {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-gs {
    border: 1px dotted #dfdfdf;
}
.iaa-tag-detail-info-text-ab {
    margin-top: 14px;
}
.iaa-tag-detail-info-text-gs {
    margin-top: 14px;
}
.iaa-tag-detail-a {
    margin-right: 5px;
}
.iaa-tag-detail-b {
    margin-right: 5px;
}
.iaa-tag-detail-g-header {
    cursor: pointer;
}
.iaa-tag-detail-g {
    border-left: 1px dotted #dfdfdf;
    padding-left: 4px;
}
.iaa-tag-detail-g:hover {
    border-left-color: #999999;
    background-color: rgb(253, 236, 205);
}
.iaa-tag-detail-oper {
    display: none;
    position: absolute;
    top: -7px;
    left: -6px;
}
.iaa-tag-detail-info:hover 
.iaa-tag-detail-oper {
    display: block;
}
.iaa-tag-attlist {
    border-bottom: 1px solid #aaaaaa;
}
.iaa-tag-attlist-name {
    font-size: 0.8em;
}
.iaa-tag-context {
    font-size: 1.2em;
}
.iaa-w-100 {
    width: 100% !important;
}
.iaa-w-80 {
    width: 80% !important;
}
.iaa-w-50 {
    width: 50% !important;
}
.iaa-w-40 {
    width: 40% !important;
}
.iaa-w-20 {
    width: 20% !important;
}
.iaa-op-50 {
    opacity: 0.5;
}
/* for text display */
.clr-red {
    color: red;
}
/* fix for metro */
.radio .caption, .radio .check {
    font-size: 1em;
}
.switch .caption, .switch .check {
    font-size: 1em;
}
.switch {
    height: 30px;
}
.radio {
    height: 30px;
}
.ribbon-toggle-group .ribbon-icon-button {
    height: 18px;
}
/* for the linking panel */
#pan_working_tag {
    position: absolute;
    top: 10px;
    left: 10px;
    max-width: 300px;
    max-height: 400px;
    overflow-x: hidden;
    overflow-y: auto;
    border: 1px solid #aaaaaa;
    background: white;
    box-shadow: 0 0 15px #828282;
    z-index: 999;
}
#pan_working_tag_title {
    cursor: grab;
    background-color: whitesmoke;
}
#pan_working_tag_title:active {
    cursor: grabbing;
}
.ltag-attr-name {
    align-items: center;
    min-width: 100px;
    max-width: 200px;
}
.ltag-attr-value {
    max-width: 150px;
}
.ltag-attr-row:hover {
    background-color: rgb(211, 211, 211) !important;
}
.ltag-attr-row:nth-child(even) {
    background-color: white;
}
.ltag-attr-row:nth-child(odd) {
    background-color: whitesmoke;
}

/* app_settings */
#app_settings {
    position: absolute;
    top: 20px;
    right: 5px;
    width: 280px;
    padding: 5px;
    background-color: white;
    border: 1px solid #828282;
    z-index: 10;
}
.setting-tab {
    border-bottom: 1px solid #aaaaaa;
    cursor: pointer;
}
.active-setting-tab {
    font-weight: bold;
    border: 1px solid #aaaaaa;
    border-bottom: 0;
}
</style>

<style id="dtd_style">
</style>

</head>

<body>

<div id="start-screen">
    <h1>
        <i class="fa fa-highlighter"></i>
        MedTator
    </h1>
    <div id="ss-msg">Loading data and initializing GUI ...</div>
</div>

<div id="app_hotpot">

    <nav data-role="ribbonmenu">
        <ul class="tabs-holder">
            <li v-on:click="switch_mui('annotation')"
                v-bind:class="{'active': section=='annotation'}">
                <a id="tab_link_annotation" href="#section-1-1">
                    <i class="fa fa-highlighter"></i>
                    Annotation
                </a>
            </li>
            <li v-on:click="switch_mui('statistics')"
                v-bind:class="{'active': section=='statistics'}">
                <a href="#section-1-5">
                    <i class="fa fa-chart-bar"></i>
                    Statistics
                </a>
            </li>
            <!-- <li v-on:click="switch_mui('corpus')"
                v-bind:class="{'active': section=='corpus'}">
                <a href="#section-1-2">
                    <i class="fa fa-cubes"></i>
                    Batch Convert
                </a>
            </li> -->
            <li v-on:click="switch_mui('ruleset')"
                v-bind:class="{'active': section=='ruleset'}">
                <a href="#section-1-4">
                    <i class="fa fa-file-export"></i>
                    Export
                </a>
            </li>
            <li v-on:click="switch_mui('iaa')"
                v-bind:class="{'active': section=='iaa'}">
                <a href="#section-1-6">
                    <i class="fa fa-people-arrows"></i>
                    IAA
                </a>
            </li>
        </ul>

        <div class="content-holder">
            <!-- the section for annotation -->
            <div class="section" id="section-1-1" 
                v-bind:class="{'active': section=='annotation'}">

                <div class="group">

                    <div id="dropzone_dtd" class="dropzone"
                        v-on:click="open_dtd_file">
                        <div v-if="dtd != null" class="zone-text">
                            <b>{{ dtd.name }}</b><br>
                            {{ dtd.etags.length }} Entity Tags<br>
                            {{ dtd.ltags.length }} Link Tags
                        </div>
                        <div v-else>
                            Drop a <b>Schema</b> File Here
                        </div>
                    </div>

                    <!-- <button class="ribbon-button"
                        v-on:click="open_dtd_file">
                        <span class="icon">
                            <i class="far fa-file"></i>
                        </span>
                        <span class="caption">Open DTD</span>
                    </button> -->

                    <span class="title">Schema DTD File (.dtd)</span>
                </div>

                <div class="group">

                    <div id="dropzone_ann" 
                        v-on:click="open_ann_files"
                        v-bind:class="{'disabled-zone': dtd == null, 'dropzone': dtd != null}">
                        <div v-if="ann_idx != null" class="zone-text">
                            <b>{{ anns[ann_idx]._filename }}</b><br>
                            {{ anns[ann_idx].text.length }} chars<br>
                            {{ anns[ann_idx].tags.length }} tags
                        </div>
                        <div v-else-if="dtd != null">
                            Drop <b>Annotation</b> File(s)
                        </div>
                        <div v-else>
                            <i class="fa fa-arrow-left"></i>
                            Load schema file first
                        </div>
                    </div>

                    <!-- <button class="ribbon-button"
                        v-on:click="open_ann_files">
                        <span class="icon">
                            <i class="far fa-file-code"></i>
                        </span>
                        <span class="caption">Open XMLs</span>
                    </button> -->

                    <span class="title">Annotation File (.xml)</span>
                </div>

                <div v-if="ann_idx != null"
                    class="group">
                    <button class="ribbon-button"
                        v-if="has_FSA_API()"
                        v-on:click="save_xml">
                        <span class="icon">
                            <i class="far fa-save"></i>
                        </span>
                        <span class="caption">Save</span>
                    </button>
 
                    <button class="ribbon-button"
                        v-if="has_FSA_API()"
                        v-on:click="save_as_xml">
                        <span class="icon">
                            <i class="far fa-copy"></i>
                        </span>
                        <span class="caption">Save as</span>
                    </button>
 
                    <button class="ribbon-button"
                        v-if="!has_FSA_API()"
                        v-on:click="download_as_xml">
                        <span class="icon">
                            <i class="fa fa-file-download"></i>
                        </span>
                        <span class="caption">Download XML</span>
                    </button>
                    
                    <a id="downloadAnchorElem" style="display:none"></a>

                    <span class="title">Save</span>
                </div>

                <!-- <div class="group">
                    <div>
                        <input type="radio" name="mode" data-role="radio" data-caption="Normal" checked><br>
                        <input type="radio" name="mode" data-role="radio" data-caption="Discontiguous" >
                    </div>
                    <span class="title">Annotation Mode</span>
                </div> -->

                <div class="group">
                    <div>
                        <input type="radio" name="display_mode" value="document" 
                            data-role="radio" 
                            data-caption="<i class='far fa-file-alt'></i> Document" checked 
                            v-model="cm.display_mode"
                            @change="on_change_display_mode">
                        <br>
                        <input type="radio" name="display_mode" value="sentences" 
                            data-role="radio" 
                            data-caption="<i class='fa fa-list'></i> Sentences" 
                            v-model="cm.display_mode"
                            @change="on_change_display_mode">
                    </div>

                    <span class="title">Display Mode</span>
                </div>

                <div class="group">
                    <div>
                        <input type="radio" name="mark_mode" value="node" 
                            data-role="radio" 
                            data-caption="Color + ID" checked 
                            v-model="cm.mark_mode"
                            @change="on_change_mark_mode">
                        <br>
                        <input type="radio" name="mark_mode" value="span" 
                            data-role="radio" 
                            data-caption="Color Only" 
                            v-model="cm.mark_mode"
                            @change="on_change_mark_mode">
                    </div>
                    <span class="title">Entity Marks</span>
                </div>
                
                <div class="group">
                    <div>
                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Show Links"
                            v-model="cm.enabled_links"
                            @change="on_change_link_settings">
                        <br>
                        
                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Show Lines"
                            v-model="cm.enabled_link_complex"
                            @change="on_change_link_settings">
                    </div>

                    <div v-show="is_linking">
                        <button class="ribbon-button"
                            v-on:click="done_linking">
                            <span class="icon">
                                <span class="fa fa-check-circle"></span>
                            </span>
                            <span class="caption">Done Linking</span>
                        </button>
                    </div>

                    <div v-show="is_linking">
                        <button class="ribbon-button"
                            v-on:click="cancel_linking">
                            <span class="icon">
                                <span class="far fa-times-circle"></span>
                            </span>
                            <span class="caption">Cancel Linking</span>
                        </button>
                    </div>
                    <span class="title">Link Marks</span>
                </div>

                <div class="group">
                    <div class="ribbon-toggle-group">
                        <button class="ribbon-icon-button active"
                            v-on:click="on_change_hint_mode('simple')">
                            <span class="icon">
                                <span class="mif-list"></span>
                            </span>
                            <span class="caption">Simple Hint</span>
                        </button>
    
                        <!-- <button class="ribbon-icon-button"
                            v-on:click="on_change_hint_mode('smart')">
                            <span class="icon">
                                <span class="fa fa-magic"></span>
                            </span>
                            <span class="caption">Smart</span>
                        </button> -->
    
                        <button class="ribbon-icon-button"
                            v-on:click="on_change_hint_mode('off')">
                            <span class="icon">
                                <span class="fa fa-ban"></span>
                            </span>
                            <span class="caption">No Hint</span>
                        </button>
                    </div>

                    <div>

                        <button class="ribbon-button" 
                            v-on:click="accept_all_hints">
                            <span class="icon">
                                <i class="fa fa-check-double"></i>
                            </span>
                            <span class="caption">Accept All</span>
                        </button>
                        
                    </div>
    
                    <span class="title">Hint Marks</span>
                </div>

                <div class="group">

                    <div class="ribbon-split-button"
                        id="btn_annotation_load_sample">
                        <button class="ribbon-main"
                            title="Load a minimal task"
                            v-on:click="load_sample_ds('MINIMAL_TASK')">
                            <span class="icon">
                                <i class="far fa-edit"></i>
                            </span>
                        </button>
                        <span class="ribbon-split dropdown-toggle">Sample</span>
                        <ul class="ribbon-dropdown text-left" 
                            data-role="dropdown" 
                            data-duration="100">
                            <li title="A minimal annotation task"
                                v-on:click="load_sample_ds('MINIMAL_TASK')">
                                <a href="javascript:void(0);">Minimal Annotation Task</a>
                            </li>
                            <li title="A sample for entity and relation annotation"
                                v-on:click="load_sample_ds('ENTITY_RELATION_TASK')">
                                <a href="javascript:void(0);">Entity and Relation Annotation</a>
                            </li>
                            <li title=""
                                v-on:click="load_sample_ds('DOCUMENT_LEVEL_TASK')">
                                <a href="javascript:void(0);">Document-Level Annotation</a>
                            </li>
                            <li title="A sample for entity and relation annotation"
                                v-on:click="load_sample_ds('IAA_TASK')">
                                <a href="javascript:void(0);">IAA Calculation</a>
                            </li>
                            <li class="divider"></li>
                            
                            <li title="A minimal annotation task"
                                v-on:click="load_sample_ds('AMIA21_WORKSHOP')">
                                <a href="javascript:void(0);">AMIA 2021 Workshop</a>
                            </li>

                        </ul>
                    </div>

                    <button class="ribbon-button" 
                        v-on:click="show_wiki">
                        <span class="icon">
                            <i class="fa fa-info"></i>
                        </span>
                        <span class="caption">Wiki</span>
                    </button>

                    <span class="title">Help</span>
                </div>

            </div>

            <!-- the section for corpus schema -->
            <div class="section" id="section-1-2"
                v-bind:class="{'active': section=='corpus'}">

                <div class="group">
                    <button class="ribbon-button"
                        v-on:click="clear_corpus_all">
                        <span class="icon">
                            <i class="far fa-times-circle"></i>
                        </span>
                        <span class="caption">Clear All</span>
                    </button>

                    <span class="title">&nbsp;</span>
                </div>

                <div class="group">
                    <div id="dropzone_txt" class="dropzone">
                        <div v-if="txt_anns.length == 0" class="zone-text">
                            Drop <b>Raw Text</b> File <br>
                            Here
                        </div>
                        <div v-else>
                            {{ txt_anns.length }} txt files
                        </div>
                    </div>

                    <button class="ribbon-button"
                        :disabled="dtd == null"
                        v-on:click="open_txt_files">
                        <span class="icon">
                            <i class="far fa-file-code"></i>
                        </span>
                        <span class="caption">Open .txt Files</span>
                    </button>

                    <span class="title">Raw Text Files</span>
                </div>
                
                <div class="group">
                    
                    <div class="d-flex flex-column ml-2">
                        <div class="mt-1 mb-2">
                            <label for="">Prefix for XML Files</label>
                            <input type="text" class="ipt-md"
                                v-model="txt_xml_prefix">
                        </div>
                        <div>
                            <label for="">Suffix for XML Files</label>
                            <input type="text" class="ipt-md"
                                v-model="txt_xml_suffix">
                        </div>
                    </div>

                    <button class="ribbon-button"
                        :disabled="dtd == null || txt_anns.length == 0"
                        v-on:click="convert_txt_anns_to_xmls">
                        <span class="icon">
                            <i class="far fa-file-code"></i>
                        </span>
                        <span class="caption">Convert to XMLs</span>
                    </button>

                    <span class="title">Annotation XML File</span>
                </div>
                
                <div class="group">

                    <button class="ribbon-button"
                        :disabled="txt_xmls.length == 0 || txt_xmls.length != txt_anns.length"
                        v-on:click="download_txt_xmls_as_zip">
                        <span class="icon">
                            <i class="fa fa-download"></i>
                        </span>
                        <span class="caption">All as a ZIP</span>
                    </button>

                    <span class="title">Download</span>
                </div>

            </div>

            <!-- the section for statistics -->
            <div class="section" id="section-1-5"
                v-bind:class="{'active': section=='statistics'}">
                <div class="group">
                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="update_hint_dict">
                        <span class="icon">
                            <i class="fa fa-sync"></i>
                        </span>
                        <span class="caption">Refresh</span>
                    </button>

                    <span class="title">&nbsp;</span>    
                </div>

                <div class="group">
                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="download_stat_summary">
                        <span class="icon">
                            <i class="fa fa-download"></i>
                        </span>
                        <span class="caption">Summary (.csv)</span>
                    </button>

                    <span class="title">Download</span>    
                </div>
                
            </div>

            <!-- the section for ruleset -->
            <div class="section" id="section-1-4"
                v-bind:class="{'active': section=='ruleset'}">

                <div v-if="dtd != null"
                     class="group">
                    <div>
                        <p class="mb-1">
                            <i class="fa fa-list"></i>
                            Summary:
                        </p>
                        <p class="mb-1 mt-1">
                            <b>
                                {{ anns.length }}
                            </b>
                            Documents
                            <br>
                            <b>
                                {{ count_tags_in_anns(anns)}}
                            </b>
                            Annotated Tags
                        </p>
                    </div>

                    <span class="title">&nbsp;</span>
                </div>

                <div class="group">
                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="download_text_tsv">
                        <span class="icon">
                            <i class="far fa-file-excel"></i>
                        </span>
                        <span class="caption">Tag Text</span>
                    </button>

                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="download_text_sent_tsv">
                        <span class="icon">
                            <i class="far fa-file-excel"></i>
                        </span>
                        <span class="caption">Tag &amp; Sentence</span>
                    </button>

                    <span class="title">Text</span>
                </div>

                <div class="group">
                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        title="Download IOB2/BIO format"
                        v-on:click="download_dataset_iob2">
                        <span class="icon">
                            <i class="far fa-file"></i>
                        </span>
                        <span class="caption">IOB2/BIO (.tsv)</span>
                    </button>

                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        title="Download BioC format"
                        v-on:click="download_dataset_bioc">
                        <span class="icon">
                            <i class="far fa-file-code"></i>
                        </span>
                        <span class="caption">BioC (.xml)</span>
                    </button>

                    <span class="title">Dataset</span>
                </div>

                <div class="group">
                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="download_ruleset_medtagger_zip">
                        <span class="icon">
                            <i class="far fa-file-archive"></i>
                        </span>
                        <span class="caption">MedTagger (.zip)</span>
                    </button>

                    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

                    <button class="ribbon-button" 
                        :disabled="dtd == null"
                        v-on:click="download_ruleset_spacy_jsonl">
                        <span class="icon">
                            <i class="far fa-file-code"></i>
                        </span>
                        <span class="caption">spaCy (.jsonl)</span>
                    </button>
                    <span class="title">Ruleset</span>
                </div>
            </div>

            <!-- the section for iaa -->
            <div class="section" id="section-1-6"
                v-bind:class="{'active': section=='iaa'}">

                <div class="group">
                    <button class="ribbon-button"
                        v-on:click="clear_iaa_all">
                        <span class="icon">
                            <i class="far fa-times-circle"></i>
                        </span>
                        <span class="caption">Clear All</span>
                    </button>

                    <span class="title">&nbsp;</span>
                </div>

                <div class="group">

                    <div id="dropzone_iaa_0" class="dropzone-iaa"
                        iaa_id="0">
                        <div v-if="dtd == null" class="zone-text">
                            Load DTD file first<br>
                            in Annotation Tab
                        </div>
                        <div v-else-if="iaa_ann_list[0].anns.length == 0" class="zone-text">
                            Drop <b>Ann</b> File(s)<br>
                            Annotator <b>A</b>
                        </div>
                        <div v-else class="zone-text">
                            <b>Annotator A</b><br>
                            Annotated {{ count_tags_in_anns(iaa_ann_list[0].anns) }} Tags
                            <br>
                            in {{ iaa_ann_list[0].anns.length }} Files
                        </div>
                    </div>

                    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

                    <div id="dropzone_iaa_1" class="dropzone-iaa"
                        iaa_id="1">
                        <div v-if="dtd == null" class="zone-text">
                            Load DTD file first<br>
                            in Annotation Tab
                        </div>
                        <div v-else-if="iaa_ann_list[1].anns.length == 0" class="zone-text">
                            Drop <b>Ann</b> File(s)<br>
                            Annotator <b>B</b>
                        </div>
                        <div v-else class="zone-text">
                            <b>Annotator B</b><br>
                            Annotated {{ count_tags_in_anns(iaa_ann_list[1].anns) }} Tags
                            <br>
                            in {{ iaa_ann_list[1].anns.length }} Files
                        </div>
                    </div>

                    <span class="title">Annotation Files</span>
                </div>

                <div class="group">
                    <div class="mr-1">
                        <input type="radio" name="match_mode" 
                            value="overlap" 
                            data-role="radio" 
                            data-caption="<i class='fa fa-align-center'></i> Overlap" checked 
                            v-model="iaa_match_mode"
                            @change="on_change_iaa_settings">
                        <br>
                        <input type="radio" name="match_mode" 
                            value="exact" 
                            data-role="radio" 
                            data-caption="<i class='fa fa-align-justify'></i> Exact" 
                            v-model="iaa_match_mode"
                            @change="on_change_iaa_settings">
                    </div>
                    
                    <div v-if="iaa_match_mode == 'overlap'"
                        class="p-1 ml-1 mr-1 border bd-gray border-radius">

                        <div class="mt-1 mb-1">
                            <i class="fa fa-percentage"></i>
                            Overlap Ratio
                        </div>

                        <div>        
                            <input id="iaa_form_overlap_ratio" 
                                name="iaa_form_overlap_ratio" 
                                style="width: 36px"
                                type="text" class="ipt-md" 
                                v-model.number="iaa_overlap_ratio">
                            <span class="mr-1">
                                %
                            </span>

                            <button title="Reset the overlap ratio"
                                v-on:click="iaa_overlap_ratio = iaa_overlap_ratio_default">
                                <i class="fa fa-undo"></i>
                            </button>
                        </div>
                    </div>

                    <button class="ribbon-button"
                        v-on:click="calc_iaa">
                        <span class="icon">
                            <i class="fa fa-calculator"></i>
                        </span>
                        <span class="caption">Calculate All</span>
                    </button>

                    <span class="title">IAA</span>
                </div>
                
                <div class="group">
                    <div>
                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Show Agreed Tags"
                            v-model="iaa_display_tags_tp"
                            @change="on_change_iaa_settings">
                        <br>

                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Show Context"
                            v-model="iaa_display_tags_context"
                            @change="on_change_iaa_settings">

                    </div>
                    <span class="title">Tag Display</span>
                </div>

                
                <div class="group">
                    <div>
                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Adj. Panel"
                            v-model="iaa_display_adj_panel"
                            @change="on_change_iaa_settings">
                        <br>

                        <input type="checkbox" 
                            class="check"
                            data-role="switch" 
                            data-caption="Tag Detail"
                            v-model="iaa_display_adj_detail"
                            @change="on_change_iaa_settings">

                    </div>

                    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

                    <div>
                        <button class="ribbon-button" 
                            :disabled="dtd == null || iaa_dict == null"
                            v-on:click="make_default_adj">
                            <span class="icon">
                                <i class="far fa-object-group"></i>
                            </span>
                            <span class="caption">Reset G.S.</span>
                        </button>
                    </div>

                    <div>
                        <button class="ribbon-button" 
                            :disabled="dtd == null"
                            v-on:click="download_all_gs">
                            <span class="icon">
                                <i class="fa fa-file-download"></i>
                            </span>
                            <span class="caption">Download All</span>
                        </button>
                    </div>
                    
                    <span class="title">Adjudication</span>
                </div>

            </div>
        </div>

        <div id="app_info">
            MedTator 1.0.2 | 
            <a title="MedTator Settings"
                href="javascript:void(0);"
                v-on:click="cfg.is_show_settings = true">
                <i class="fa fa-cog"></i>
                Settings
            </a> | 
            <a target="_blank" 
                title="MedTator Source Code at GitHub"
                href="https://github.com/OHNLP/MedTator">
                <i class="fab fa-github"></i>
            </a>
        </div>

    </nav>

    <div id="app_settings"
        v-show="cfg.is_show_settings"
        class="box">
        <div class="box-header d-flex flex-justify-between">
            <h4>
                <i class="fa fa-cog"></i>
                MedTator Settings
            </h4>
            <div>
                <button v-on:click="cfg.is_show_settings = false">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </div>
        <div class="box-body">
            <div class="d-flex flex-row">
                <div class="px-2 setting-tab"
                    v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='import'}"
                    v-on:click="switch_setting_tab('import')">
                    <i class="far fa-file"></i>
                    Import
                </div>

                <!-- <div class="px-2 setting-tab"
                    v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='external_data'}"
                    v-on:click="switch_setting_tab('external_data')">
                    <i class="fa fa-table"></i>
                    Data
                </div> -->
            </div>

            <!-- import setting tab -->
            <div v-if="cfg.active_setting_tab == 'import'">
                <div class="box-body-item">
                    <p>
                        Sentence Splitting Algorithm
                        <a href="javascript:void(0);"
                            v-on:click="show_help('sentence_splitting_algorithm')">
                            <i class="far fa-question-circle"></i>
                        </a>:
                    </p>
                    <ul class="box">
                        <li>
                            <input type="radio" id="cfg_ssa_v1" 
                                value="simpledot" 
                                v-model="cfg.sentence_splitting_algorithm">
                            <label for="cfg_ssa_v1">Simple Method (Default)</label>
                        </li>
                        <li>
                            <input type="radio" id="cfg_ssa_v2" 
                                value="compromise" 
                                v-model="cfg.sentence_splitting_algorithm">
                            <label for="cfg_ssa_v2">Compromise NLP</label>
                        </li>
                        <li>
                            <input type="radio" id="cfg_ssa_v3" 
                                value="wink_nlp" 
                                v-model="cfg.sentence_splitting_algorithm">
                            <label for="cfg_ssa_v3">Wink NLP Sentence Tokenization</label>
                        </li>
                    </ul>
                </div>
            </div>

            <!-- data setting tab -->
            <div v-else-if="cfg.active_setting_tab == 'external_data'">
                <div class="box-body-item">
                    <p>
                        TBD
                    </p>
                    
                </div>
            </div>

            <div v-else>
                &nbsp;
            </div>

        </div>
    </div>

    <!-- the ui for main annotation -->
    <div v-show="section=='annotation'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 60%;">
        <div id="mui_filelist"
            class="d-flex flex-column flex-justify-start flex-align-start h-100">
            <div id="mui_filelist_toolbar"
                class="d-flex flex-row flex-justify-between flex-align-center w-100">
                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <span class="mr-1"
                        title="Filter the files by file name">
                        Filter: 
                    </span>
                    <input type="text" 
                        class="ipt-xs mr-1"
                        v-model="fn_pattern">
                
                    <span v-if="anns.length > 0">
                        {{ anns.length }} files
                    </span>
                </div>

                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <button class="btn-xs"
                        title="Remove all files"
                        v-on:click="remove_all_ann_files">
                        <i class="far fa-trash-alt"></i>
                        All
                    </button>
                </div>
            </div>
            <div id="mui_filelist_list" 
                class="d-flex flex-column flex-justify-start flex-align-start w-100 h-100">

                <ul class="w-100 file-list">
                    <li v-for="ann, idx in anns"
                        v-show="idx == ann_idx || is_match_filename(ann._filename)"
                        v-bind:class="{'file-selected':idx == ann_idx}"
                        class="file-list-item">
                        <div class="d-flex flex-row flex-justify-between">
                            <div class="file-list-item-name"
                                style="flex-grow: 1;"
                                v-on:click="set_ann_idx(idx)"
                                v-bind:title="ann._filename"
                                v-bind:class="{'file-list-item-name-unsaved':!ann._has_saved}">

                                <a href="javascript:void(0);"
                                    v-show="!ann._has_saved" 
                                    v-on:click="save_xml_by_idx(idx)"
                                    title="Save this annotation file"
                                    class="icon-fg-unsaved mr-1">
                                    <i class="fa fa-save"></i>
                                </a>
                                
                                <span>
                                    {{ ann._filename }}
                                </span>
                            </div>

                            <div class="d-flex flex-row">
                                <div class="mr-2"
                                    v-bind:title="'Annotated ' + ann.tags.length + ' tags'">
                                    {{ ann.tags.length }}
                                </div>

                                <div v-bind:title="'Remove ' + ann._filename">
                                    <a v-on:click="remove_ann_file(idx)"
                                        class="btn btn-red btn-xs"
                                        href="javascript:void(0);">
                                        <i class="fa fa-minus-circle"></i>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_texteditor">
            <div id="cm_editor" class="w-100">
                
            </div>
        </div>
        
    </div>
    <div class="v-splitter"></div>
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 40%;">
        <div id="mui_dtdlist" 
            class="d-flex h-100">
            <ul v-if="dtd != null"
                class="w-100 tag-list">

                <li v-on:click="update_tag_table(null)"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == '__all__'}">
                    <div class="tag-list-row-name"
                        v-on:click="display_tag_name = '__all__'">
                        <span class='mif-folder fg-red'></span>
                        All Tags
                    </div>
                    <div class="mr-1">
                        {{ count_n_tags(null) }}
                    </div>
                </li>

                <!-- show all etags -->
                <li v-for="etag in dtd.etags"
                    v-on:click="update_tag_table(etag)"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == etag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="display_tag_name = etag.name">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + etag.name">
                        </i>
                        <span v-if="etag.hasOwnProperty('shortcut')"
                            class="badge-shortcut mr-1">
                            {{ etag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(etag)">
                            
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null && etag.is_non_consuming"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty entity tag"
                                v-on:click="add_empty_etag(etag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(etag)">
                            {{ count_n_tags(etag) }}
                        </div>
                    </div>
                </li>

                <!-- show all link tags -->
                <li v-for="ltag in dtd.ltags"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == ltag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="display_tag_name = ltag.name">
                        <i class="fa fa-link"
                            v-bind:class="'fg-tag-' + ltag.name">
                        </i>
                        <span v-if="ltag.hasOwnProperty('shortcut')"
                            class="badge-shortcut mr-1">
                            {{ ltag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(ltag)">
                            
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty link tag"
                                v-on:click="add_empty_ltag(ltag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(ltag)">
                            {{ count_n_tags(ltag) }}
                        </div>
                    </div>

                </li>

            </ul>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_annlist" 
            class="d-flex flex-justify-start flex-align-start h-100">
            <table v-if="dtd!=null && ann_idx != null" class="tag-table w-100 mt-0 mb-0">
                <thead>
                    <tr>
                        <th class="tag-name">Tag</th>
                        <th class="tag-id">ID</th>
                        <th class="tag-span">Spans</th>
                        <th class="tag-text">Text</th>
                        <th class="tag-attr">Attributes</th>
                    </tr>
                </thead>
                <tbody style="overflow-y: auto;">
                    <tr v-for="tag, tag_idx in anns[ann_idx].tags"
                        v-if="tag.tag == display_tag_name || display_tag_name == '__all__'">
                        <td>
                            <div class="d-flex flex-row flex-justify-between">
                                <div>
                                    <i v-if="get_tag_def(tag.tag).type == 'etag'" 
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    <i v-else class="fa fa-link"
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    {{ tag.tag }}
                                </div>

                                <div class="mr-2">
                                    <button class="btn btn-xs btn-red"
                                        title="Delete this tag"
                                        v-on:click="del_tag(tag.id)">
                                        <i class="fa fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </td>

                        <td>
                            <span class="c-pointer">
                                {{ tag.id }}
                            </span>
                        </td>

                        <td>
                            <span v-if="tag.spans=='-1~-1'">
                                DOCUMENT
                            </span>
                            <span v-else
                                v-on:click="highlight_tag(tag)"
                                class="c-pointer">
                                {{ tag.spans }}
                            </span>
                        </td>

                        <td class="td-text">
                            <span v-if="is_etag(tag)"
                                class="c-pointer"
                                v-on:click="highlight_tag(tag)">
                                {{ tag.text }}
                            </span>
                            <span v-else>
                            </span>
                        </td>

                        <td class="d-flex flex-row flex-justify-start flex-align-start flex-wrap">
                            <div v-for="(attlist, attlist_idx) in dtd.tag_dict[tag.tag].attlists"
                                v-if="!['id','spans','text','tag'].contains(attlist.name)"
                                class="tag-attr-box mr-1 d-flex flex-column">
                                <div class="tag-attr-name">
                                    {{ attlist.name }}
                                    <span v-if="attlist.require == 'REQUIRED'"
                                        class="clr-red">
                                        *
                                    </span>
                                    <span v-else>
                                        &nbsp;
                                    </span>
                                </div>
                                
                                <div v-if="attlist.vtype == 'list'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @change="on_change_attr_value">
                                        <option v-for="val in attlist.values"
                                            v-bind:value="val">
                                            {{ val }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else-if="attlist.vtype == 'text'">
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @input="on_input_attr_value">
                                </div>
                                <div v-else-if="attlist.vtype == 'idref'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @change="on_change_idref_value">
                                        <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                            v-bind:value="s_etag.id">
                                            {{ s_etag.id }}
                                            |
                                            {{ s_etag.tag }}
                                            -
                                            {{ s_etag.text }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else>
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @input="on_input_attr_value">
                                </div>
                            </div>
                            
                            
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div v-if="is_linking"
        ref="pan_working_tag_box"
        id="pan_working_tag"
        class="d-flex flex-column">
        <div class="p-2 mb-1"
            id="pan_working_tag_title"
            @mousedown="dragMouseDown">
            Creating a Link Tag
            <b>{{ linking_tag.tag }}</b>
        </div>
        <div class="d-flex flex-row p-1 border-bottom">
            <button class="btn-xs mr-1"
                title="Using the following values to create a link tag"
                v-on:click="done_linking();">
                <i class="fa fa-check-circle"></i>
                Done Linking
            </button>
            <button class="btn-xs"
                title="Stop creating a link tag and drop the following values"
                v-on:click="cancel_linking();">
                <i class="far fa-times-circle"></i>
                Cancel Linking
            </button>
        </div>
        <div class="d-flex flex-column p-1 pr-2">
            <div v-for="attlist in linking_tag_def.attlists"
                class="d-flex flex-row ltag-attr-row p-1 mb-1">
                <div class="d-flex ltag-attr-name pr-1">
                    &nbsp;- 
                    {{ attlist.name }}
                </div>
                <div class="d-flex ltag-attr-value">
                    <div v-if="attlist.vtype == 'idref'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attlist.name]">
                            <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                v-bind:value="s_etag.id">
                                {{ s_etag.id }}
                                |
                                {{ s_etag.tag }}
                                -
                                {{ s_etag.text }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else-if="attlist.vtype == 'text'"
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attlist.name]">
                    </div>
                    <div v-else-if="attlist.vtype == 'list'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attlist.name]">
                            <option v-for="val in attlist.values"
                                v-bind:value="val">
                                {{ val }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attlist.name]">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <!-- the ui for corpus -->
    <div v-show="section=='corpus'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

        <div class="box w-100">
            <div class="box-header">
                <h4>
                    <i class="fa fa-list-ul"></i>
                    Corpus Files
                </h4>
            </div>

            <div class="box-body" style="overflow-y: auto;">
                <table class="table striped">
                    <tr>
                        <th>#</th>
                        <th>TXT File Name</th>
                        <th>&nbsp;</th>
                        <th>XML File Name</th>
                    </tr>
                    <tr v-for="txt_ann, txt_ann_idx in txt_anns">
                        <td>
                            {{ txt_ann_idx + 1 }}
                        </td>
                        <td>
                            <i class="far fa-file-alt"></i>
                            {{ txt_ann._filename }}
                        </td>
                        <td>
                            <span>
                                <i class="fa fa-arrow-right"></i>
                            </span>
                        </td>
                        <td>
                            <span v-if="txt_xmls.length > txt_ann_idx">
                                <i class="far fa-file-code"></i>
                                {{ get_new_xml_filename(txt_xmls[txt_ann_idx].fn) }}

                                <span>
                                    <a href="javascript:void(0);"
                                        v-on:click="download_txt_xml(txt_ann_idx)"
                                        v-bind:title="'Download ' + get_new_xml_filename(txt_xmls[txt_ann_idx].fn)">
                                        <i class="fa fa-download"></i>
                                        Download
                                    </a>
                                </span>
                            </span>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
        <!-- /.box -->
        

    </div>
</div>

    <!-- the ui for ruleset / export -->
    <div v-show="section=='ruleset'" id="main_ui"
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">
        <div id="mui_ruleset_result" class="d-flex w-100 h-100">
            <div class="box w-100">
                <div class="box-header">
                    <h4>
                        <i class="far fa-file-alt"></i>
                        Export Preview
                    </h4>
                </div>

                <div v-if="export_text != null"
                    class="box-body h-100">

                    <textarea v-model="export_text" class="w-100 h-100" style="font-family: 'Courier New', Courier, monospace;"></textarea>
                    
                </div>
            </div>
            <!-- /.box -->
        </div>
    </div>
</div>

    <!-- the ui for iaa -->
    <div v-show="section=='iaa'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

        <div id="mui_iaa_summary" class="d-flex h-100 mr-1">
            <div v-if="dtd != null && iaa_dict != null" class="box h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-list-ul"></i>
                        Summary
                    </h4>
                </div>
                <div class="box-body">

                    <div>
                        <div class="iaa-row iaa-row-header d-flex flex-row">
                            <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                Tag Name
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                                F1
                            </div>
                        </div>

                        <!-- special for the overall result -->
                        <div class="iaa-row d-flex flex-row"
                            v-bind:class="{'iaa-row-actived': iaa_display_tag_name == '__all__'}"
                            v-on:click="iaa_display_tag_name = '__all__'">
                            <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                OVERALL
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                                <div v-bind:style="'width:' + to_width(iaa_dict.all.f1) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="ml-1">
                                    <span style="font-size: 1.2em; font-weight: bold;">
                                        {{ to_fixed(iaa_dict.all.f1) }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- for each tag -->
                        <div v-for="etag in dtd.etags"
                            class="iaa-row d-flex flex-row"
                            v-bind:class="{'iaa-row-actived': iaa_display_tag_name == etag.name}"
                            v-on:click="iaa_display_tag_name = etag.name">
                            <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + etag.name">
                                </i>
                                <span>
                                    {{ etag.name }}
                                </span>
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <div v-bind:style="'width:' + to_width(iaa_dict.tag[etag.name].f1) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="ml-1">
                                    {{ to_fixed(iaa_dict.tag[etag.name].f1) }}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-3">
                        <p>
                            Text Matched Files: <b>{{ iaa_dict.stat.matched_hashcodes.length }}</b>
                        </p>
                        <p>
                            Duplicated Files: <b>{{ iaa_dict.stat.duplicates.length }}</b>
                        </p>
                        <p>
                            Unmatched Files: <b>{{ iaa_dict.stat.unmatched.length }}</b>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div id="mui_iaa_anns" class="d-flex h-100 ml-1 mr-1">
            <div v-if="dtd != null && iaa_dict != null" class="box w-100 h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-list"></i>
                        Annotation Files
                    </h4>
                </div>

                <div class="box-body">

                    <div class="iaa-row iaa-row-header d-flex flex-row">
                        <div class="iaa-bar-filename-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                            File names
                        </div>
                        <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                            <span v-if="iaa_display_tag_name == '__all__'">
                                OVERALL
                            </span>
                            <span v-else>
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + iaa_display_tag_name">
                                </i>
                                <span>
                                    {{ iaa_display_tag_name }}
                                </span>
                            </span>
                            &nbsp;
                            <span>
                                F1
                            </span>
                        </div>
                    </div>

                    <div v-for="ann_rst, ann_hashcode in iaa_dict.ann"
                        class="iaa-row d-flex flex-row"
                        v-bind:class="{'iaa-row-actived': iaa_display_hashcode == ann_hashcode}"
                        v-on:click="iaa_display_hashcode = ann_hashcode">
                        <div class="iaa-bar-filename-box d-flex flex-column flex-align-center flex-justify-start mr-1">
                            <div class="iaa-bar-filename w-100">
                                A: {{ ann_rst.anns[0]._filename }}
                            </div>
                            <div class="iaa-bar-filename w-100">
                                B: {{ ann_rst.anns[1]._filename }}
                            </div>
                            <div class="iaa-bar-filename w-100">
                                <span title="Set check"
                                    v-on:click="iaa_gs_dict[ann_hashcode].ann._has_star = !iaa_gs_dict[ann_hashcode].ann._has_star">
                                    <span v-if="iaa_gs_dict[ann_hashcode].ann._has_star">
                                        <i class="fa fa-check-circle fg-emerald"></i>
                                    </span>
                                    <span v-else>
                                        <i class="far fa-circle"></i>
                                    </span>
                                </span>
                                
                                GS: {{ iaa_gs_dict[ann_hashcode].ann._filename }}
                            </div>
                        </div>

                        <div class="d-flex flex-column">
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <div v-bind:style="'width:' + to_width(get_rst(ann_rst.rst)['f1']) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="iaa-bar-value ml-1">
                                    {{ to_fixed(get_rst(ann_rst.rst)['f1']) }}
                                </div>
                            </div>
                            <div class="iaa-file-cm-box">
                                <span class="mr-2">
                                    <span class="iaa-op-50">AB: </span>
                                    {{ get_rst(ann_rst.rst).cm.tp }}
                                </span>
                                <span class="mr-2">
                                    <span class="iaa-op-50">A+: </span>
                                    {{ get_rst(ann_rst.rst).cm.fp }}
                                </span>
                                <span class="mr-2">
                                    <span class="iaa-op-50">B+: </span>
                                    {{ get_rst(ann_rst.rst).cm.fn }}
                                </span>
                            </div>
                            <div class="iaa-file-gs-box">
                                <span class="mr-2">
                                    <span class="iaa-op-50">
                                        <span v-if="iaa_display_tag_name == '__all__'">
                                            OVERALL
                                        </span>
                                        <span v-else>
                                            {{ iaa_display_tag_name }}
                                        </span>
                                        in GS:
                                    </span> 
                                    {{ count_gs_tags(ann_hashcode) }}
                                </span>
                            </div>
                        </div>
                    </div>

                </div>

            </div>
        </div>

        <div id="mui_iaa_tags" class="d-flex h-100 ml-1">
            <div v-if="dtd != null && iaa_dict != null && iaa_display_hashcode != null" class="box w-100 h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-tag"></i>
                        Annotated Tags
                    </h4>
                </div>

                <div v-if="iaa_display_hashcode != null"
                    class="box-body d-flex flex-column">
                    <div class="w-100 d-flex flex-row">

                        <div class="iaa-tag-detail-header iaa-tag-detail-a"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <i class="fa fa-user"></i>
                            A 
                            {{ iaa_dict.ann[iaa_display_hashcode].anns[0]._filename }}
                        </div>

                        <div class="iaa-tag-detail-header"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <i class="fa fa-user"></i>
                            B
                            {{ iaa_dict.ann[iaa_display_hashcode].anns[1]._filename }}
                        </div>

                        <div v-if="iaa_display_adj_panel"
                            v-on:click="iaa_gs_dict[iaa_display_hashcode].ann._has_star = !iaa_gs_dict[iaa_display_hashcode].ann._has_star"
                            title="Set check"
                            class="iaa-tag-detail-header iaa-tag-detail-g iaa-tag-detail-g-header iaa-w-20">
                            <span v-if="iaa_gs_dict[iaa_display_hashcode].ann._has_star">
                                <i class="fa fa-check-circle fg-emerald"></i>
                            </span>
                            <span v-else>
                                <i class="far fa-circle"></i>
                            </span>
                            <span>
                                {{ iaa_gs_dict[iaa_display_hashcode].ann._filename }}
                            </span>
                            
                        </div>
                        
                    </div>

                    <div v-for="tag_rst, tag_name in iaa_dict.ann[iaa_display_hashcode].rst.tag"
                        v-if="iaa_display_tag_name == '__all__' || iaa_display_tag_name == tag_name"
                        class="w-100 mb-2">
                            
                        <div class="iaa-tag-name d-flex flex-row">
                            <div class="iaa-tag-name-ab mr-1"
                                :class="{'iaa-w-80': iaa_display_adj_panel, 'iaa-w-100': !iaa_display_adj_panel}">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + tag_name">
                                </i>
                                <span class="mr-2">
                                    {{ tag_name }}
                                </span>
                                <span class="mr-2">
                                    AB: {{ tag_rst.cm.tp }}
                                </span>
                                <span class="mr-2">
                                    A+: {{ tag_rst.cm.fp }}
                                </span>
                                <span class="mr-2">
                                    B+: {{ tag_rst.cm.fn }}
                                </span>
                            </div>

                            <div v-if="iaa_display_adj_panel"
                                class="iaa-tag-name-g iaa-tag-detail-g iaa-w-20">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + tag_name">
                                </i>
                                <span class="mr-2">
                                    {{ tag_name }}
                                </span>
                                <span v-if="iaa_gs_dict != null">
                                    Total: {{ count_iaa_gs_tag_notnull(iaa_gs_dict[iaa_display_hashcode].rst[tag_name]) }}
                                </span>
                                <span v-else>
                                    &nbsp;
                                </span>
                            </div>
                        </div>

                        <div v-if="iaa_display_tags_tp"
                            class="iaa-tag-rsts-tp w-100">
                            <!-- last, show the TP group -->
                            <div v-for="tags_tp, tag_idx in tag_rst.cm.tags.tp"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:from="'a'"
                                        v-bind:tag="tags_tp[0]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>
                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:from="'b'"
                                        v-bind:tag="tags_tp[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>
                                <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].tp[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>

                                </div>
                            </div>

                        </div>                            

                        <div class="iaa-tag-rsts-fp w-100">
                            <!-- first, show the FP group -->
                            <div v-for="tags_fp, tag_idx in tag_rst.cm.tags.fp"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:from="'a'"
                                        v-bind:tag="tags_fp[0]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-if="tags_fp[1] != null"
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:from="'b'"
                                        v-bind:tag="tags_fp[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fp[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>
                                </div>
                            </div>
                        </div>

                        <div class="iaa-tag-rsts-fn w-100">
                            <!-- second, show the FN group -->
                            <div v-for="tags_fn, tag_idx in tag_rst.cm.tags.fn"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    &nbsp;
                                </div>
                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fn'"
                                        v-bind:from="'b'"
                                        v-bind:tag="tags_fn[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div v-if="iaa_display_adj_panel"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fn'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fn[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    
    <!-- the ui for statistics -->
    <div v-show="section=='statistics'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

        <div id="mui_stat_summary" class="d-flex h-100">
            <div class="box w-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-list-ul"></i>
                        Summary
                    </h4>
                </div>

                <div v-if="dtd != null && anns.length != 0"
                    class="box-body">

                    <div v-for="stat_item in get_stat_items()"
                        class="box-body-item d-flex flex-row flex-justify-between">
                        <div>
                            {{ stat_item[0] }}: 
                        </div>
                        <div class="mr-2">
                            {{ stat_item[1] }}
                        </div>
                    </div>
                    
                </div>
            </div>
            <!-- /.box -->
        </div>


        <div id="mui_stat_details" class="d-flex ml-2">

            <div class="w-100 d-flex flex-row h-100">
                <div class="box w-100">
                    <div class="box-header">
                        <h4>
                            <i class="fa fa-list-ul"></i>
                            Annotated Tags
                        </h4>
                    </div>
                    <div v-if="dtd != null && anns.length > 0"
                        class="box-body" style="overflow-y: auto;">
                        <div class="d-flex flex-column w-100 h-100">
        
                            <div v-for="(tag_def, tag_def_idx) in dtd.etags"
                                class="ruleset-tag-item d-flex flex-row mb-1 pt-1 pb-1">
                                <div class="ruleset-tag-name pl-2 d-flex flex-row flex-justify-between"
                                    v-bind:class="'border-tag-' + tag_def.name">
                                    <div>
                                        <i class="fa fa-tag"
                                            v-bind:class="'fg-tag-' + tag_def.name">
                                        </i>
                                        {{ tag_def.name }}
                                    </div>
                                    <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                                        class="mr-2">
                                        {{ hint_dict[tag_def.name].texts.length }}
                                    </div>
                                    <div v-else>
                                        -
                                    </div>
                                </div>
        
                                <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                                    class="ruleset-tag-info d-flex flex-row flex-wrap">

                                    <!-- for the NC etags -->
                                    <div v-if="hint_dict[tag_def.name].nc_dict.count > 0"
                                        class="ruleset-tag-text mr-2 mb-2 d-flex flex-column">
                                        <div v-on:click="hint_dict[tag_def.name].nc_dict._is_shown = !hint_dict[tag_def.name].nc_dict._is_shown">
                                            <span class="ruleset-tag-text-count"
                                                v-bind:title="'Annotated ' + hint_dict[tag_def.name].nc_dict.count + ' times'">
                                                <i v-if="hint_dict[tag_def.name].nc_dict._is_shown"
                                                    class="fa fa-caret-down"></i>
                                                <i v-else
                                                    class="fa fa-caret-right"></i>
                                                {{ hint_dict[tag_def.name].nc_dict.count }}
                                            </span>
                                            <span class="ruleset-tag-text-str">
                                                <i class="far fa-file"></i>
                                                DOC-LEVEL
                                            </span>
                                        </div>
                                        <div v-show="hint_dict[tag_def.name].nc_dict._is_shown"
                                            class="ruleset-tag-text-filelist">
                                            <div v-for="(fn_v, fn) in hint_dict[tag_def.name].nc_dict.ann_fn_dict"
                                                v-on:click="show_ann_file(fn)"
                                                class="ruleset-tag-text-filelist-item">
                                                <span class="ruleset-tag-text-filelist-item-count">
                                                    {{ fn_v }}
                                                </span>
                                                <i class="fa fa-angle-right ml-1 mr-1"></i>
                                                <span>
                                                    {{ fn }}
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- for general etags -->
                                    <div v-for="(text_info, text) in hint_dict[tag_def.name].text_dict"
                                        class="ruleset-tag-text mr-2 mb-2 d-flex flex-column">
                                        <div v-on:click="hint_dict[tag_def.name].text_dict[text]._is_shown = !hint_dict[tag_def.name].text_dict[text]._is_shown">
                                            <span class="ruleset-tag-text-count"
                                                v-bind:title="'Annotated ' + text_info.count + ' times'">
                                                <i v-if="text_info._is_shown"
                                                    class="fa fa-caret-down"></i>
                                                <i v-else
                                                    class="fa fa-caret-right"></i>
                                                {{ hint_dict[tag_def.name].text_dict[text].count }}
                                            </span>
                                            <span class="ruleset-tag-text-str">
                                                {{ text }}
                                            </span>
                                        </div>
                                        <div v-show="text_info._is_shown"
                                            class="ruleset-tag-text-filelist">
                                            <div v-for="(fn_v, fn) in text_info.ann_fn_dict"
                                                v-on:click="show_ann_file(fn)"
                                                class="ruleset-tag-text-filelist-item">
                                                <span class="ruleset-tag-text-filelist-item-count">
                                                    {{ fn_v }}
                                                </span>
                                                <i class="fa fa-angle-right ml-1 mr-1"></i>
                                                <span>
                                                    {{ fn }}
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                </div>
        
                            </div>
        
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>
    

    <!-- the context menu -->
    <div v-if="dtd != null"
        style="display: none;"
        id="ctxmenu_sel">
        <li class="ui-widget-header"
            v-on:click="close_ctxmenu">Entity Tags:</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in dtd.etags"
            v-on:click="add_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_sel">

    </div>

    <!-- the context menu for non-consuming tags -->
    <div v-if="dtd != null && get_nc_etags().length > 0"
        style="display: none;"
        id="ctxmenu_nce">
        <li class="ui-widget-header"
            style="padding-right: 5px;"
            v-on:click="close_ctxmenu">Document-Level Tag</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in get_nc_etags()"
            v-on:click="add_nc_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_nce">

    </div>

    <!-- the tag click menu -->
    <div v-if="dtd != null"
        style="display: none;"
        id="popmenu_tag">
        <li class="ui-widget-header"
            v-on:click="close_popmenu">
            TAG <i class="fa fa-tag"></i>
            <b>{{ clicked_tag_id }}</b>
        </li>

        <div v-if="is_linking">
            <li v-for="att, att_idx in linking_atts"
                v-on:click="popmenu_set_linking(att_idx)"
                class="ctxmenu-item">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + linking_tag_def.name">
                    </i>
                    <b>{{ linking_tag_def.name }}</b>
                    -
                    <i>{{ att.name }}</i>
                </div>
            </li>

            <li class="ctxmenu-divider"></li>
            <li class="ctxmenu-item"
                v-on:click="cancel_linking()">
                <div>
                    <i class="far fa-times-circle"></i>
                    Cancel current linking
                </div>
            </li>
        </div>

        <div v-else>
            <li class="ctxmenu-item"
                v-for="ltag, ltag_idx in dtd.ltags"
                v-on:click="popmenu_start_linking(ltag)">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + ltag.name">
                    </i>
                    <b>{{ ltag.name }}</b>
                    -
                    <i>{{ get_idref_attlist_by_seq(ltag).name }}</i>
                </div>
            </li>
        </div>

        <li class="ctxmenu-divider"></li>
        <li class="ctxmenu-item"
            v-on:click="popmenu_del_tag()">
            <div>
                <i class="far fa-trash-alt"></i>
                Delete this tag
            </div>
        </li>
    </div>
    <div v-else
        id="popmenu_tag">

    </div>
    
</div>

<script>
function get_browser() {
    var ua = navigator.userAgent,tem,M=ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; 
    if(/trident/i.test(M[1])){
        tem=/\brv[ :]+(\d+)/g.exec(ua) || []; 
        return {name:'IE',version:(tem[1]||'')};
        }   
    if(M[1]==='Chrome'){
        tem=ua.match(/\bOPR|Edge\/(\d+)/)
        if(tem!=null)   {return {name:'Opera', version:tem[1]};}
        }   
    M=M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem=ua.match(/version\/(\d+)/i))!=null) {M.splice(1,1,tem[1]);}
    return {
      name: M[0],
      version: M[1]
    };
}
var _browser = get_browser();

var isIE = /*@cc_on!@*/false || !!document.documentMode;
var isCHROME = _browser.name == 'Chrome';
var isSAFARI = _browser.name == 'Safari';
var isFIREFOX = _browser.name == 'Firefox';

// the file system access api
var isFSA_API_OK = typeof(window.showOpenFilePicker) == 'function';
console.log('* isIE: ' + isIE);
console.log('* isCHROME: ' + isCHROME);
console.log('* isSAFARI: ' + isSAFARI);
console.log('* isFIREFOX: ' + isFIREFOX);
console.log('* isFSA_API_OK: ' + isFSA_API_OK);

var _NOT_SUPPORT_MSG = 'The visualization and annotation features require advanced web techniques, which are <b>NOT</b> supported by the web browser you are using.<br>'+
'Try using latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.';

var _LMT_SUPPORT_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> require latest HTML5 techniques, which are <b>NOT</b> supported by the web browser [' + _browser.name + '] you are using. <br>' +
'Try using latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.<br> '+
'Except for the file saving limitation, you can use all other functions.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

</script>
<!-- metro ui -->
<script src="https://cdn.metroui.org.ua/v4.3.2/js/metro.min.js"></script>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<!-- jQuery UI -->
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.min.js"></script>
<!-- Vue.js -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<!-- jszip -->
<script src="https://stuk.github.io/jszip/dist/jszip.js"></script>
<!-- filesaver -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
<!-- dayjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.36/dayjs.min.js"></script>
<!-- code mirror -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>
<!-- code mirror addon -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.2/addon/selection/active-line.min.js"></script>
<!-- code mirror addon for line jump -->

<!-- numjs -->
<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
<!-- compromise -->
<script src="https://unpkg.com/compromise"></script>
<!-- chart.js -->
<!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
<!-- PapaParse -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<!-- Shepherd -->
<script src="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/js/shepherd.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/css/shepherd.css">
<!-- wink-nlp customized bundle -->
<script src="./static/lib/wink-nlp/bundle-1.8.0.min.js"></script>
<!-- dataset spliter -->
<script src="./static/lib/ds-spliter/ds-spliter-1.0.0.min.js"></script>
<!-- format xml -->
<script src="https://cdn.jsdelivr.net/npm/xml-formatter@2.4.0/dist/browser/xml-formatter.js"></script>
<script>

// The file helper 
async function fs_open_files(pickerOpts) {
    const fhs = await window.showOpenFilePicker(pickerOpts);
    return fhs;
}

async function fs_read_txt_file_handle(fh, dtd, enabled_sentences) {
    if (typeof(dtd) == 'undefined') {
        dtd = {name: ''};
    }
    if (typeof(enabled_sentences) == 'undefined') {
        enabled_sentences = false;
    }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.txt2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences
    if (enabled_sentences) {
        var result = nlp_toolkit.sent_tokenize(ann.text);
        ann._sentences = result.sentences;
        ann._sentences_text = result.sentences_text;
    } else {
        ann._sentences = null;
        ann._sentences_text = null;
    }

    return ann;
}

async function fs_read_ann_file_handle(fh, dtd, enabled_sentences) {
    if (typeof(enabled_sentences) == 'undefined') {
        enabled_sentences = true;
    }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.xml2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences
    if (enabled_sentences) {
        var result = nlp_toolkit.sent_tokenize(ann.text);
        ann._sentences = result.sentences;
        ann._sentences_text = result.sentences_text;
    } else {
        ann._sentences = null;
        ann._sentences_text = null;
    }

    return ann;
}

async function fs_read_dtd_file_handle(fh) {
    const file = await fh.getFile();
    const text = await file.text();

    // create dtd
    var dtd = dtd_parser.parse(text);

    return dtd;
}

async function fs_write_ann_file(fh, content) {
    const writable = await fh.createWritable();
    
    // write the contents
    await writable.write(content);

    // close the file
    await writable.close();

    return fh;
}

async function fs_get_new_ann_file_handle(fn) {
    const options = {
    suggestedName: fn,
      types: [
        {
          description: 'Text Files',
          accept: {
            'text/xml': ['.xml'],
          },
        },
      ],
    };
    const handle = await window.showSaveFilePicker(options);
    return handle;
}

async function fs_save_new_ann_file(ann, dtd) {
    // create a new fh by the suggested ann filename
    const fh = await fs_get_new_ann_file_handle(ann._filename);

    // update the filename according to fh
    ann._fh = fh;
    ann._filename = fh.name;

    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_ann_file(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}

async function fs_save_ann_file(ann, dtd) {
    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_ann_file(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}

// The DTD parser
var dtd_parser = {
    regex: {
        entity: /\<\!ENTITY\ name\ "([a-zA-Z\-0-9\_]+)"\>/gmi,
        element: /^\<\!ELEMENT\s+([a-zA-Z\-0-9\_]+)\s.+/gmi,
        attlist: /^\<\!ATTLIST\s+([a-zA-Z\-0-9\_]+)\s+([a-zA-Z0-9\_]+)\s+(\S+)\s/gmi,
        attlist_values: /\(([a-zA-Z0-9\_\ \|\-]+)\)/gmi,
        attlist_require: /#([A-Z]+)+(\b["a-zA-Z0-9\-\_\ ]+|\>)/gm,
        attlist_prefix: /prefix="([a-zA-Z0-9\_]+)"/gm,
        // attlist_cdata_default_value: /(?<=").*?(?=")/gm
        attlist_cdata_default_value: /\s+\"(.*)\"/g

    },

    NON_CONSUMING_SPANS: '-1~-1',

    parse: function(text) {
        var lines = text.split('\n');

        var dtd = {
            id_prefixd: {},
            name: '',
            tag_dict: {},
            etags: [],
            ltags: []
        };

        for (let l = 0; l < lines.length; l++) {
            const line = lines[l];
            
            // check this line
            var ret = this.parse_line(line);

            if (ret == null) {
                // nothing happens
                console.log('* null dtd line: ', line);
                continue;

            } else if (ret.type == 'entity') {
                dtd.name = ret.name;

            } else if (ret.type == 'etag') {
                // check the id by a looping
                while (true) {
                    if (dtd.id_prefixd.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefixd[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'ltag') {
                // check the id
                while (true) {
                    if (dtd.id_prefixd.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefixd[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'attr') {
                // put this attr to an element
                dtd.tag_dict[ret.element].attlists.push(
                    ret
                );

            } else {
                // what???
            }
        }
        
        // post processing for all tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                if (dtd.tag_dict[name].type == 'etag') { 
                    // check the attlist to make sure no missing
                    for (let i = 0; i < dtd.tag_dict[name].attlists.length; i++) {
                        if (dtd.tag_dict[name].attlists[i].vtype == 'dfix') {
                            // which means this is a non-consuming tag
                            dtd.tag_dict[name].is_non_consuming = true;
                        }
                    } 

                }  else {

                    // for link tag, need to check how many attlists are found
                    var cnt_idrefs = 0;
                    for (let i = 0; i < dtd.tag_dict[name].attlists.length; i++) {
                        if (dtd.tag_dict[name].attlists[i].vtype == 'idref') {
                            cnt_idrefs += 1;
                        }
                    }

                    // if there is not idref, just create two:
                    if (cnt_idrefs == 0) {
                        // create from and to
                        var attlist_from = this.mk_attlist(name, 'from', 'idref');
                        var attlist_to = this.mk_attlist(name, 'to', 'idref');
                        dtd.tag_dict[name].attlists = [attlist_from, attlist_to].concat(
                            dtd.tag_dict[name].attlists
                        );
                        console.log('* added from+to to the attlist of ' + name);
                    }
                }
                
            }
        }

        // split the tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                // now, create a attlist_dict for each tag
                dtd.tag_dict[name].attlist_dict = this.make_attlist_dict(
                    dtd.tag_dict[name]
                );

                // last, put this tag to list
                var element = dtd.tag_dict[name];
                if (element.type == 'etag') {
                    dtd.etags.push(element);
                } else {
                    dtd.ltags.push(element);
                }
            }
        }

        return dtd;
    },

    parse_line: function(line) {
        var obj = null;
        var ret = null;

        // try entity
        ret = this.get_entity(line);
        if (ret != null) { return ret; }

        // try element
        ret = this.get_element(line);
        if (ret != null) { return ret; }

        // try attlist
        ret = this.get_attlist(line);

        return ret;
    },

    get_entity: function(text) {
        let m;
        var ret = null;
        let regex = this.regex.entity;

        while ((m = regex.exec(text)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found entity match, group ${groupIndex}: ${match}`);
                ret = {
                    name: match,
                    type: 'entity'
                };
            });
        }

        return ret;
    },

    get_element: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.element;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var element = {
                name: '',
                type: 'etag',
                id_prefix: '',
                is_non_consuming: false,
                attlists: []
            };

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found element match, group ${groupIndex}: ${match}`);
                // group 0 is the leading line
                if (groupIndex == 1) {
                    element.name = match;
                    element.id_prefix = match.substring(0, 1);
                } 
            });
        
            // check the element type
            if (line.lastIndexOf('EMPTY')>=0) {
                element.type = 'ltag';
            }

            ret = element;
        }

        return ret;

    },

    get_attlist: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var attlist = this.mk_attlist();
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    attlist.element = match;

                } else if (groupIndex == 2) {
                    // which means it is the attr of this element
                    attlist.name = match;

                    // special rule for some attrs
                    if (match == 'spans') {
                        // for attr `spans`, need to update the elememt
                        attlist.vtype = 'dfix';
                        attlist.default_value = this.NON_CONSUMING_SPANS;
                    }

                } else if (groupIndex == 3) {
                    if (match == 'CDATA') {
                        // ok, it's just a text content
                        attlist.vtype = 'text';
                        
                        // then get the default value
                        attlist.default_value = this.get_attlist_cdata_default_value(line);

                    } else if (match == '(') {
                        // this is a list
                        attlist.vtype = 'list';

                        // get the values
                        attlist.values = this.get_attlist_values(line);

                    } else if (match == 'IDREF') {
                        // it's an attr for link tag
                        attlist.vtype = 'idref';

                        if (this.is_argN(attlist.name)) {
                            // ok
                        } else {
                            // IDREF's default name must argX
                            // but ... why?
                            console.error('* error name for this "', line, '", attlist name should be argX format');
                        }

                        // then, check if there is prefix
                        var prefix = this.get_attlist_prefix(line);
                        if (prefix == null) {
                            // which means this attlist doesn't have a prefix
                            // for renaming the extraction
                        } else {
                            // use the prefix to replace this name
                            attlist.name = prefix;
                        }
                    }
                } else {
                    // what?
                }
            });

            // before end, check the require info
            var require = this.get_attlist_require(line);
                        
            if (require.length == 0) {
                // which means this attlist has nothing

            } else if (require.length == 1) {
                // which means just has the require name it self
                attlist.require = require[0];

            } else if (require.length == 2) {
                // which means it has the default value!
                attlist.require = require[0];
                attlist.default_value = require[1];
            }

            ret = attlist;
        }

        return ret;
    },

    get_attlist_values: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attlist_values;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var values = [];
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist values match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    var ps = match.split('|');
                    for (let i = 0; i < ps.length; i++) {
                        const p = ps[i];
                        var _p = p.trim();
                        values.push(_p);
                    }
                } 
            });

            ret = values;
        }

        return ret;
    },

    get_attlist_require: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attlist_require;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var values = [];

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist require match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the require name
                    // IMPLIED or REQUIRED
                    values.push(match)
                } else if (groupIndex == 2) {
                    // get default value 
                    var t = match.replaceAll('"', '');
                    t = t.replaceAll('>', '');
                    t = t.trim();

                    // not matter what is left, save it
                    values.push(t);
                }
            });

            ret = values;
        }

        
        return ret;
    },

    get_attlist_prefix: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist_prefix;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    get_attlist_cdata_default_value: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist_cdata_default_value;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    make_attlist_dict: function(tag) {
        let attlist_dict = {};

        for (let i = 0; i < tag.attlists.length; i++) {
            attlist_dict[tag.attlists[i].name] = tag.attlists[i];
        }

        return attlist_dict;
    },

    get_next_id_prefix: function(element) {
        var ret = element.name.substring(
            0,
            element.id_prefix.length + 1
        );

        return ret;
    },

    ///////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////
    get_id_prefix: function(tag_name, dtd) {
        if (dtd.tag_dict.hasOwnProperty(tag_name)) {
            return dtd.tag_dict[tag_name].id_prefix;
        }
        return '';
    },

    is_argN: function(name) {
        if (name.startsWith('arg')) {
            if (/^\d+$/.test(name.substring(3))) {
                return true;
            }
        }
        return false;
    },

    mk_attlist: function(element='', name='', vtype='') {
        return {
            element: element,
            name: name,
            type: 'attr',
            vtype: vtype,
            require: '',
            values: [],
            default_value: null,
        };
    }
};

// The Ann parser
/**
 * Annotation file parser
 * 
 * The ann used in this tool is an object following this format:
 * {
 *  _fh: FileSystemHandle,
 *  _has_saved: true/false,
 *  text: '',
 *  dtd_name: '',
 *  tags: [{
 *    id: '',
 *    tag: '',
 *    spans: '', // this may not be available
 *    text: '',  // this may not be available
 * 
 *  }]
 * }
 * 
 * the `_fh` is added outside of parser.
 * the `_has_saved` is added outside
 */
var ann_parser = {
    NON_CONSUMING_SPANS: '-1~-1',

    txt2ann: function(txt, dtd) {
        var ann = {
            text: txt,
            dtd_name: dtd.name,
            tags: []
        };

        return ann;
    },

    xml2ann: function(text, dtd) {
        // create a new DOM parser
        var parser = new DOMParser();

        // parse the given text
        var xmlDoc = parser.parseFromString(text, "text/xml");

        // create an empty ann
        var ann = {
            text: '',
            dtd_name: '',
            tags: []
        };

        // first, get the dtd name
        var dtd_name = xmlDoc.children[0].tagName;
        ann.dtd_name = dtd_name;

        if (dtd.name != ann.dtd_name) {
            throw {
                name: 'Not match given DTD',
                message: 'The task name in XML (' + ann.dtd_name + ') does NOT match the given DTD (' + dtd.name + ')'
            };
        }

        // then get the text content
        var textContent = xmlDoc.getElementsByTagName('TEXT')[0].textContent;
        ann.text = textContent;

        // then check all of the tags
        if (xmlDoc.getElementsByTagName('TAGS').length == 0) {
            // it's possible that there is no tags at all
            // then we could skip
        } else {
            var elems = xmlDoc.getElementsByTagName('TAGS')[0].children;

            for (let i = 0; i < elems.length; i++) {
                var elem = elems[i];

                // get the attributes
                var tag_name = elem.tagName;

                // create a new empty tag
                var tag = {
                    tag: tag_name
                };

                // get all attr names
                var attrs = elem.getAttributeNames();

                // get all attr values
                for (let j = 0; j < attrs.length; j++) {
                    var attr = attrs[j];
                    var value = elem.getAttribute(attr);

                    // there are exceptions
                    if (attr.toLocaleLowerCase() == 'text') {
                        // special rule for the text attr
                        // due to the bad convertion
                        tag['text'] = value;

                    } else if (attr.toLocaleLowerCase() == 'spans') {
                        // special rule for the text attr
                        // due to the bad convertion
                        // tag['spans'] = value;

                        // fix the wrong values
                        var locs = this.spans2locs(value);
                        var spans = this.locs2spans(locs);

                        if (value != spans) {
                            console.log('* fixed wrong format spans ' + value + ' -> ' + spans);
                        }
                        tag['spans'] = spans;

                    } else if (attr.endsWith('ID')) {
                        // omg, this may be a link tag
                        // let's check if there is a xxxText attr
                        var attr_prefix_name = attr.substring(0, attr.length-2);
                        var attrText_name = attr_prefix_name + 'Text';
                        if (attrs.indexOf(attrText_name)>=0) {
                            // ok, I'm sure this is a idref att
                            // the value is the etag id
                            // let's save it and goto next
                            tag[attr_prefix_name] = value;
                            continue;

                        } else {
                            // what??? ok, this is just a normal but weird attr
                            // just save it later

                        }
                    } else if (attr.endsWith('Text')) {
                        // I guess we could skip this one
                        continue;

                    } else {
                        // other special rule? maybe
                        // put this value into tag
                        tag[attr] = value;
                    }
                }

                // one more step, need to check whether this tag belongs to dtd
                // if not, skip the next step
                if (dtd.tag_dict.hasOwnProperty(tag_name)) {
                    // one more step, sometimes the attr in XML doesn't contain
                    // what defined int dtd, so we need to give a value
                    for (let k = 0; k < dtd.tag_dict[tag_name].attlists.length; k++) {
                        const att = dtd.tag_dict[tag_name].attlists[k];
                        if (tag.hasOwnProperty(att.name)) {
                            // ok, that's what it should be
                        } else {
                            // also ok, that's what it actually is sometimes
                            tag[att.name] = att.default_value;                            
                            console.log('* fixed missing '+tag.id+' attr['+att.name+']');
                        }
                    }

                    // check the text attr for entity tags
                    if (dtd.tag_dict[tag_name].type == 'etag') {
                        if (tag.hasOwnProperty('text')) {

                        } else {
                            if (tag.spans == '-1~-1') {
                                tag.text = '';
                            } else {
                                tag.text = this.get_text_by_spans(tag.spans, ann.text);
                            }
                        }
                    }
                } else {
                    console.log('* undefined [' + tag_name + '] in dtd');
                }
                // console.log('* add tag', tag);

                // then, put this new tag to the ann tags list
                ann.tags.push(tag);
            }
        }

        return ann;
    },

    ann2xml: function(ann, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, ann.dtd_name
        );
        var root = xmlDoc.getElementsByTagName(ann.dtd_name)[0];
        // var root = xmlDoc.getRootNode();

        // create the CDATA section for TEXT
        var node_TEXT = xmlDoc.createElement('TEXT');
        node_TEXT.appendChild(
            xmlDoc.createCDATASection(ann.text)
        );
        root.appendChild(node_TEXT);

        // create the tags
        var node_TAGS = xmlDoc.createElement('TAGS');
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];

            // create a node for this tag
            var node_tag = xmlDoc.createElement(tag.tag);

            // create all attributes
            for (const attr in tag) {
                if (attr == 'tag') {
                    // skip the tag name itself
                    continue;
                }

                if (tag[attr] == null) {
                    // skip those null values in xml
                    continue;
                }

                if (attr == 'id') {
                    // quick save this attr
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;
                }

                if (dtd.tag_dict[tag.tag].type == 'etag') {
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;

                } else if (dtd.tag_dict[tag.tag].type == 'ltag') {
                    // for link tag, spans and text are not required
                    if (attr == 'spans') { continue; }
                    if (attr == 'text') { continue; }

                    // due to schema version issue, 
                    // the attribute may not exist in current schema
                    if (!dtd.tag_dict[tag.tag].attlist_dict.hasOwnProperty(attr)) {
                        continue;
                    }
                
                    // for those link tag, need to check 
                    if (dtd.tag_dict[tag.tag].attlist_dict[attr].vtype == 'idref') {
                        // so, this attr is a id ref,
                        // the value is a tag_id of an etag
                        // to be compatible with MAE format,
                        // we need to set 2 attributes if the value is not null
                        if (tag[attr] == null || tag[attr] == '') {
                            // if the value is empty, just skip this
                            continue;
                        }
                        // first, the xxxID
                        // second, the xxxText
                        // so, let's get the text first
                        var etag = this.get_tag_by_tag_id(tag[attr], ann);
                        if (etag == null) {
                            // ??? how could it be?
                            // well...skip this one
                            console.log('* not found etag [', attr, '] in ', tag);
                            continue;
                        }

                        // great! the etag is not null
                        node_tag.setAttribute(attr + 'ID', tag[attr]);
                        node_tag.setAttribute(attr + 'Text', etag.text);

                    } else {
                        // bind this node_attr to the node_tag
                        node_tag.setAttribute(attr, tag[attr]);
                    }
                }
            }

            // append this node to TAGS
            node_TAGS.appendChild(node_tag);
        }
        root.appendChild(node_TAGS);
        
        return xmlDoc;
    },

    xml2str_v1: function(xmlDoc, pretty) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n' + xmlStr;
        }

        if (typeof(pretty)=='undefined') {
            pretty = true;
        }

        if (pretty) {
            // var pretty_xmlStr = vkbeautify.xml(xmlStr, 0);
            // return pretty_xmlStr;
            var format = require('xml-formatter');
            formattedXml = format(xmlStr, {
                indentation: ''
            });
        }

        return xmlStr;
    },

    xml2str: function(xml_doc) {
        const serializer = new XMLSerializer();
        var xml_str_TEXT = serializer.serializeToString(xml_doc.getElementsByTagName('TEXT')[0]);
        var xml_str_TAGS = serializer.serializeToString(xml_doc.getElementsByTagName('TAGS')[0]);

        var format = require('xml-formatter');
        var xml_str_TAGS_formatted = format(xml_str_TAGS, {
            indentation: ''
        });

        var root_name = xml_doc.children[0].nodeName;

        var xml_str = [
            '<?xml version="1.0" encoding="UTF-8" ?>',
            '<' + root_name + '>',
            xml_str_TEXT,
            xml_str_TAGS_formatted,
            '</' + root_name + '>'
        ].join('\n');

        return xml_str;
    },

    pretty_xml_str: function(xml_str) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function(index, node) {
            var indent = 0;
            if (node.match( /.+<\/\w[^>]*>$/ )) {
                indent = 0;
            } else if (node.match( /^<\/\w/ )) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    },

    /**
     * Convert a list of anns to hints as tag name dict
     * @param {object} dtd annotation dtd object
     * @param {list} anns a list of annotation objects
     */
     anns2hint_dict: function(dtd, anns) {
        var hint_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                this.add_tag_to_hint_dict(ann, tag, hint_dict);
            }
        }

        return hint_dict;
    },

    add_tag_to_hint_dict: function(ann, tag, hint_dict) {
        if (!hint_dict.hasOwnProperty(tag.tag)) {
            hint_dict[tag.tag] = {
                // text only
                text_dict: {}, 

                // non-consuming dict
                nc_dict: {
                    count: 0,
                    ann_fn_dict: {},
                    _is_shown: false,
                }, 

                texts: []
            }
        }
        // empty text should be removed
        if (!tag.hasOwnProperty('text')) {
            // which means it's a link tag
            // we can do nothing to a link tag now
            return;
        }

        // now get the text and trim it
        var text = tag.text;
        text = text.trim();
        if (text == '') {
            // need to check if is a NC etag
            if (tag.spans == this.NON_CONSUMING_SPANS) {
                // add this nc etag
                if (hint_dict[tag.tag].nc_dict.ann_fn_dict.hasOwnProperty(ann._filename)) {
                    // oh, this is NOT a new file
                    // just increase the count for this concept and file
                    hint_dict[tag.tag].nc_dict.count += 1;
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] += 1
        
                } else {
                    // ok, this is a new file
                    // count +1
                    hint_dict[tag.tag].nc_dict.count += 1;
        
                    // save this ann file name
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] = 1;
                }

                // ok, we have add this file information to the hint dict
                return hint_dict;

            } else {
                // ok, it's just a wrong hint I guess
                return hint_dict;
            }
        }

        // add this text
        if (hint_dict[tag.tag].text_dict.hasOwnProperty(text)) {
            // oh, this is NOT a new text
            // just increase the count
            hint_dict[tag.tag].text_dict[text].count += 1;
            if (hint_dict[tag.tag].text_dict[text].ann_fn_dict.hasOwnProperty(ann._filename)) {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] += 1;
            } else {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
            }

        } else {
            // ok, this is a new text
            // count +1
            hint_dict[tag.tag].text_dict[text] = {
                count: 1,
                ann_fn_dict: {},
                _is_shown: false
            };

            // save this tag
            hint_dict[tag.tag].texts.push(text);

            // save this ann file name
            hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
        }

        return hint_dict;
    },

    /**
     * Search feasible hints to ranges for highlighting in codemirror
     * Those conflict / overlaped hints would be skiped
     * 
     * @param {object} hints The hints object contains all hint texts
     * @param {object} ann The annotation object which contains text and tags
     */
    search_hints_in_ann: function(hint_dict, ann) {
        var is_overlapped = function(a, b) {
            if (a[0] >= b[0] && a[0] < b[1]) {
                return true;
            }
            if (a[1] > b[0] && a[1] <= b[1]) {
                return true;
            }
            // the missing for contains
            if (a[0] <= b[0] && a[1] >= b[1]) {
                return true;
            }
            return false;
        }

        var is_overlapped_in_list = function(loc_x, loc_list) {
            for (let i = 0; i < loc_list.length; i++) {
                const loc = loc_list[i];
                if (is_overlapped(loc_x, loc)) {
                    return true;
                }
            }
            return false;
        }

        // for saving the locations of all marks 
        var loc_list = [];

        // for saving those hints need to be marked
        var hint_list = [];

        // for saving existing hint strs and mapping to tags
        var str_dict = {};

        // first, put existed ann tags in to mark dict
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (!tag.hasOwnProperty('spans')) {
                // which means it's a link tag
                continue;
            }
            // var spans = tag.spans.split(',');
            // for (let j = 0; j < spans.length; j++) {
            //     const span = spans[j];
            //     var loc = this.span2loc(span);
            //     loc_list.push(loc);
            // }
            var _locs = this.spans2locs(tag.spans);
            loc_list = loc_list.concat(_locs);
        }
        console.log('* created loc_list', loc_list);
        
        // check each tag in the hint
        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                // check each str in this hint tag
                for (let i = 0; i < hint_dict[tag_name].texts.length; i++) {
                    const str = hint_dict[tag_name].texts[i];
                    // if this str exists, just skip
                    if (str_dict.hasOwnProperty(str)) { 
                        if (str_dict[str].tags.hasOwnProperty(tag_name)) {

                        } else {
                            str_dict[str].tags[tag_name] = 1;
                        }
                        continue; 
                    }

                    // put this str to global dict first
                    str_dict[str] = {
                        tags: {}
                    };
                    str_dict[str].tags[tag_name] = 1;

                    // then find the locs of this str in
                    var locs = this.get_locs(str, ann.text);

                    for (let j = 0; j < locs.length; j++) {
                        const loc = locs[j];
                        
                        // we need to check whether this loc exsits
                        if (is_overlapped_in_list(loc, loc_list)) {
                            // ok, skip this
                        } else {
                            // append this loc to the list
                            loc_list.push(loc);

                            // and add this loc as a new mark
                            hint_list.push({
                                id: 'hint-' + tag_name + '-' + i + '-' + j,
                                tag: tag_name,
                                text: str,
                                spans: this.loc2span(loc)
                            })
                        }
                    }
                }
            }
        }

        return hint_list;
    },

    get_locs: function(str, text) {
        // convert str to lower for ignore case?
        try {
            var regex = new RegExp('\\b' + str + '\\b', 'gmi');
        

            var m;
            var locs = [];
            while ((m = regex.exec(text)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
                
                // The result can be accessed through the `m`-variable.
                m.forEach((match, groupIndex) => {
                    locs.push([ m.index, regex.lastIndex]);
                });
            }

            return locs;
        } catch (error) {
            console.log("* couldn't create regex by", str);
            return [];
        }
    },

    get_text_by_spans: function(spans, full_text) {
        var locs = this.spans2locs(spans);
        var text = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            const _t = full_text.substring(
                loc[0],
                loc[1]
            );
            text.push(_t);
        }

        return text.join('...');
    },

    spans2locs: function(raw_spans) {
        // fix for the special convert
        raw_spans = raw_spans.replaceAll(';', ',');

        // split by comma
        var span_arr = raw_spans.split(',');
        var locs = [];
        for (let i = 0; i < span_arr.length; i++) {
            const span = span_arr[i];
            var loc = this.span2loc(span);

            if (loc == null) {

            } else {
                locs.push(loc);
            }
        }

        return locs;
    },

    span2loc: function(span) {
        var ps = span.split('~');
        var span_pos_0 = parseInt(ps[0]);
        var span_pos_1 = parseInt(ps[1]);

        if (isNaN(span_pos_0)) {
            return null;
        }
        if (isNaN(span_pos_1)) {
            return null;
        }
        return [
            span_pos_0,
            span_pos_1
        ];
    },

    loc2span: function(loc) {
        return loc[0] + '~' + loc[1];
    },

    locs2spans: function(locs) {
        var spans = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            var span = this.loc2span(loc);
            spans.push(span);
        }
        spans = spans.join(',');
        return spans;
    },

    hash: function(str, seed) {
        if (typeof(seed) == 'undefined') {
            seed = 0;
        }
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    get_next_tag_id: function(ann, tag_def) {
        var n = 0;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].tag == tag_def.name) {
                // get the id number of this tag
                var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
                if (_id >= n) {
                    n = _id + 1;
                }
            }
        }
        return tag_def.id_prefix + n;
    },

    get_tag_by_tag_id: function(tag_id, ann) {
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                return ann.tags[i];
            }                
        }
        return null;
    },

    get_linked_ltags: function(tag_id, ann) {
        var tags = [];
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            
            // check if this is itself
            if (tag.id == tag_id) {
                // skip this tag_id itself
                continue;
            }

            for (const attr in tag) {
                if (Object.hasOwnProperty.call(tag, attr)) {
                    if (attr == 'id'   || 
                        attr == 'tag'  ||
                        attr == 'text' ||
                        attr == 'spans'
                    ) {
                        // skip those special attrs
                        continue;
                    }
                    const val = tag[attr];
                    if (val == tag_id) {
                        // ok, this a link ... I guess 
                        tags.push(tag);

                        // then, we don't need to check other attr
                        // just go to next tag
                        break;
                    }
                }
            }
        }
        return tags;
    }
};

// The BioC parser
/**
 * BioC Format Annotation file parser
 */
var bioc_parser = {

    NON_CONSUMING_SPANS: '-1~-1',

    anns2xml: function(anns, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, 'collection'
        );
        var root = xmlDoc.getElementsByTagName('collection')[0];

        // create an empty source tag
        var elem_source = xmlDoc.createElement('source');
        root.appendChild(elem_source);

        // create a date tag
        var elem_date = xmlDoc.createElement('date');
        elem_date.innerHTML = "" + new Date();
        root.appendChild(elem_date);

        // create an empty key tag
        var elem_key = xmlDoc.createElement('key');
        root.appendChild(elem_key);

        // create document for each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // create a document tag for this ann
            var elem_doc = xmlDoc.createElement('document');

            // add filename as id to this document
            var elem_id = xmlDoc.createElement('id');
            elem_id.innerHTML = ann._filename;
            elem_doc.appendChild(elem_id);

            // there is only one passage for this doc
            var elem_passage = xmlDoc.createElement('passage');

            // add the offset 0 to this passage
            var elem_poffset = xmlDoc.createElement('offset');
            elem_poffset.innerHTML = '0';
            elem_passage.appendChild(elem_poffset);

            // add the text to this passage
            var elem_ptext = xmlDoc.createElement('text');
            elem_ptext.appendChild(
                xmlDoc.createTextNode(ann.text)
            );
            elem_passage.appendChild(elem_ptext);

            // add all entity tags to this passage
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                
                // get the tag def from dtd
                var tag_def = dtd.tag_dict[tag.tag];

                if (tag_def.type == 'etag') {
                    // ok, it is a entity tag
                    // due to the fact of non-continous annoation,
                    // we need to check the spans first
                    var locs = ann_parser.spans2locs(tag.spans);

                    // for most of time, there is only one loc
                    // but sometimes, there are more
                    for (let k = 0; k < locs.length; k++) {
                        const loc = locs[k];

                        // get the attribute for the location element
                        var att_len = loc[1] - loc[0];
                        var att_ofs = loc[0];

                        // each entity tag is an annotation element 
                        var elem_ann = xmlDoc.createElement('annotation');
                        // set the ann elem id 
                        if (locs.length == 1) {
                            // if this is only one loc, just use the id
                            elem_ann.setAttribute('id', tag.id);
                        } else {
                            // otherwise, add suffix
                            elem_ann.setAttribute('id', tag.id + '_' + k);
                        }

                        // create location elements for this ann
                        var elem_location = xmlDoc.createElement('location');
                        elem_location.setAttribute('length', att_len);
                        elem_location.setAttribute('offset', att_ofs);
                        elem_ann.appendChild(elem_location);

                        // set the text content for this annotation
                        var elem_atext = xmlDoc.createElement('text');
                        var atext = ann.text.substring(loc[0], loc[1]);
                        elem_atext.appendChild(
                            xmlDoc.createTextNode(atext)
                        );
                        elem_ann.appendChild(elem_atext);

                        // ok, let's put other elements in this annotation
                        for (const key in tag) {
                            if (Object.hasOwnProperty.call(tag, key)) {
                                const val = tag[key];
                                if (['id','spans','text','tag'].contains(key)) {
                                    // these keys can be skipped
                                    continue;
                                }
                                
                                // for other key, need to create a infon element
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                elem_infon.innerHTML = val;

                                // ok, add this infon to this annotation
                                elem_ann.appendChild(elem_infon);
                            }
                        }
                        // finally, add this ann to the passage
                        elem_passage.appendChild(elem_ann);
                    }

                } else if (tag_def.type == 'ltag') {
                    // ok, it is a link tag

                    // each link tag is an relation element 
                    var elem_rel = xmlDoc.createElement('relation');
                    // set the id
                    elem_rel.setAttribute('id', tag.id);

                    // let's check each value
                    // ok, let's put other elements in this relation
                    for (const key in tag) {
                        if (Object.hasOwnProperty.call(tag, key)) {
                            const val = tag[key];
                            if (['id','spans','text','tag'].contains(key)) {
                                // these keys can be skipped
                                continue;
                            }
                            
                            // for other key, need to check attr type first
                            var att_def = tag_def.attlist_dict[key];

                            if (att_def.vtype == 'idref') {
                                // for idref type, need to create node
                                var elem_node = xmlDoc.createElement('node');
                                // set the refid
                                elem_node.setAttribute('refid', val);
                                // set the role as the attr name
                                elem_node.setAttribute('role', att_def.name);

                                // add this node
                                elem_rel.appendChild(elem_node);

                            } else {
                                // for other types, just create a infon
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                elem_infon.innerHTML = val;

                                // ok, add this infon to this annotation
                                elem_rel.appendChild(elem_infon);
                            }
                        }
                    }

                    // ok, save this relation
                    // finally, add this relation to the passage
                    elem_passage.appendChild(elem_rel);

                } else {
                    // what???

                }
            }

            // add this passage to the doc
            elem_doc.appendChild(elem_passage);

            // add this doc to the collection
            root.appendChild(elem_doc);
        }

        return xmlDoc;
    },

    xml2str: function(xmlDoc) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE collection SYSTEM "BioC.dtd">\n' + xmlStr;
        }
        return xmlStr;
    },

    /**
     * Download the BioC format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     * @param {string} fn the download file name
     */
     download_dataset_bioc: function(anns, dtd, fn) {
        // get the xml doc
        var xmlDoc = this.anns2xml(anns, dtd);

        // get the string for xml
        var xmlStr = this.xml2str(xmlDoc);

        // download
        var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
        saveAs(blob, fn);

        return xmlStr;
     }
};

// The Rulepack toolkit
/**
 * Easy Rule Pack Toolkit
 */
var erp_toolkit = {
    rp: {
        prefix: {
            rsregexp: 'resources_regexp_re'
        }
    },

    ///////////////////////////////////////////////////////
    // Rule Pack Functions
    ///////////////////////////////////////////////////////
    create_new_rulepack: function () {
        return {
            name: '',
            matchrules: [ ],
            rsregexps: [ ],
            contexts: [ ],
            fns: {
                used_resources: 'used_resources.txt',
                resources_rules_matchrules: 'resources_rules_matchrules.txt'
            }
        };
    },

    create_new_matchrule: function () {
        return {
            rule_name: 'cm_fever',
            regexp: '\\b(?i)(?:%reFEVER)\\b',
            location: 'NA',
            enabled: true,
            ignore_case: true,
            norm: 'FEVER'
        };
    },

    create_new_rsregexp: function () {
        return {
            name: 'FEVER',
            text: 'fever\nfebris\nfebrile'
        };
    },

    create_new_context: function() {
        var num = 0;
        if (this.vpp != null) {
            if (this.vpp.rulepack != null) {
                if (typeof(this.vpp.rulepack) != 'undefined') {
                    if (typeof(this.vpp.rulepack.contexts) != 'undefined') {
                        num = this.vpp.rulepack.contexts.length;
                    }
                }
            }
        }
        return {
            name: 'contextRule' + num,
            text: erp_toolkit.MEDTAGGER_CONTEXT_RULE
            // text: 'regex:(^|\s)\?(?=\s?\w+)~|~pre~|~poss~|~1\ndoes not demonstrate~|~pre~|~neg~|~1\ndid not demonstrate~|~pre~|~neg~|~1\ndo not demonstrate~|~pre~|~neg~|~1'
        };
    },

    rulepack2zip: function(rulepack) {
        var zip = new JSZip();

        // create the file list of regexp
        var txt_fns = '';
        for (var i = 0; i < rulepack.rsregexps.length; i++) {
            var rsregexp = rulepack.rsregexps[i];
            var ffn = 'regexp/' + this.rp.prefix.rsregexp + rsregexp.name + '.txt';
            var txt = rsregexp.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }
        
        // create the context rules
        for (var i = 0; i < rulepack.contexts.length; i++) {
            var context = rulepack.contexts[i];
            var ffn = 'context/' + context.name + '.txt';
            var txt = context.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }

        // create the rule file
        var rules = '// ' + rulepack.name + '\n';
        for (let i = 0; i < rulepack.matchrules.length; i++) {
            const matchrule = rulepack.matchrules[i];
            rules += 'RULENAME="' + matchrule.rule_name + '",';
            rules += 'REGEXP="' + matchrule.regexp + '",';
            rules += 'LOCATION="' + matchrule.location + '",';
            rules += 'NORM="' + matchrule.norm + '"\n';
        }
        var rule_fn = 'rules/' + rulepack.fns.resources_rules_matchrules;
        txt_fns += './' + rule_fn + '\n';

        zip.file(rule_fn, rules);
        console.log('* add ' + rule_fn);

        // create the used_resources.txt
        txt_fns += './' + rulepack.fns.used_resources + '\n';
        zip.file(rulepack.fns.used_resources, txt_fns);

        return zip;
    },
    
    ///////////////////////////////////////////////////////
    // Easy Pack Functions
    ///////////////////////////////////////////////////////
    create_new_easypack: function(rule_pack_name) {
        if (typeof(rule_pack_name)=='undefined') {
            rule_pack_name = 'rule_pack_name';
        }
        return {
            name: rule_pack_name,
            contexts: [ this.create_new_context() ],
            ergroups: [ ]
        }
    },

    create_new_ergroup: function(norm, text) {
        // set the default norm
        if (typeof(norm) == 'undefined') {
            norm = 'NAME_' + this.mkid(6);
        } else {
            norm = norm.toLocaleUpperCase();
        }

        // set the default text
        if (typeof(text) == 'undefined') {
            text = '';
        }

        return {
            _is_shown: false,
            norm: norm,
            rule_type: 'cm',
            location: 'NA',
            text: text
        };
    },

    anns2text_dict: function(anns) {
        var text_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                // create the tag_def if not exists
                if (!text_dict.hasOwnProperty(tag.tag)) {
                    // the text_dict is for searching
                    // the texts is for storing
                    text_dict[tag.tag] = {
                        textd: {},
                        texts: []
                    };
                }

                // empty text should be removed

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }

                var text = tag.text;
                text = text.trim();
                if (text == '') {
                    continue;
                }

                if (text_dict[tag.tag].textd.hasOwnProperty(text)) {
                    // oh, this is NOT a new text
                    // just increase the count
                    text_dict[tag.tag].textd[text] += 1;

                } else {
                    // ok, this is a new text
                    // count +1
                    text_dict[tag.tag].textd[text] = 1;

                    // save this tag
                    text_dict[tag.tag].texts.push(text);
                }
            }
        }

        return text_dict;
    },

    anns2easypack: function(anns, dtd) {
        // first, create an empty easypack
        var easypack = this.create_new_easypack(dtd.name);

        // then create ergroup_dict
        var ergroup_dict = {};

        // using the dtd to init the ergroup_dict
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag = dtd.etags[i];
            
            // create a new ergroup from this tag
            var ergroup = this.create_new_ergroup(tag.name, '');

            // put this ergroup to the dict for furture use
            ergroup_dict[tag.name] = ergroup;
        }

        // then, using the anns to fill the text of each ergroup
        var text_dict = this.anns2text_dict(anns);

        // using this text_dict to fill the ergroup_dict
        for (const tag_name in text_dict) {
            if (Object.hasOwnProperty.call(text_dict, tag_name)) {
                // check each text in each tag_name
                for (let k = 0; k < text_dict[tag_name].texts.length; k++) {
                    const text = text_dict[tag_name].texts[k];

                    // just append this text as a new line
                    ergroup_dict[tag_name].text += text + '\n';
                }
            }
        }

        // last, put the ergroup_dict to easypack.ergroups
        for (const tag_name in ergroup_dict) {
            if (Object.hasOwnProperty.call(ergroup_dict, tag_name)) {
                easypack.ergroups.push(ergroup_dict[tag_name]);
            }
        }

        return easypack;
    },

    easypack2rulepack: function(easypack) {
        // create an empty rule pack for converting
        var rulepack = this.create_new_rulepack();
    
        // now update the simple parts according to the easypack
        rulepack.name = easypack.name;
        rulepack.contexts = easypack.contexts;

        // now update the complex parts according to the easypack
        for (let i = 0; i < easypack.ergroups.length; i++) {
            const ergroup = easypack.ergroups[i];
            var regexp_name = this.norm2regexp_name(ergroup.norm);
            var cm_name = regexp_name.toLowerCase();
            
            // create a matchrule
            var matchrule = this.create_new_matchrule();

            // update the matchrule
            // norm is just the norm
            matchrule.norm = ergroup.norm;
            // location is just the location
            matchrule.location = ergroup.location;
            // rule_name is the comb of rule_type and cm_name
            matchrule.rule_name = ergroup.rule_type + '_' + cm_name;
            // regexp is the comb of regexp_name according to the rule_type
            if (ergroup.rule_type == 'cm') {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';

            } else if (ergroup.rule_type == 'rem') {
                matchrule.regexp = '\\b(?i)%re'+regexp_name+'\\b';

            } else {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';
            }

            // create a rsregexp(?i)
            var rsregexp = this.create_new_rsregexp();

            // update the rsregexp
            rsregexp.name = regexp_name;
            rsregexp.text = ergroup.text;

            // save the new matchrule and rsregexp
            rulepack.matchrules.push(matchrule);
            rulepack.rsregexps.push(rsregexp);
        }

        return rulepack;
    },
    
    ///////////////////////////////////////////////////////
    // Other Functions
    ///////////////////////////////////////////////////////
    mkid: function(length) {
        var result           = '';
        var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var charactersLength = characters.length;
        for ( var i = 0; i < length; i++ ) {
            result += characters.charAt(
                Math.floor(Math.random() * charactersLength)
            );
        }
       return result;
    },

    /**
     * Convert the norm to a valid regexp name
     * 
     * @param {string} norm 
     */
    norm2regexp_name: function(norm) {
        return norm.replace(/_/g, "");
    },

    download_zip: function(zip, fn) {
        zip.generateAsync({ type: "blob" }).then((function(fn){
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));
    },

    download_anns_as_zip: function(anns, dtd, fn) {
        // first, convert anns to easypack
        var easypack = this.anns2easypack(anns, dtd);

        // second, convert easypack to rulepack
        var rulepack = this.easypack2rulepack(easypack);

        // then convert this easypack to zip
        var zip = this.rulepack2zip(rulepack)

        // last, save this zip
        this.download_zip(zip, fn);

        return rulepack;
    },

    MEDTAGGER_CONTEXT_RULE: `// Format regex:?match_string~|~trigger_type~|~context_type~|~rule_priority(~|~window_size_override)?
// JW added start
regex:\?( ?\w+)?~|~pre~|~poss~|~1
does not demonstrate~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
do not demonstrate~|~pre~|~neg~|~1
regex:\bdo not see (\S+\s+){1,3}that suggests?\b~|~pre~|~neg~|~2
complications include~|~pre~|~hypo~|~1
complications include,~|~pre~|~hypo~|~1
given some brief thought to~|~pre~|~poss~|~1
never been high enough to cause~|~pre~|~poss~|~1
regex:\bno (\S+\s+){1,3} (to|that) suggests?\b~|~pre~|~neg~|~2
// AW added start
which demonstrates~|~termin~|~poss~|~1
interested in~|~pre~|~poss~|~1
etiology indeterminate~|~pseudo~|~poss~|~1
patient and family~|~pseudo~|~exp~|~1
patient and his husband~|~pseudo~|~exp~|~1
patient and her husband~|~pseudo~|~exp~|~1
patient and his wife~|~pseudo~|~exp~|~1
patient and her wife~|~pseudo~|~exp~|~1
patient and his family~|~pseudo~|~exp~|~1
patient and her family~|~pseudo~|~exp~|~1
patient and husband~|~pseudo~|~exp~|~1
patient and wife~|~pseudo~|~exp~|~1
family in the room~|~pseudo~|~exp~|~1
regex:(query|alternative)(?=\s(\S+\s+){1,3}(versus|vs))~|~pre~|~poss~|~1
does not suggest~|~pre~|~neg~|~2
do not suggest~|~pre~|~neg~|~2
did not suggest~|~pre~|~neg~|~2
not suggest~|~pseudo~|~poss~|~1
investigated for~|~pre~|~poss~|~1
investigating for~|~pre~|~poss~|~1
investigate for~|~pre~|~poss~|~1
regex:\bnot? (\S+\s+){1,5}due\b~|~pseudo~|~neg~|~1
no overt~|~pre~|~poss~|~2
likely due to~|~post~|~poss~|~1
resolution of~|~pre~|~neg~|~1
no progression of the~|~pseudo~|~neg~|~1
because~|~termin~|~neg~|~1
consideration given history~|~post~|~hypo~|~1
considered given history~|~post~|~hypo~|~1
consideration given history~|~pre~|~hist~|~1
considered given history~|~pre~|~hist~|~1
patient had~|~termin~|~neg~|~1
patient had~|~pre~|~hist~|~1
was diagnosed~|~termin~|~neg~|~1
was diagnosed~|~pre~|~hist~|~1
regex:;\b~|~termin~|~neg~|~1
from~|~termin~|~poss~|~1
from~|~termin~|~neg~|~1
maybe~|~pre~|~poss~|~1
no date~|~pseudo~|~neg~|~1
no date:~|~pseudo~|~neg~|~1
not limited~|~pseudo~|~neg~|~1
regex:\bfamily history\s*$~|~post~|~exp~|~2
regex:\bfamily history\s*$~|~post~|~hist~|~2
didn't have~|~pre~|~neg~|~1
don't have~|~pre~|~neg~|~1
never used~|~pre~|~neg~|~1
no question~|~pseudo~|~neg~|~1
her2 negative~|~pseudo~|~neg~|~1
who also had~|~pseudo~|~hypoexp~|~1
symptomatology~|~post~|~poss~|~1
pmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~exp~|~1
family history~|~pre~|~exp~|~1
family history~|~pre~|~hist~|~1
family member~|~pre~|~exp~|~1
likely to pursue~|~pseudo~|~poss~|~1
likely success~|~pseudo~|~poss~|~1
likely failure~|~pseudo~|~poss~|~1
cousin~|~pre~|~exp~|~1
cousins~|~pre~|~exp~|~1
regex:\basymptomatic\s*$~|~post~|~poss~|~2
// AW added end
//KER added start
trace~|~pre~|~poss~|~1
prn~|~pre~|~hypo~|~1
possible~|~pre~|~hypo~|~1
potential~|~pre~|~poss~|~1
mild~|~pre~|~poss~|~1
will be considered~|~post~|~hypo~|~1
would be considered~|~post~|~hypo~|~1
should be considered~|~post~|~hypo~|~1
considered~|~pre~|~hypo~|~1
consider~|~pre~|~hypo~|~1
consideration~|~pre~|~hypo~|~1
should consider~|~pre~|~hypo~|~1
should have~|~pre~|~hypo~|~1
should be offered~|~pre~|~hypo~|~1
scheduled~|~pre~|~hypo~|~1
planned~|~pre~|~hypo~|~1
plans for~|~pre~|~hypo~|~1
plan for~|~pre~|~hypo~|~1
plans are~|~pre~|~hypo~|~1
candidate for~|~pre~|~hypo~|~1
not a candidate for~|~pre~|~neg~|~1
not be a candidate for~|~pre~|~neg~|~1
put off~|~pre~|~hypo~|~1
    vs ~|~pre~|~hypo~|~1
discuss~|~pre~|~hypo~|~1
discussed~|~pre~|~hypo~|~1
discussion~|~pre~|~hypo~|~1
versus~|~pre~|~hypo~|~1
referred~|~pre~|~hypo~|~1
advised~|~pre~|~hypo~|~1
chance~|~pre~|~hypo~|~1
risky~|~post~|~poss~|~1
recommended~|~post~|~poss~|~1
if experiences worsening~|~pre~|~hypo~|~1
does not have~|~pre~|~neg~|~1
doesn't have~|~pre~|~neg~|~1
doesn't appear to have~|~pre~|~neg~|~1
does not appear to have~|~pre~|~neg~|~1
excluding~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
differential diagnosis~|~pre~|~poss~|~1
would not want to have~|~pre~|~neg~|~1
decline~|~pre~|~neg~|~1
declined~|~pre~|~neg~|~1
//KER added end
//Sunghwan added start
appear~|~pre~|~poss~|~1
appears~|~pre~|~poss~|~1
suspect~|~pre~|~poss~|~1
suspects~|~pre~|~poss~|~1
//appears? to have~|~pre~|~poss //not working why??
to evaluate~|~pre~|~poss~|~1
indeterminate~|~post~|~poss~|~1
indeterminable~|~pre~|~poss~|~1
to prevent~|~pre~|~hypo~|~1
has been instructed~|~pre~|~hypo~|~1
has been instructed in the sign~|~pre~|~hypo~|~1
has been instructed in the signs~|~pre~|~hypo~|~1
should the patient develop~|~pre~|~hypo~|~1
regex:\bno$~|~post~|~neg~|~1
//Sunghwan added end
//following two not working why??
none current~|~post~|~neg~|~1
no current~|~post~|~neg~|~1
hx~|~pre~|~hist~|~1
previous~|~pre~|~hist~|~1
previously~|~pre~|~hist~|~1
previously undergone~|~pre~|~hist~|~1
after undergoing~|~pre~|~hist~|~1
deny~|~pre~|~neg~|~1
no:~|~pre~|~neg~|~1
no :~|~pre~|~neg~|~1
(no~|~pre~|~neg~|~1
--no~|~pre~|~neg~|~1
don't sound like~|~pre~|~neg~|~1
doesn't sound like~|~pre~|~neg~|~1
regex:-? all of which(\s+\S+){0,3} (denies|denied)\b~|~post~|~neg~|~1
denies any of the following symptoms:~|~pre~|~neg~|~1
denies, however,~|~pre~|~neg~|~1
denies any associated~|~pre~|~neg~|~1
denies any significant~|~pre~|~neg~|~1
precaution for~|~pre~|~poss~|~1
resection of~|~pre~|~hist~|~1
debridement of~|~pre~|~hist~|~1
indication for~|~pre~|~hist~|~1
admitted for~|~pre~|~hist~|~1
likely~|~pre~|~poss~|~1
did deny~|~pre~|~neg~|~1
no source of~|~pre~|~poss~|~1
no source for~|~pre~|~poss~|~1
did not show much of~|~pre~|~poss~|~1
did not show much for~|~pre~|~poss~|~1
no definite finding for~|~pre~|~poss~|~1
no definite finding of~|~pre~|~poss~|~1
no definite findings for~|~pre~|~poss~|~1
no definite findings of~|~pre~|~poss~|~1
concern about~|~pre~|~poss~|~1
concerned about~|~pre~|~poss~|~1
would~|~pre~|~poss~|~1
could have~|~pre~|~poss~|~1
may have~|~pre~|~poss~|~1
raise the question of~|~pre~|~poss~|~1
raise the question for~|~pre~|~poss~|~1
raises the question of~|~pre~|~poss~|~1
raises the question for~|~pre~|~poss~|~1
highly unlikely~|~pre~|~poss~|~1
did not show any~|~pre~|~neg~|~1
do not show any~|~pre~|~neg~|~1
does not show any~|~pre~|~neg~|~1
suspicious for~|~pre~|~poss~|~1
suspicion for~|~pre~|~poss~|~1
suspicious of~|~pre~|~poss~|~1
suspicion of~|~pre~|~poss~|~1
a question of~|~pre~|~poss~|~1
a question for~|~pre~|~poss~|~1
without evidence of~|~pre~|~neg~|~1
without evidence for~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
without sign for~|~pre~|~neg~|~1
without signs of~|~pre~|~neg~|~1
without signs for~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
suggests~|~pre~|~poss~|~1
suggest~|~pre~|~poss~|~1
neg of~|~pre~|~neg~|~1
neg for~|~pre~|~neg~|~1
whether~|~pre~|~hypo~|~1
sound more like~|~pre~|~poss~|~1
sound like~|~pre~|~poss~|~1
sounds more like~|~pre~|~poss~|~1
sounds like~|~pre~|~poss~|~1
look more like~|~pre~|~poss~|~1
look like~|~pre~|~poss~|~1
looks more like~|~pre~|~poss~|~1
looks like~|~pre~|~poss~|~1
review the use~|~pre~|~poss~|~1
reviewed~|~pre~|~poss~|~1
likely~|~post~|~poss~|~1
will have~|~pre~|~hypo~|~1
may be~|~pre~|~poss~|~1
for excluding~|~pre~|~poss~|~1
potentially represent~|~pre~|~poss~|~1
possibility of~|~pre~|~poss~|~1
possibility for~|~pre~|~poss~|~1
should symptoms suggesting~|~pre~|~poss~|~1
look for~|~pre~|~hypo~|~1
no evidence of~|~pre~|~neg~|~1
no evidences of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
no evidences for~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no sign for~|~pre~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no signs for~|~pre~|~neg~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
risk of~|~pre~|~hypo~|~1
risk for~|~pre~|~hypo~|~1
risks of~|~pre~|~hypo~|~1
risks for~|~pre~|~hypo~|~1
cardiovascular risk~|~pseudo~|~hypo~|~1
cardiovascular risks~|~pseudo~|~hypo~|~1
risk~|~pre~|~hypo~|~1
risks~|~pre~|~hypo~|~1
s/p~|~pre~|~hist~|~1
at high-risk of~|~pre~|~hypo~|~1
at high-risk for~|~pre~|~hypo~|~1
at high risk of~|~pre~|~hypo~|~1
at high risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
re-assess~|~pre~|~hypo~|~1
reassess~|~pre~|~hypo~|~1
assess~|~pre~|~hypo~|~1
prior~|~pre~|~hist~|~1
pmh of~|~pre~|~hist~|~1
pmh for~|~pre~|~hist~|~1
concern~|~pre~|~poss~|~1
concerning~|~pre~|~poss~|~1
is concerned~|~post~|~poss~|~1
is concerned of~|~pre~|~poss~|~1
is concerned for~|~pre~|~poss~|~1
a concern of~|~pre~|~poss~|~1
a concern for~|~pre~|~poss~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is potentional~|~post~|~poss~|~1
no overt clinical sign of~|~pre~|~neg~|~1
no overt clinical sign for~|~pre~|~neg~|~1
no overt clinical signs of~|~pre~|~neg~|~1
no overt clinical signs for~|~pre~|~neg~|~1
monitor of~|~pre~|~hypo~|~1
monitor for~|~pre~|~hypo~|~1
no source of~|~pre~|~neg~|~1
no source for~|~pre~|~neg~|~1
was ruled out of~|~pre~|~neg~|~1
is ruled out of~|~pre~|~neg~|~1
was ruled out for~|~pre~|~neg~|~1
is ruled out for~|~pre~|~neg~|~1
no evidence of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
was negative of~|~pre~|~neg~|~1
was negative for~|~pre~|~neg~|~1
is negative of~|~pre~|~neg~|~1
is negative for~|~pre~|~neg~|~1
probable~|~pre~|~poss~|~1
possible~|~pre~|~poss~|~1
potential~|~pre~|~poss~|~1
probable for~|~pre~|~poss~|~1
probable of~|~pre~|~poss~|~1
possible of~|~pre~|~poss~|~1
possible for~|~pre~|~poss~|~1
potential of~|~pre~|~poss~|~1
potential for~|~pre~|~poss~|~1
negative~|~pre~|~neg~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is negative~|~post~|~neg~|~1
was possible~|~post~|~poss~|~1
was probable~|~post~|~poss~|~1
was negative~|~post~|~neg~|~1
regex::\s*no\s*(?:$|[,.!?])~|~post~|~neg~|~2
regex::\s*none\s*(?:$|[,.!?])~|~post~|~neg~|~2
asymptomatic~|~pre~|~poss~|~1
//Hongfang added end
absence of~|~pre~|~neg~|~1
absence for~|~pre~|~neg~|~1
adequate to rule her out~|~pre~|~neg~|~1
adequate to rule him out~|~pre~|~neg~|~1
adequate to rule out~|~pre~|~neg~|~1
adequate to rule the patient out~|~pre~|~neg~|~1
although~|~termin~|~neg~|~1
any other~|~pre~|~neg~|~1
apart from~|~termin~|~neg~|~1
are ruled out~|~post~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a etiology for~|~termin~|~neg~|~1
as a etiology of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as an etiology for~|~termin~|~neg~|~1
as an etiology of~|~termin~|~neg~|~1
as an origin for~|~termin~|~neg~|~1
as an origin of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as has~|~termin~|~neg~|~1
as needed~|~pre~|~hypo~|~1
as the cause for~|~termin~|~neg~|~1
as the cause of~|~termin~|~neg~|~1
as the etiology for~|~termin~|~neg~|~1
as the etiology of~|~termin~|~neg~|~1
as the origin for~|~termin~|~neg~|~1
as the origin of~|~termin~|~neg~|~1
as the reason for~|~termin~|~neg~|~1
as the reason of~|~termin~|~neg~|~1
as the secondary cause for~|~termin~|~neg~|~1
as the secondary cause of~|~termin~|~neg~|~1
as the secondary etiology for~|~termin~|~neg~|~1
as the secondary etiology of~|~termin~|~neg~|~1
as the secondary origin for~|~termin~|~neg~|~1
as the secondary origin of~|~termin~|~neg~|~1
as the secondary reason for~|~termin~|~neg~|~1
as the secondary reason of~|~termin~|~neg~|~1
as the secondary source for~|~termin~|~neg~|~1
as the secondary source of~|~termin~|~neg~|~1
as the source for~|~termin~|~neg~|~1
as the source of~|~termin~|~neg~|~1
as well as any~|~pre~|~neg~|~1
aside from~|~termin~|~neg~|~1
aunt~|~pre~|~exp~|~1
aunt:~|~pre~|~exp~|~1
aunts~|~pre~|~exp~|~1
aunt's~|~pre~|~exp~|~1
be ruled out~|~post~|~poss~|~1
be ruled out for~|~pre~|~poss~|~1
because~|~termin~|~hypo~|~1
being ruled out~|~post~|~poss~|~1
brother~|~pre~|~exp~|~1
brother:~|~pre~|~exp~|~1
brother's~|~pre~|~exp~|~1
brothers~|~pre~|~exp~|~1
but~|~termin~|~neg~|~1
can be ruled out~|~post~|~neg~|~1
can be ruled out for~|~pre~|~neg~|~1
can rule her out~|~pre~|~neg~|~1
can rule her out against~|~pre~|~neg~|~1
can rule her out for~|~pre~|~neg~|~1
can rule him out~|~pre~|~neg~|~1
can rule him out against~|~pre~|~neg~|~1
can rule him out for~|~pre~|~neg~|~1
can rule out~|~pre~|~neg~|~1
can rule out against~|~pre~|~neg~|~1
can rule out for~|~pre~|~neg~|~1
can rule the patient out~|~pre~|~neg~|~1
can rule the patinet out against~|~pre~|~neg~|~1
can rule the patinet out for~|~pre~|~neg~|~1
cannot~|~pre~|~neg~|~1
cannot exclude~|~pre~|~poss~|~2
cause for~|~termin~|~neg~|~1
cause of~|~termin~|~neg~|~1
causes for~|~termin~|~neg~|~1
causes of~|~termin~|~neg~|~1
checked for~|~pre~|~neg~|~1
clear of~|~pre~|~neg~|~1
come back for~|~pre~|~hypo~|~1
come back to~|~pre~|~hypo~|~1
complains~|~termin~|~histexp~|~1
could be ruled out~|~post~|~poss~|~1
//could be~|~both~|~poss~|~1
could be ruled out for~|~pre~|~poss~|~1
currently~|~termin~|~histexp~|~1
dad~|~pre~|~exp~|~1
dad:~|~pre~|~exp~|~1
dad's~|~pre~|~exp~|~1
declined~|~pre~|~neg~|~1
declines~|~pre~|~neg~|~1
denied~|~pre~|~neg~|~1
denies~|~pre~|~neg~|~1
denying~|~pre~|~neg~|~1
did not rule out~|~post~|~poss~|~1
did rule her out~|~pre~|~neg~|~1
did rule her out against~|~pre~|~neg~|~1
did rule her out for~|~pre~|~neg~|~1
did rule him out~|~pre~|~neg~|~1
did rule him out against~|~pre~|~neg~|~1
did rule him out for~|~pre~|~neg~|~1
did rule out~|~pre~|~neg~|~1
did rule out against~|~pre~|~neg~|~1
did rule out for~|~pre~|~neg~|~1
did rule the patient out~|~pre~|~neg~|~1
did rule the patient out against~|~pre~|~neg~|~1
did rule the patient out for~|~pre~|~neg~|~1
doesn't look like~|~pre~|~neg~|~1
ed~|~termin~|~hist~|~1
emergency department~|~termin~|~hist~|~1
etiology for~|~termin~|~neg~|~1
etiology of~|~termin~|~neg~|~1
evaluate for~|~pre~|~neg~|~1
evaluation for~|~pre~|~neg~|~1
except~|~termin~|~neg~|~1
fails to reveal~|~pre~|~neg~|~1
family~|~pre~|~exp~|~1
fam hx~|~pre~|~exp~|~1
fam hx:~|~pre~|~exp~|~1
father~|~pre~|~exp~|~1
father:~|~pre~|~exp~|~1
father's~|~pre~|~exp~|~1
free~|~post~|~neg~|~1
free of~|~pre~|~neg~|~1
gram negative~|~pseudo~|~neg~|~1
grandfather~|~pre~|~exp~|~1
grandfather's~|~pre~|~exp~|~1
grandfather:~|~pre~|~exp~|~1
grandmother~|~pre~|~exp~|~1
grandmother's~|~pre~|~exp~|~1
grandmother:~|~pre~|~exp~|~1
has been negative~|~post~|~neg~|~1
has been ruled out~|~post~|~neg~|~1
have been ruled out~|~post~|~neg~|~1
her~|~termin~|~hypoexp~|~1
his~|~termin~|~hypoexp~|~1
hx of~|~pre~|~hist~|~1
h/o~|~pre~|~hist~|~1
statuspost~|~pre~|~hist~|~1
status/post~|~pre~|~hist~|~1
status-post~|~pre~|~hist~|~1
status post~|~pre~|~hist~|~1
year ago~|~pre~|~hist~|~1
year ago~|~post~|~hist~|~1
years ago~|~pre~|~hist~|~1
years ago~|~post~|~hist~|~1
have had~|~pre~|~hist~|~1
has had~|~pre~|~hist~|~1
had~|~pre~|~hist~|~1
underwent~|~pre~|~hist~|~1
husband~|~pre~|~exp~|~1
ho~|~pre~|~hist~|~1
history~|~pre~|~hist~|~1
history of~|~pre~|~hist~|~1
history and~|~pseudo~|~hist~|~1
history and examination~|~pseudo~|~hist~|~1
history and physical~|~pseudo~|~hist~|~1
history for~|~pseudo~|~hist~|~1
history of chief complaint~|~pseudo~|~hist~|~1
history of present illness~|~pseudo~|~hist~|~1
history taking~|~pseudo~|~hist~|~1
history, physical~|~pseudo~|~hist~|~1
however~|~termin~|~neg~|~1
if~|~pre~|~hypo~|~1
if negative~|~pseudo~|~hypo~|~1
inconsistent with~|~pre~|~neg~|~1
is not~|~pre~|~neg~|~1
is ruled out~|~post~|~neg~|~1
is to be ruled out~|~post~|~poss~|~1
is to be ruled out for~|~pre~|~poss~|~1
isn't~|~pre~|~neg~|~1
lack of~|~pre~|~neg~|~1
lacked~|~pre~|~neg~|~1
may be ruled out~|~post~|~poss~|~1
may be ruled out for~|~pre~|~poss~|~1
discussed~|~pre~|~poss~|~1
might be ruled out~|~post~|~poss~|~1
might be ruled out for~|~pre~|~poss~|~1
mom~|~pre~|~exp~|~1
mom:~|~pre~|~exp~|~1
mom's~|~pre~|~exp~|~1
mother~|~pre~|~exp~|~1
mother:~|~pre~|~exp~|~1
mother's~|~pre~|~exp~|~1
must be ruled out~|~post~|~poss~|~1
must be ruled out for~|~pre~|~poss~|~1
negative for~|~pre~|~neg~|~1
never developed~|~pre~|~neg~|~1
never had~|~pre~|~neg~|~1
nevertheless~|~termin~|~neg~|~1
no~|~pre~|~neg~|~1
no abnormal~|~pre~|~neg~|~1
no cause of~|~pre~|~neg~|~1
no change~|~pseudo~|~neg~|~1
no complaints of~|~pre~|~neg~|~1
no definite change~|~pseudo~|~neg~|~1
no evidence~|~pre~|~neg~|~1
no evidence to suggest~|~pre~|~neg~|~1
no findings of~|~pre~|~neg~|~1
no findings to indicate~|~pre~|~neg~|~1
no history of~|~pre~|~neg~|~1
no increase~|~pseudo~|~neg~|~1
no interval change~|~pseudo~|~neg~|~1
no longer present~|~post~|~neg~|~1
no mammographic evidence of~|~pre~|~neg~|~1
no new~|~pre~|~neg~|~1
no new evidence~|~pre~|~neg~|~1
no other evidence~|~pre~|~neg~|~1
no radiographic evidence of~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no significant~|~pre~|~neg~|~1
no significant change~|~pseudo~|~neg~|~1
no significant interval change~|~pseudo~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no suggestion of~|~pre~|~neg~|~1
no suspicious~|~pre~|~neg~|~1
no suspicious change~|~pseudo~|~neg~|~1
non diagnostic~|~post~|~neg~|~1
not~|~pre~|~neg~|~1
not appear~|~pre~|~neg~|~1
not appreciate~|~pre~|~neg~|~1
not associated with~|~pre~|~neg~|~1
not been ruled out~|~post~|~poss~|~1
not cause~|~pseudo~|~neg~|~1
not certain if~|~pseudo~|~neg~|~1
not certain whether~|~pseudo~|~neg~|~1
not complain of~|~pre~|~neg~|~1
not demonstrate~|~pre~|~neg~|~1
not drain~|~pseudo~|~neg~|~1
not exhibit~|~pre~|~neg~|~1
not extend~|~pseudo~|~neg~|~1
not feel~|~pre~|~neg~|~1
not had~|~pre~|~neg~|~1
not have~|~pre~|~neg~|~1
not have evidence of~|~pre~|~neg~|~1
not know of~|~pre~|~neg~|~1
not known to have~|~pre~|~neg~|~1
not necessarily~|~pseudo~|~neg~|~1
not on~|~pseudo~|~neg~|~1
not only~|~pseudo~|~neg~|~1
not recommended~|~post~|~neg~|~1
not recommend~|~pre~|~neg~|~1
not recommending~|~pre~|~neg~|~1
not reveal~|~pre~|~neg~|~1
not ruled out~|~post~|~poss~|~1
not see~|~pre~|~neg~|~1
not to be~|~pre~|~neg~|~1
nothing to suggest~|~pre~|~neg~|~2
noted~|~termin~|~histexp~|~1
now resolved~|~post~|~neg~|~1
origin for~|~termin~|~neg~|~1
origin of~|~termin~|~neg~|~1
origins for~|~termin~|~neg~|~1
origins of~|~termin~|~neg~|~1
other possibilities of~|~termin~|~neg~|~1
ought to be ruled out~|~post~|~poss~|~1
ought to be ruled out for~|~pre~|~poss~|~1
past history~|~pre~|~hist~|~1
past~|~pre~|~hist~|~1
following up~|~pre~|~hist~|~1
following~|~pre~|~hist~|~1
received~|~pre~|~hist~|~1
past medical history~|~pre~|~hist~|~1
patient~|~termin~|~hypoexp~|~1
patient was not~|~pre~|~neg~|~1
patient's~|~termin~|~hypoexp~|~1
poor history~|~pseudo~|~hist~|~1
presenting~|~termin~|~histexp~|~1
presents~|~termin~|~histexp~|~1
prophylaxis~|~post~|~neg~|~1
r/o~|~pre~|~neg~|~1
rather than~|~pre~|~neg~|~1
reason for~|~termin~|~neg~|~1
reason of~|~termin~|~neg~|~1
reasons for~|~termin~|~neg~|~1
reasons of~|~termin~|~neg~|~1
reported~|~termin~|~histexp~|~1
reports~|~termin~|~histexp~|~1
resolved~|~pre~|~neg~|~1
resolved after~|~post~|~neg~|~1
return~|~pre~|~hypo~|~1
ro~|~pre~|~neg~|~1
rule her out~|~pre~|~neg~|~1
rule her out for~|~pre~|~neg~|~1
rule him out~|~pre~|~neg~|~1
rule him out for~|~pre~|~neg~|~1
rule out~|~pre~|~neg~|~1
rule out for~|~pre~|~neg~|~1
rule the patient out~|~pre~|~neg~|~1
rule the patinet out for~|~pre~|~neg~|~1
ruled her out~|~pre~|~neg~|~1
ruled her out against~|~pre~|~neg~|~1
ruled her out for~|~pre~|~neg~|~1
ruled him out~|~pre~|~neg~|~1
ruled him out against~|~pre~|~neg~|~1
ruled him out for~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
ruled out against~|~pre~|~neg~|~1
ruled out for~|~pre~|~neg~|~1
ruled the patient out~|~pre~|~neg~|~1
ruled the patient out against~|~pre~|~neg~|~1
ruled the patient out for~|~pre~|~neg~|~1
rules her out~|~pre~|~neg~|~1
rules her out for~|~pre~|~neg~|~1
rules him out~|~pre~|~neg~|~1
rules him out for~|~pre~|~neg~|~1
rules out~|~pre~|~neg~|~1
rules out for~|~pre~|~neg~|~1
rules the patient out~|~pre~|~neg~|~1
rules the patient out for~|~pre~|~neg~|~1
secondary~|~termin~|~neg~|~1
secondary to~|~termin~|~neg~|~1
should be ruled out~|~post~|~neg~|~1
should be ruled out for~|~pre~|~neg~|~1
should he~|~pre~|~hypo~|~1
should she~|~pre~|~hypo~|~1
should the patient~|~pre~|~hypo~|~1
should there~|~pre~|~hypo~|~1
since~|~termin~|~hypo~|~1
sister~|~pre~|~exp~|~1
sister's~|~pre~|~exp~|~1
social history~|~pseudo~|~hist~|~1
son~|~pre~|~exp~|~1
source for~|~termin~|~neg~|~1
source of~|~termin~|~neg~|~1
sources for~|~termin~|~neg~|~1
sources of~|~termin~|~neg~|~1
states~|~termin~|~histexp~|~1
still~|~termin~|~neg~|~1
sudden onset of~|~pseudo~|~hist~|~1
sufficient to rule her out~|~pre~|~neg~|~1
sufficient to rule her out against~|~pre~|~neg~|~1
sufficient to rule her out for~|~pre~|~neg~|~1
sufficient to rule him out~|~pre~|~neg~|~1
sufficient to rule him out against~|~pre~|~neg~|~1
sufficient to rule him out for~|~pre~|~neg~|~1
sufficient to rule out~|~pre~|~neg~|~1
sufficient to rule out against~|~pre~|~neg~|~1
sufficient to rule out for~|~pre~|~neg~|~1
sufficient to rule the patient out~|~pre~|~neg~|~1
sufficient to rule the patient out against~|~pre~|~neg~|~1
sufficient to rule the patient out for~|~pre~|~neg~|~1
test for~|~pre~|~neg~|~1
though~|~termin~|~neg~|~1
to exclude~|~pre~|~neg~|~1
today~|~termin~|~histexp~|~1
trigger event for~|~termin~|~neg~|~1
uncle~|~pre~|~exp~|~1
uncle:~|~pre~|~exp~|~1
uncle's~|~pre~|~exp~|~1
unlikely~|~post~|~neg~|~1
unremarkable for~|~pre~|~neg~|~1
was found~|~termin~|~histexp~|~1
was negative~|~post~|~neg~|~1
was not~|~pre~|~neg~|~1
was ruled out~|~post~|~neg~|~1
wasn't~|~pre~|~neg~|~1
what must be ruled out is~|~pre~|~poss~|~1
which~|~termin~|~exp~|~1
wife~|~pre~|~exp~|~1
who~|~termin~|~hypoexp~|~1
will be ruled out~|~post~|~poss~|~1
will be ruled out for~|~pre~|~poss~|~1
with no~|~pre~|~neg~|~1
without~|~pre~|~neg~|~1
without any evidence of~|~pre~|~neg~|~1
without difficulty~|~pseudo~|~neg~|~1
without evidence~|~pre~|~neg~|~1
without indication of~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
yet~|~termin~|~neg~|~1
    `
};

// The spaCy toolkit
var spacy_toolkit = {

    download_anns_as_jsonl: function(anns, dtd, fn) {
        // create patterns
        var patterns = this.anns2patterns(anns);

        // get the text
        var str = this.patterns2str(patterns);

        // download
        var blob = new Blob([str], {type: "text/txt;charset=utf-8"});
        saveAs(blob, fn);

        return str;
    },

    anns2patterns: function(anns) {
        // use a dictionary for sorting
        var patterns = {};
        
        // check each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // check each tag in this ann
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                var tag_name = tag.tag;

                if (patterns.hasOwnProperty(tag_name)) {
                    
                } else {
                    patterns[tag_name] = {
                        text_dict: {},
                        pattern_list: []
                    }
                }
                
                // create a pharse pattern

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }
                var text = tag.text;

                if (text == null) { 
                    // what?
                    continue;
                }

                // remove blank
                text = text.trim();

                if (text == '') {
                    // what??
                    continue;
                }
                
                // change to lower
                text = text.toLocaleLowerCase();

                if (patterns[tag_name].text_dict.hasOwnProperty(text)) {
                    // skip existed text
                    patterns[tag_name].text_dict[text] += 1;
                    continue;
                }

                // create a new pattern
                var p = {
                    label: tag_name.toLocaleUpperCase(),
                    pattern: text,
                    id: tag_name
                };

                // add this as a new pattern
                patterns[tag_name].pattern_list.push(p);
                patterns[tag_name].text_dict[text] = 1;
            }
        }

        // convert the patterns to a list
        var all_patterns = [];
        for (const tag_name in patterns) {
            if (Object.hasOwnProperty.call(patterns, tag_name)) {
                for (let i = 0; i < patterns[tag_name].pattern_list.length; i++) {
                    const p = patterns[tag_name].pattern_list[i];
                    all_patterns.push(p);
                }
            }
        }

        return all_patterns;
    },

    patterns2str: function(patterns) {
        var strs = [];
        for (let i = 0; i < patterns.length; i++) {
            const p = patterns[i];
            var p_str = JSON.stringify(p);
            strs.push(p_str);
        }

        return strs.join('\n');
    }
};

// The IAA Calculator
var iaa_calculator = {
    

    make_ann_by_rst: function(ann_rst, dtd) {
        var ann = JSON.parse(JSON.stringify(ann_rst.ann));

        // clear the ann tags
        ann.tags = [];

        // check each cate
        var cms = ['tp', 'fp', 'fn'];

        for (const tag_name in ann_rst.rst) {
            if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                const tag_rst = ann_rst.rst[tag_name];

                for (let i = 0; i < cms.length; i++) {
                    const cm = cms[i];
                    
                    for (let j = 0; j < tag_rst[cm].length; j++) {
                        var tag = Object.assign({}, tag_rst[cm][j].tag);
                        var tag_def = dtd.tag_dict[tag.tag];

                        // get a new id for this tag
                        var new_id = ann_parser.get_next_tag_id(ann, tag_def);

                        // now, set this tag and put it into list
                        tag.id = new_id;
                        ann.tags.push(tag);
                    }
                }
            }
        }

        return ann;
    },

    get_default_gs_dict: function(dtd, iaa_dict) {
        // the core of gs is similar to the iaa_dict.ann
        // which is a hashcode based dictionary.
        // and the inner data is similar.
        /*
        {
            hashcode: {
                ann: ann_obj // but the tags are empty,
                rst: {
                    tag_name: {
                        tp: [{tag: tag, from: 'a'}, ...],
                        fp: [],
                        fn: []
                    }
                }
            }
        }

        the length of tp, fp, fn is exactly equal to the iaa_dict
        */
        var gs_dict = {};

        var cnt = 0;
        for (const hashcode in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                // deep copy a new object
                const ann_rst = JSON.parse(JSON.stringify(iaa_dict.ann[hashcode]));
                cnt += 1;

                // rename the 
                gs_dict[hashcode] = {
                    // copy the ann_a as defult
                    ann: ann_rst.anns[0],
                    rst: {}
                }
                // rename the gs
                var fn_gs = "GS_" + this.find_lcs(
                    ann_rst.anns[0]._filename,
                    ann_rst.anns[1]._filename
                ) + '_' + cnt + '.xml';
                gs_dict[hashcode].ann._filename = fn_gs;

                // remove the _fh
                delete gs_dict[hashcode].ann._fh;

                // empty the existing tags
                gs_dict[hashcode].ann.tags = [];

                // add one more 
                gs_dict[hashcode].ann._has_star = false;

                for (const tag_name in ann_rst.rst.tag) {
                    if (Object.hasOwnProperty.call(ann_rst.rst.tag, tag_name)) {
                        const tag_rst = ann_rst.rst.tag[tag_name];
                        gs_dict[hashcode].rst[tag_name] = {
                            tp: [],
                            fp: [],
                            fn: []
                        }

                        // fill each in tp
                        for (let i = 0; i < tag_rst.cm.tags.tp.length; i++) {
                            const tags = tag_rst.cm.tags.tp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].tp.push({
                                tag: tags[0],
                                from: 'a'
                            });
                        }

                        // fill each in fp
                        for (let i = 0; i < tag_rst.cm.tags.fp.length; i++) {
                            const tags = tag_rst.cm.tags.fp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].fp.push({
                                tag: tags[0],
                                from: 'a'
                            });
                        }
                        
                        // fill each in fn
                        for (let i = 0; i < tag_rst.cm.tags.fn.length; i++) {
                            const tags = tag_rst.cm.tags.fn[i];
                            // use ann_b's result
                            gs_dict[hashcode].rst[tag_name].fn.push({
                                tag: tags[1],
                                from: 'b'
                            });
                        }
                    }
                }
            }
        }

        return gs_dict;
    },

    evaluate_anns_on_dtd: function(dtd, anns_a, anns_b, match_mode, overlap_ratio) {
        if (typeof(match_mode) == 'undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = 0.01;
        }
        /* we will build a dictionary for this task
        {
            ann: {
                text_hash: {
                    anns: [ann_a, ann_b],
                    rst: {
                        tag_name: result
                    }
                },
                ...
            },
            all: {pre, rec, f1, cm},
            tag: {
                tag_a: {pre, rec, f1, cm},
            }
        },
        */
        var iaa_dict = {
            ann: {}, // for the file
            all: {},
            tag: {},
            stat: {
                duplicates: [],
                unmatched: [],
                matched_hashcodes: []
            },
        };

        // this is just for checking dupliated ann
        var ann_dict = {};
        
        // first, let's check all anns_a
        for (let i = 0; i < anns_a.length; i++) {
            const ann_a = anns_a[i];
            var hashcode = this.hash(ann_a.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                // what??? duplicated text in anns_a?
                console.log('* found duplicated ann a', ann_a);
                iaa_dict.stat.duplicates.push({
                    ann: ann_a,
                    from: 'a'
                });
                continue;
            }

            // ok, let's create a new item here
            ann_dict[hashcode] = [{
                ann: ann_a,
                from: 'a'
            }];
        }

        // second, let's check all anns_b
        for (let i = 0; i < anns_b.length; i++) {
            const ann_b = anns_b[i];
            var hashcode = this.hash(ann_b.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                if (ann_dict[hashcode].length > 1) {
                    // this is a dupliated ann
                    iaa_dict.stat.duplicates.push({
                        ann: ann_b,
                        from: 'b'
                    });
                    console.log('* found duplicated ann b', ann_b);

                    continue;
                }
            } else {
                // which means this ann has no ann in a
                ann_dict[hashcode] = [{
                    ann: ann_b,
                    from: 'b'
                }];
                iaa_dict.stat.unmatched.push({
                    ann: ann_b,
                    from: 'b'
                });
                console.log('* found unmatched ann b', ann_b);
                continue;
            }
            
            // OK, this ann_b could be matched with ann_a
            var ann_a = ann_dict[hashcode][0].ann;
            iaa_dict.ann[hashcode] = {
                anns: [
                    ann_a,
                    ann_b
                ],
                rst: {},
            };

            // save the hashcode
            iaa_dict.stat.matched_hashcodes.push(hashcode);
            
            // let's save this ann_b
            ann_dict[hashcode].push({ 
                ann: ann_b,
                from: 'b'
            });

            // now, time to evaluate
            var rst = this.evaluate_ann_on_dtd(
                dtd,
                ann_a,
                ann_b,
                match_mode,
                overlap_ratio
            );

            // save this result
            iaa_dict.ann[hashcode].rst = rst;
        }

        // third, check if there is any unmatched from ann a
        for (const hashcode in ann_dict) {
            if (Object.hasOwnProperty.call(ann_dict, hashcode)) {
                if (ann_dict[hashcode].length == 1 &&
                    ann_dict[hashcode][0].from == 'a') {
                    // which means ... this ann is not used for matching
                    iaa_dict.stat.unmatched.push(ann_dict[hashcode][0]);

                    console.log('* found unmatched ann a', ann_dict[hashcode][0].ann);
                }
            }
        }

        // finally, calculate the result at all and tag levels
        var cm_all = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var cm_tag = { tp: 0, fp: 0, fn: 0 };
            
            for (const hashcode in iaa_dict.ann) {
                if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                    const iaa = iaa_dict.ann[hashcode];
                    // add the result of this tag
                    cm_tag.tp += iaa.rst.tag[tag_def.name].cm.tp;
                    cm_tag.fp += iaa.rst.tag[tag_def.name].cm.fp;
                    cm_tag.fn += iaa.rst.tag[tag_def.name].cm.fn;
                }
            }
            // get the tag level result
            var tag_result = this.calc_p_r_f1(cm_tag);
            iaa_dict.tag[tag_def.name] = tag_result;

            // add the tag level to all
            cm_all.tp += cm_tag.tp;
            cm_all.fp += cm_tag.fp;
            cm_all.fn += cm_tag.fn;
        }
        // get the all level result
        var all_result = this.calc_p_r_f1(cm_all);
        iaa_dict.all = all_result;

        return iaa_dict;
    },

    evaluate_ann_on_dtd: function(dtd, ann_a, ann_b, match_mode, overlap_ratio) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = 0.01;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // check each etag
        var result_ann = {
            all: {},
            tag: {}
        }
        var cm_ann = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var r = this.evaluate_ann_on_tag(tag_def, ann_a, ann_b, match_mode, overlap_ratio);
            result_ann.tag[tag_def.name] = r;

            // add the result of this tag
            cm_ann.tp += r.cm.tp;
            cm_ann.fp += r.cm.fp;
            cm_ann.fn += r.cm.fn;

        }
        var all_result = this.calc_p_r_f1(cm_ann);

        result_ann.all = all_result;

        return result_ann;
    },

    evaluate_ann_on_tag: function(tag_def, ann_a, ann_b, match_mode, overlap_ratio) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = 0.01;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // get all tags of this tag_def
        var tag_list_a = this.get_tag_list_by_tag(tag_def, ann_a);
        var tag_list_b = this.get_tag_list_by_tag(tag_def, ann_b);

        var cm = this.calc_matching(tag_list_a, tag_list_b, match_mode, overlap_ratio);
        var result = this.calc_p_r_f1(cm);

        return result;
    },

    calc_matching: function(tag_list_a, tag_list_b, match_mode, overlap_ratio) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = 0.01;
        }
        var cm = {
            tp: 0,
            fp: 0,
            fn: 0,
            
            // save the details
            tags: {
                tp: [],
                fp: [],
                fn: []
            }
        };

        // this dictionary is for generating the list for FN list
        var tag_dict_b = {};
        for (let i = 0; i < tag_list_b.length; i++) {
            const tag = Object.assign({}, tag_list_b[i]);
            tag_dict_b[tag.spans] = tag;
        }

        for (let i = 0; i < tag_list_a.length; i++) {
            var tag_a = tag_list_a[i];
            
            var is_match = this.is_tag_in_list(
                tag_a, 
                tag_list_b, 
                match_mode,
                overlap_ratio
            );

            console.log('* a', tag_a.spans, is_match.is_in, 'b', is_match.tag_b);

            if (is_match.is_in) {
                cm.tp += 1;
                cm.tags.tp.push([tag_a, is_match.tag_b]);

                // remove this tag_b from the dict
                delete tag_dict_b[is_match.tag_b.spans];

            } else {
                cm.fp += 1;
                cm.tags.fp.push([
                    tag_a, 
                    // usually, the tag_b is null,
                    // but sometimes it is not
                    is_match.tag_b
                ]);

                // in some cases, it's not match is due to low overlap ratio
                // we need to remove this tag_b as well.
                // but we may also want to keep both?
                // if (is_match.tag_b != null) {
                //     delete tag_dict_b[is_match.tag_b.spans];
                // }
            }
        }

        cm.fn = tag_list_b.length - cm.tp;
        cm.tags.fn = Object.values(tag_dict_b).map(tag => [null, tag]);

        return cm;
    },

    is_tag_in_list: function(tag, tag_list, match_mode, overlap_ratio) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = 0.01;
        }
        var spans = tag.spans;
        var loc_a = this.spans2loc(spans);

        // potential b
        var p_tag_b = null;

        for (let i = 0; i < tag_list.length; i++) {
            const tag_b = tag_list[i];
            var spans_b = tag_b.spans;

            if (match_mode == 'overlap') {
                // for overlap mode, check ranges of two spans
                var loc_b = this.spans2loc(spans_b);
                var is_olpd = this.is_overlapped(
                    loc_a, loc_b, 
                    overlap_ratio
                );
                if (is_olpd[0]) {
                    return { 
                        is_in: true,
                        tag_b: tag_b
                    };
                }
                // in some cases, the overlapped ratio is low
                // but still match, we need to check this case
                if (is_olpd[1] > 0) {
                    p_tag_b = tag_b;
                }
                
            } else if (match_mode == 'exact') {

                if (spans == spans_b) {
                    return {
                        is_in: true,
                        tag_b: tag_b
                    };
                }
            }
        }

        return {
            is_in: false,
            tag_b: p_tag_b
        };
    },

    is_overlapped: function(loc_a, loc_b, overlap_ratio) {
        if (typeof(overlap_ratio)=='undefined') {
            overlap_ratio = 0.01;
        }
        
        var s_a = new Set(new Array(loc_a[1] - loc_a[0] + 1).fill(loc_a[0]).map((e,i)=>e+i));
        var s_b = new Set(new Array(loc_b[1] - loc_b[0] + 1).fill(loc_b[0]).map((e,i)=>e+i));

        var s_inter = this.set_intersection(s_a, s_b);
        var s_union = this.set_union(s_a, s_b);
        var r = s_inter.size / s_union.size;

        // console.log('* is overlapped', loc_a, '', loc_b, 'i:', s_inter.size, 'u:', s_union.size, 'r:', r);

        if (r >= overlap_ratio) {
            return [true, r];
        } else {
            return [false, r]
        }
    },

    spans2loc: function(spans) {
        var vs = spans.split('~');
        return [
            parseInt(vs[0]), 
            parseInt(vs[1])
        ];
    },

    calc_p_r_f1: function(cm) {
        var precision = this.calc_precision(cm.tp, cm.fp);
        var recall = this.calc_recall(cm.tp, cm.fn);
        var f1 = this.calc_f1_by_pr(precision, recall);

        return {
            precision: precision,
            recall: recall,
            f1: f1,
            cm: cm
        }
    },

    calc_precision: function(tp, fp) {
        return tp / (tp + fp);
    },

    calc_recall: function(tp, fn) {
        return tp / (tp + fn);
    },

    calc_f1: function(tp, fp, fn) {
        var precision = this.calc_precision(tp, fp);
        var recall = this.calc_recall(tp, fn);
        return 2 * precision * recall / (precision + recall);
    },

    calc_f1_by_pr: function(precision, recall) {
        return 2 * precision * recall / (precision + recall);
    },

    get_tag_list_by_tag: function(tag_def, ann) {
        var tag_dict = {};
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (tag.tag == tag_def.name) {
                tag_dict[tag.spans] = tag;
            }
        }

        // conver the dictionary to list
        var tag_list = Object.values(tag_dict);
        return tag_list;
    },

    hash: function(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    set_union: function(setA, setB) {
        let _union = new Set(setA)
        for (let elem of setB) {
            _union.add(elem)
        }
        return _union
    },
    
    set_intersection: function(setA, setB) {
        let _intersection = new Set()
        for (let elem of setB) {
            if (setA.has(elem)) {
                _intersection.add(elem)
            }
        }
        return _intersection
    },

    /**
     * Find the longest common substring
     * @param {string} str1 a string
     * @param {string} str2 another string
     * @returns longest common substring
     */
    find_lcs: function(str1, str2) {
        let m = new Array(str1.length+1).fill(0).map(function() {
            return new Array(str2.length+1).fill(0);
        });
        let max = 0;
        let index = null;
        for (let i = 0; i < str1.length; i++) {
            
            for (let j = 0; j < str2.length; j++) {
                
                if(str1.charAt(i) === str2.charAt(j)){
                    if(i>0 && j>0 && m[i-1][j-1]>0) {
                        m[i][j] = 1 + m[i-1][j-1];
                    } else{
                        m[i][j] = 1;
                    }
                    
                    if(max < m[i][j]){
                        max = m[i][j];
                        index = i;
                    }
                } else {
                    
                }
            }
        }

        return str1.substr(index-max + 1, max)
    },
    
};

// The NLP toolkit
var nlp_toolkit = {

    sent_tokenize: function(text, backend) {
        if (typeof(backend) == 'undefined') {
            backend = 'simpledot';
        }
        console.log('* sentencizing text by ' + backend);

        if (backend == 'simpledot') {
            return this.sent_tokenize_by_simpledot(text);
        }

        if (backend == 'compromise') {
            return this.sent_tokenize_by_compromise(text);
        }

        if (backend == 'wink_nlp') {
            return this.sent_tokenize_by_wink_nlp(text);
        }

        throw {
            name: 'Not found backend',
            message: "The backend is not valid."
        }
    },

    tokenize_by_wink_nlp: function(text) {

    },

    /**
     * Convert the spans to the token index
     * 
     * The item in the list of tags need to contain the following:
     * {
     *     name: 'NAME', // the name this tags, e.g., LOC, PER, GEO
     *     span: [1, 2], // the start and end this tag in this sentence
     * }
     * 
     * So, the text of the tag is not required.
     * After processing, this will return a list:
     * [{
     *     token: 'TOKEN TEXT', // the text of this token
     *     span: [1, 2],        // the start and end of this token
     *     label: 'B-LOC'       // the BIO label, e.g., B-X, I-X, O
     * }, ...]
     * 
     * If any pre-processing is needed, please do it before calling.
     * 
     * @param {string} sentence just a sentence text
     * @param {list} tags list of tags
     * 
     * @returns {list} the list of token position and labels
     */
    convert_span_to_bio_by_wink_nlp: function(sentence, tags) {
        // first, convert the sentence to tokens
        var doc = wink_nlp.readDoc(sentence);
        var tokens = doc.tokens().out();
        
        // then search each token and get the position
        var idx = 0; 
        var pos = []; 
        for (let i=0; i<tokens.length; i++) {
            const token = tokens[i];
            var ia = sentence.indexOf(token);
            var tp = 1;
            while(true) {
                if (ia >= idx) {
                    pos.push({
                        token: token,
                        span: [ia, ia + token.length],
                        // the default label is just O
                        label: 'O'
                    })
                    idx = ia + token.length;
                    break;
                } else {
                    ia = sentence.indexOf(token, tp);
                    tp += 1;
                }
            }
        }
        
        // ok, let's check each token pos
        // make a copy of tags
        var tgs = JSON.parse(JSON.stringify(tags));
        for (let i=0; i<pos.length; i++) {
            // the simplest is just check all tags
            for (let j=0; j<tgs.length; j++) {
                if (i==4) {
                    console.log("j=" +j + ': '+ tgs[j].span + ' vs ' + pos[i].span);
                }
                if (this.is_overlapped(tgs[j].span, pos[i].span)) {
                    if (tgs[j].hasOwnProperty('_has_met')) {
                        pos[i].label = 'I-' + tgs[j].name;
                    } else {
                        pos[i].label = 'B-' + tgs[j].name;
                        tgs[j]._has_met = true;
                    }
                    break;
                }
            }
        }
        
        return pos;
    },

    sent_tokenize_by_wink_nlp: function(text) {
        var doc = wink_nlp.readDoc(text);
        var raw_sentences = doc.sentences().out();

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};
        // get all sentences and spans
        var sentences = [];
        // get all sentence trimed text
        var sentences_text = [];

        for (let idx=0; idx<raw_sentences.length; idx++) {
            // get this sentence
            var sentence = raw_sentences[idx];
            var spans_start = text.indexOf(sentence);

            // TODO fix the multiple same sentence bug
            if (sentences_dict.hasOwnProperty(sentence)) {
                // which means this is a duplicated 
                var i = 1;
                var cnt = 0;
                while(true) {
                    spans_start = text.indexOf(sentence, i);

                    if (sentences_dict[sentence] == spans_start) {
                        // which means this sentence appeared
                        i += 1;
                        cnt += 1;

                    } else {
                        // which means this span start is a new one
                        sentences_dict[sentence] = spans_start;
                        break;
                    }
                }

            } else {
                // ok, just add this new sentence
                sentences_dict[sentence] = spans_start;
            }
            var spans_end = spans_start + sentence.length;

            // sometimes the sentence has right blanks
            // we need to remove it to avoid unexpected linebreaks
            sentence = sentence.trimRight();

            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        };

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    sent_tokenize_by_simpledot: function(text) {
        // get all sentences and spans
        var sentences = [];

        // get all sentence trimed text
        var sentences_text = [];

        // a temp sentence
        var sentence = [];
        // locate the sentence start
        var spans_start = 0;
        // locate the sentence end
        var spans_end = 0;
        // flag for a sentence end
        var flag_sent = false;

        for (let i = 0; i < text.length; i++) {
            // get the current char
            const c = text[i];

            // set the end to current char
            spans_end = i;
            
            // before checking, set the flag to false
            flag_sent = false;

            // detect if this is a sentence break
            if (c == '.') {
                // but there are some corner cases
                flag_sent = true;
                // collect the char
                sentence.push(c);
                
            } else if ( c == '?' || c == '!' || c == ';') {
                flag_sent = true;
                // collect the char
                sentence.push(c);
    
            } else if ( c == '\n') {
                flag_sent = true;
                // no need to collect
                // sentence.push(c);

            } else {
                // collect the char
                sentence.push(c);
            }

            if (flag_sent) {
                // ok, this is a sentence.
                var _sentence = sentence.join('');

                // clear the collection
                sentence = [];

                // create a new sentence obj
                sentences.push({
                    text: _sentence, 
                    spans: {
                        start: spans_start, 
                        end: spans_end
                    }
                });

                // put the text
                sentences_text.push(_sentence);

                // move the spans_start to spans_end
                spans_start = spans_end + 1;
            }
        }

        // ok, let's check if the sentence collection is empty
        if (sentence.length > 0) {
            // there is a last sentence
            var _sentence = sentence.join('');

            // create a new sentence obj
            sentences.push({
                text: _sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });

            // put the text
            sentences_text.push(_sentence);
        }

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    sent_tokenize_by_compromise: function(text) {
        // first, convert the raw text to a doc object
        var doc = nlp(text);

        // get all sentences and spans
        var sentences = [];

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};

        // get all sentence trimed text
        var sentences_text = [];

        doc.sentences().forEach(function(d) {
            // get this sentence
            var sentence = d.text();
            var spans_start = text.indexOf(sentence);

            // TODO fix the multiple same sentence bug
            if (sentences_dict.hasOwnProperty(sentence)) {
                // which means this is a duplicated 
                var i = 1;
                var cnt = 0;
                while(true) {
                    spans_start = text.indexOf(sentence, i);

                    if (sentences_dict[sentence] == spans_start) {
                        // which means this sentence appeared
                        i += 1;
                        cnt += 1;

                    } else {
                        // which means this span start is a new one
                        sentences_dict[sentence] = spans_start;
                        break;
                    }
                }

            } else {
                // ok, just add this new sentence
                sentences_dict[sentence] = spans_start;
            }
            var spans_end = spans_start + sentence.length;

            // sometimes the sentence has right blanks
            // we need to remove it to avoid unexpected linebreaks
            sentence = sentence.trimRight();

            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        });

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    find_linech: function(pos, sentences) {
        for (let i = 0; i < sentences.length; i++) {
            const sentence = sentences[i];
            if (pos>=sentence.spans.start &&
                pos<=sentence.spans.end) {
                return {
                    line: i, 
                    ch: pos-sentence.spans.start
                };
            }
        }
        return null;
    },

    is_overlapped: function(a, b) {
        if (a[0] >= b[0] && a[0] < b[1]) {
            return true;
        }
        if (a[1] > b[0] && a[1] <= b[1]) {
            return true;
        }
        if (a[0] <= b[0] && a[1] >= b[1]) {
            return true;
        }
        return false;
    },

    download_text_tsv: function(anns, dtd, hint_dict, fn) {
        // convert the hint dict to a json obj
        var json = [];

        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                const tag_dict = hint_dict[tag_name];
                
                for (const tag_text in tag_dict.text_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.text_dict, tag_text)) {
                        const tag = tag_dict.text_dict[tag_text];
                        
                        json.push({
                            tag: tag_name,
                            text: tag_text,
                            count: tag.count
                        });
                    }
                }

                // the nc tag
                for (const fn in tag_dict.nc_dict.ann_fn_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.nc_dict.ann_fn_dict, fn)) {
                        const count = tag_dict.nc_dict.ann_fn_dict[fn];
                        
                        json.push({
                            tag: tag_name,
                            text: fn,
                            count: count
                        });
                    }
                }
            }
        }

        // then convert the json to csv
        var tsv = Papa.unparse(json, {
            delimiter: '\t'
        });

        // download this tsv
        var blob = new Blob([tsv], {type: "text/tsv;charset=utf-8"});
        saveAs(blob, fn);

        return tsv;
    },

    /**
     * Download the BIO format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     */
    download_dataset_bio: function(anns, dtd, fn, ratios, skip_non_tags_sentence) {
        if (typeof(ratios)=='undefined') {
            ratios = [0.8, 0.1, 0.1];
        }
        if (typeof(skip_non_tags_sentence)=='undefined') {
            skip_non_tags_sentence = true;
        }
        // first, create the dataset itself
        var ann_sentence_tags = {};

        // check each tag
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            var sentence_tags = {};
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];

                // now mapping the span to token index
                if (!tag.hasOwnProperty('spans')) {
                    // this is not an entity tag
                    continue;
                }
                
                var spans = tag.spans.split(',');
                for (let k = 0; k < spans.length; k++) {
                    const _span = spans[k];

                    const span = this.txt2span(_span);
                    if (span[0] == -1 || spans[1] == -1) {
                        // which means this tag is just a non-consuming tag
                        // at present, we won't use this kind of tag when
                        // exporting the BIO
                        continue;
                    }
                    // find the offset in a sentence
                    var loc0 = this.find_linech(span[0], ann._sentences);
                    if (loc0 == null) {
                        // something wrong?
                        continue;
                    }

                    // find the location for the right part
                    // var loc1 = this.find_linech(span[1], ann._sentences);
                    var loc1 = Object.assign({}, loc0);
                    loc1.ch += (span[1] - span[0]);

                    if (!sentence_tags.hasOwnProperty(loc0.line)) {
                        sentence_tags[loc0.line] = {
                            sentence: ann._sentences[loc0.line],
                            tags: []
                        }
                    }

                    // put this tag for this line
                    sentence_tags[loc0.line].tags.push({
                        name: tag.tag,
                        span: [
                            loc0.ch,
                            loc1.ch
                        ],
                        // if k>0, which means this span is a multi location tag
                        force_label_i: k != 0
                    });
                }
            }
            ann_sentence_tags[i] = sentence_tags;
        }

        // now, we need to convert each sentence to 
        // the BIO format
        var bios_all = [];
        for (const ann_idx in ann_sentence_tags) {
            if (Object.hasOwnProperty.call(ann_sentence_tags, ann_idx)) {
                const sentence_tags = ann_sentence_tags[ann_idx];
                for (const sent_idx in sentence_tags) {
                    if (Object.hasOwnProperty.call(sentence_tags, sent_idx)) {
                        if (sentence_tags[sent_idx].tags.length == 0) {
                            if (skip_non_tags_sentence) {
                                continue;
                            }
                        };
                        
                        var labeled_tokens = this.convert_span_to_bio_by_wink_nlp(
                            sentence_tags[sent_idx].sentence.text,
                            sentence_tags[sent_idx].tags
                        );
        
                        bios_all.push(labeled_tokens);
                    }
                }
            }
        }
        // split into train, dev, test
        var [bios_train, bios_dt] = ds_spliter(bios_all, ratios[0]);
        var [bios_dev, bios_test] = ds_spliter(bios_dt, ratios[1] / (ratios[1] + ratios[2]));

        // create a help function for converting
        function bios2text(bios) {
            var txt_ds = [];
            var txt_lb = {};

            for (let i = 0; i < bios.length; i++) {
                const labeled_tokens = bios[i];
                for (let j = 0; j < labeled_tokens.length; j++) {
                    const item = labeled_tokens[j];
                    txt_ds.push(
                        item.token + '\t' + item.label
                    );
                    txt_lb[item.label] = 1;
                }
                // add a blank line after each sentence
                txt_ds.push('');
            }
            return [txt_ds, txt_lb];
        }

        // merge into text
        var [txt_dataset, txt_labels] = bios2text(bios_all);
        var [txt_train, _] = bios2text(bios_train);
        var [txt_dev, _] = bios2text(bios_dev);
        var [txt_test, _] = bios2text(bios_test);
        
        // convert text arr to pure string
        txt_dataset = txt_dataset.join('\n');
        txt_train = txt_train.join('\n');
        txt_dev = txt_dev.join('\n');
        txt_test = txt_test.join('\n');
        txt_labels = Object.keys(txt_labels).sort().join('\n');

        // last, create a zip file, which contains
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = 'dataset-'+ dtd.name + '-BIO';

        // add the text dataset to zip
        zip.file(folder_name + '/dataset.tsv', txt_dataset);
        // add the label to zip
        zip.file(folder_name + '/labels.tsv', txt_labels);
        // add the splited to zip
        zip.file(folder_name + '/train.tsv', txt_train);
        zip.file(folder_name + '/dev.tsv', txt_dev);
        zip.file(folder_name + '/test.tsv', txt_test);

        // create zip file
        zip.generateAsync({ type: "blob" }).then((function(fn) {
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));

        return txt_dataset;
    },

    txt2span: function(txt) {
        var ps = txt.split('~');
        return [
            parseInt(ps[0]),
            parseInt(ps[1])
        ]
    }

};

// The Vue APP
var app_hotpot = {
    // metro app toast
    metro_toast: Metro.toast.create,

    // for tour
    tour: {
        annotation: null,
    },

    // vue app
    vpp: null,
    vpp_id: '#app_hotpot',

    vpp_data: {
        // for the section control
        section: 'annotation',

        // for the dtd
        dtd: null,

        // for the ann files
        ann_idx: null,
        anns: [],

        // for showing the tag by tag_name,
        display_tag_name: '__all__',

        // for the hints of current ann
        hints: [],

        // for all hints of all anns
        hint_dict: {},

        // for popmenu
        clicked_tag_id: null,

        // a flag for showing which mode we are working
        is_linking: false,
        linking_tag_def: null,
        linking_tag: null,
        linking_atts: [],
        
        // linking
        pan_working_tag: {
            pos: {
                clientX: undefined,
                clientY: undefined,
                movementX: 0,
                movementY: 0
            }
        },

        // for converting the txt to xmls
        txt_anns: [],
        txt_xmls: [],
        txt_xml_prefix: '',
        txt_xml_suffix: '',

        // for file name filter
        fn_pattern: '',

        // for iaa comp
        iaa_ann_list: [
            {anns: [], name: 'A'}, // for annotator A
            {anns: [], name: 'B'}, // for annotator B
        ],
        iaa_dict: null,
        iaa_display_tag_name: '__all__',
        iaa_match_mode: 'overlap', // overlap / exact
        iaa_overlap_ratio: 50,
        iaa_overlap_ratio_default: 50,
        iaa_display_hashcode: null,
        iaa_display_tags_context: true,
        iaa_display_tags_tp: false,
        iaa_display_adj_panel: true,
        iaa_display_adj_detail: false,
        force_module_update: Math.random(), // for updating the sub module

        // for iaa adjudication
        iaa_gs_dict: null,

        // cm settings
        cm: {
            // document / sentences
            display_mode: 'document',

            // node / span
            mark_mode: 'node',

            // simple / smart
            hint_mode: 'simple',

            // update the hint when delete
            // but I found this is not doable.
            // the deleted tag may be used in different place,
            // so simplely deleting the token from hint dict 
            // may cause issue.
            enabled_auto_hint_update: true,

            // display the hints or not
            enabled_hints: true,

            // display the links
            enabled_links: true,

            // display the link name
            enabled_link_name: true,

            // display complex link
            enabled_link_complex: true,

            // for updating the codemirror instance
            is_expire: false
        },

        // general cfg
        cfg: {
            // display the setting panel or not
            is_show_settings: false,

            // active tab
            active_setting_tab: 'import',

            // which algorithm to use as default
            sentence_splitting_algorithm: 'simpledot',
        },

        // for statistics

        // for export
        export_text: null,

        // for texts
        // this variable would be replaced by the 
        // app_hotpot_ext_texts.js module
        texts: {}
    },

    vpp_methods: {
        /////////////////////////////////////////////////////////////////
        // Settings related functions
        /////////////////////////////////////////////////////////////////
        switch_setting_tab: function(tab) {
            this.cfg.active_setting_tab = tab;
        },

        /////////////////////////////////////////////////////////////////
        // Annotation section related functions
        /////////////////////////////////////////////////////////////////
        save_xml_by_idx: function(idx) {
            // switch to this ann first
            if (this.ann_idx != idx) {
                this.ann_idx = idx;
            }
            // $this.$forceUpdate();
            this.save_xml();
        },

        save_xml: function() {
            // before checking, need to ensure the FSA API
            if (this.has_FSA_API()) {
                // OK, go go go
            } else {
                // well ... it's ok ...
                app_hotpot.msg('The browser you are using does not support File System Access API. You can use "Download XML" function instead.', 'warning');
                return;
            }
            // before saving, need to check the _fh
            var p_ann = null;
            if (this.anns[this.ann_idx]._fh === null ||
                typeof(this.anns[this.ann_idx]._fh.createWritable)==='undefined') {
                // which means this ann's original file is not available
                // or it is a txt-converted ann
                // let's go to save as directly
                p_ann = fs_save_new_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
                
            } else {
                // normal save
                var p_ann = fs_save_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
            }
            p_ann.then(function(ann) {
                // usually it should be OK ...
                // but it may change ...
                // using the given ann to replace the current ann
                app_hotpot.vpp.set_current_ann(ann);
                app_hotpot.toast('Successfully saved ' + ann._filename);
            })
            .catch(function(error) {
                console.log(error);
                if (error.name == 'AbortError') {
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                if (error.name == 'NotAllowedError') {
                    // which means user or system cancelled this saving
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                app_hotpot.msg(
                    'Saving xml failed. Try to use "Save As" instead.', 
                    'bg-lightCrimson fg-white'
                );
                console.log('* error when save xml', error);
            });;
        },
        
        save_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // create a new name for suggestion
            var new_fn = 'copy_of_' + fn;

            // ask for new fh for this file
            var p_fh = fs_get_new_ann_file_handle(new_fn);

            // when new fh is ready, save it
            p_fh.then((function(xmlStr){
                return function(fh) {
                    // first, update the fh
                    
                    // save this xmlStr with the given fh
                    let p_done = fs_write_ann_file(
                        fh,
                        xmlStr
                    );

                    // show something when saved
                    p_done.then(function(fh) {
                        app_hotpot.toast('Successfully saved as ' + fh.name);
                    });
                }
            })(xmlStr))
            .catch(function(error) {
                console.log('* error when save as xml', error);
            });
        },
        
        download_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // download this csv
            var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
            saveAs(blob, fn);
        },

        show_wiki: function() {
            // app_hotpot.start_tour_annotation();
            window.open(
                'https://github.com/OHNLP/MedTator/wiki',
                '_blank'
            );
        },

        load_sample_ds: function(ds_name) {
            if (typeof(ds_name) == 'undefined') {
                ds_name = 'MINIMAL_TASK';
            }
            $.get(
                './static/data/vpp_data_'+ds_name+'.json', 
                {
                    rnd: Math.random()
                }, 
                function(data) {
                    Object.assign(app_hotpot.vpp.$data, data);
                    app_hotpot.set_dtd(
                        app_hotpot.vpp.$data.dtd
                    );
                    app_hotpot.vpp.set_ann_idx(0);
                }, 
                'json'
            );
        },

        open_dtd_file: function() {
            // the settings for dtd file
            var pickerOpts = {
                types: [
                    {
                        description: 'DTD File',
                        accept: {
                            'text/dtd': ['.dtd']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: false
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // read the fh and set dtd
                // in fact, there is only one file for this dtd
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    // read the file
                    var p_dtd = fs_read_dtd_file_handle(fh);

                    p_dtd.then(function(dtd) {
                        app_hotpot.set_dtd(dtd);
                    });
                }
            });
        },
        
        open_ann_files: function() {
            // the settings for annotation file
            var pickerOpts = {
                types: [
                    {
                        description: 'Annotation File',
                        accept: {
                            'text/xml': ['.xml']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // bind the content
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    // check exists
                    if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
                        // exists? skip this file
                        app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
                        return;
                    }
                    
                    // parse this ann fh
                    app_hotpot.parse_ann_file_fh(
                        fh,
                        app_hotpot.vpp.$data.dtd
                    );
                }
            });
        },

        update_tag_table: function(tag) {
            console.log('* update tag table', tag);
        },

        set_current_ann: function(ann) {
            // replace the ann object
            this.anns[this.ann_idx] = ann;

            // reset the marks and others
            this.set_ann_idx(this.ann_idx);
        },

        set_ann_idx: function(idx) {
            console.log('* set ann_idx', idx);

            // update the ann_idx
            this.ann_idx = idx;

            if (idx == null) {
                // which means remove the content
                app_hotpot.cm_set_ann(null);

                // update the marks
                app_hotpot.cm_update_marks();

            } else {
                // update the text display
                app_hotpot.cm_set_ann(
                    this.anns[this.ann_idx]
                );

                // update the marks
                app_hotpot.cm_update_marks();
            }
        },

        show_ann_file: function(fn) {
            // first, find the ann_idx
            var idx = this.fn2idx(fn);

            if (idx < 0) {
                // no such file
                app_hotpot.toast('Not found ' + fn + ' file', 'bg-yellow');
                return;
            }

            // then switch to annotation
            this.switch_mui('annotation');

            // then show the idx
            this.set_ann_idx(idx);

            // trick for cm late update
            this.cm.is_expire = true;
        },

        fn2idx: function(fn) {
            for (let i = 0; i < this.anns.length; i++) {
                if (this.anns[i]._filename == fn) {
                    return i;
                }                
            }
            return -1;
        },

        remove_ann_file: function(idx) {
            // delete this first
            this.anns.splice(idx, 1);

            // once the file is removed, update the hint_dict
            // app_hotpot.update_hint_dict_by_anns();

            if (idx == this.ann_idx) {
                this.set_ann_idx(null);
            }

            // need to move the current ann_idx location
            if (idx < this.ann_idx) {
                this.ann_idx -= 1;
            }
        },

        remove_all_ann_files: function() {
            var ret = window.confirm('Are you sure to remove all annotation files?');
            if (ret) {
                this.set_ann_idx(null);
                this.anns = [];
            }
        },

        highlight_tag: function(tag) {
            var dom_id = 'mark-etag-id-' + tag.id;
            console.log('* highlight tag: ' + dom_id);

            // remove class
            $('.mark-tag-active').removeClass('mark-tag-active');

            // jump to this tag for display
            app_hotpot.cm_jump2tag(
                tag, 
                this.anns[this.ann_idx]
            );

            // remove class
            $('.mark-tag-active').removeClass('mark-tag-active');

            // add a class to this dom
            $('#'+dom_id).addClass('mark-tag-active');
        },

        on_change_attr_value: function(event) {
            // just mark current ann as unsaved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* changed attr in', event.target);
        },

        on_change_idref_value: function(event) {
            this.anns[this.ann_idx]._has_saved = false;
            // then, need to update this value
            this.on_change_link_settings(event);
        },

        on_input_attr_value: function(event) {
            // just mark current ann as unsaved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* changed input attr to', event.target.value);
        },

        on_change_display_mode: function(event) {
            console.log(event.target.value);
            // need to set ann again,
            // it will display according to the mode
            app_hotpot.cm_set_ann(
                this.anns[this.ann_idx]
            );
            app_hotpot.cm_update_marks();
        },

        on_change_mark_mode: function(event) {
            console.log(event.target.value);
            app_hotpot.cm_update_marks();
        },

        // on_change_hint_mode: function(event) {
        //     console.log(event.target.value);
        //     app_hotpot.cm_update_marks();
        // },
        on_change_hint_mode: function(hint_mode) {
            this.cm.hint_mode = hint_mode;
            app_hotpot.cm_update_marks();
        },

        on_change_link_settings: function(event) {
            console.log(event.target.value);
            app_hotpot.cm_clear_ltag_marks();
            app_hotpot.cm_update_ltag_marks();
        },

        accept_all_hints: function() {
            if (this.hints.length == 0) {
                app_hotpot.msg('No hints found');
                return;
            }

            var msg = [
                "There are " + this.hints.length + " hints found and not decided yet in current annotation:\n\n"
            ];
            for (let i = 0; i < this.hints.length; i++) {
                msg.push((i+1) + ' | ' + this.hints[i].tag + ', ' + this.hints[i].spans + ' [' + this.hints[i].text + ']\n');
            }
            msg.push('\nAre you sure to accept all of them?');

            msg = msg.join('');

            var ret = window.confirm(msg);

            if (ret) {
                // check all hints
                for (let i = 0; i < this.hints.length; i++) {
                    const hint_id = this.hints[i].id;
                    this.add_tag_by_hint(hint_id, false);
                }
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();

            } else {
                return;
            }
        },

        get_hint: function(hint_id) {
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].id == hint_id) {
                    return this.hints[i];
                }
            }
            return null;
        },

        add_tag_by_hint: function(hint_id, update_marks) {
            if (typeof(update_marks)=='undefined') {
                update_marks = true;
            }
            // get the hint from list 
            var hint = this.get_hint(hint_id);
            if (hint == null) { 
                // fix the missing
                app_hotpot.cm_update_marks();
                return; 
            }
            var tag_name = hint.tag;

            // createa new ann tag
            var _tag = {
                'spans': hint.spans,
                'text': hint.text
            }
            var tag_def = this.dtd.tag_dict[tag_name];
            
            // create a new tag
            var tag = app_hotpot.make_etag(_tag, tag_def, this.anns[this.ann_idx]);

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* added tag by hint, ' + tag_name + ' on ' + hint.text);

            // update the hint_dict
            app_hotpot.update_hint_dict_by_tag(
                this.anns[this.ann_idx],
                tag
            );

            if (update_marks) {
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();
            }
        },

        add_nc_etag_by_ctxmenu: function(tag_def) {
            this.add_nc_etag(tag_def);

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_nce.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added nc etag by right click, ' + tag_def.name);
        },

        add_etag_by_ctxmenu: function(tag_def) {

            // get the basic tag
            var _tag = app_hotpot.cm_make_basic_tag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_sel.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added etag by right click, ' + tag_def.name);
        },

        add_etag_by_shortcut_key: function(key) {
            // first, get selection
            var selection = app_hotpot.cm_get_selection();
            if (selection.sel_txts == '') {
                // nothing selected for tag, skip
                return;
            }

            // then get the tag_def by the given key
            var tag_def = null;
            for (let i = 0; i < this.dtd.etags.length; i++) {
                if (this.dtd.etags[i].shortcut == key) {
                    // found!
                    tag_def = this.dtd.etags[i];
                    break
                }
            }
            if (tag_def == null) {
                // oh, this shortcut is not registered
                return;
            }

            // get a basic tag
            var _tag = app_hotpot.cm_make_basic_tag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            console.log('* added tag by shortcut, ' + tag_def.name + ' on ' + _tag.text);
        },

        add_etag: function(basic_tag, tag_def) {
            // create a new tag
            var tag = app_hotpot.make_etag(
                basic_tag, 
                tag_def, 
                this.anns[this.ann_idx]
            );

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // add this new tag to hint_dict
            app_hotpot.update_hint_dict_by_tag(this.anns[this.ann_idx], tag);

            // update the cm
            app_hotpot.cm_update_marks();
        },

        add_nc_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);

            // set to nc 
            etag.spans = dtd_parser.NON_CONSUMING_SPANS;

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        add_empty_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);
            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        add_empty_ltag: function(ltag_def) {
            var ltag = app_hotpot.make_empty_ltag_by_tag_def(ltag_def);

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                ltag_def
            );
            ltag.id = tag_id;

            // add to list
            this.anns[this.ann_idx].tags.push(ltag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        del_tag: function(tag_id) {
            // delete the clicked tag id
            app_hotpot.del_tag(
                tag_id, this.anns[this.ann_idx]
            );
        },


        /////////////////////////////////////////////////////////////////
        // Statistics related functions
        /////////////////////////////////////////////////////////////////

        update_hint_dict: function() {
            app_hotpot.update_hint_dict_by_anns();
        },

        download_stat_summary: function() {
            var json = [];

            var stat_items = this.get_stat_items();

            for (let i = 0; i < stat_items.length; i++) {
                const stat_item = stat_items[i];
                json.push({
                    item: stat_item[0],
                    result: stat_item[1]
                });
            }

            // then convert the json to csv
            var csv = Papa.unparse(json, {
            });

            // download this csv
            var blob = new Blob([csv], {type: "text/tsv;charset=utf-8"});
            var fn = this.get_ruleset_base_name() + '-statistics.csv';
            saveAs(blob, fn);
        },

        get_stat_items: function() {
            return [
                ['# of documents', this.anns.length],
                ['# of tags in schema', this.dtd.etags.length],
                ['# of annotations', this.count_all_tags(this.anns)],
                ['# of annotations per tag', this.calc_avg_tags_per_def(this.anns, this.dtd)],
                ['# of annotations per document', this.calc_avg_tags_per_doc(this.anns)],
                [
                    '# of sentences',
                    this.count_all_sentences(this.anns)
                ],
                [
                    '# of sentences per document',
                    this.calc_avg_sentences_per_doc(this.anns)
                ],
            ];
        },
        
        /////////////////////////////////////////////////////////////////
        // Corpus menu related functions
        /////////////////////////////////////////////////////////////////

        clear_corpus_all: function() {
            this.txt_anns = [];
            this.txt_xmls = [];
        },

        open_txt_files: function() {
            // the settings for raw text file
            var pickerOpts = {
                types: [
                    {
                        description: 'Raw Text File',
                        accept: {
                            'text/txt': ['.txt']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // bind the content
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    // check exists
                    if (app_hotpot.vpp.has_included_txt_ann_file(fh.name)) {
                        // exists? skip this file
                        return;
                    }
                    
                    // read the file
                    var p_txt_ann = fs_read_txt_file_handle(
                        fh,
                        app_hotpot.vpp.$data.dtd
                    );
                    p_txt_ann.then(function(txt_ann) {
                        app_hotpot.vpp.add_txt(txt_ann);
                    });
                    
                }
            });
        },

        add_txt: function(txt_ann) {
            // update the dtd name here
            txt_ann.dtd_name = this.dtd.name;
    
            // put this to the list
            this.txt_anns.push(txt_ann);
        },

        convert_txt_anns_to_xmls: function() {
            // clear the current txt_xmls
            this.txt_xmls = [];

            for (let i = 0; i < this.txt_anns.length; i++) {
                const txt_ann = this.txt_anns[i];
                
                // create new filename
                var fn = txt_ann._filename;

                // get the xml string
                var xml = ann_parser.ann2xml(txt_ann, this.dtd);
                var str = ann_parser.xml2str(xml);

                // create an object for display
                var txt_xml = {
                    fn: fn,
                    text: str
                };

                this.txt_xmls.push(txt_xml);
            }
        },

        get_new_xml_filename: function(fn, ext='.xml') {
            var prefix = this.txt_xml_prefix.trim();
            var suffix = this.txt_xml_suffix.trim();
            var new_fn = fn;

            // add prefix
            if (prefix == '') {
                // nothing to do
            } else {
                new_fn = prefix + '_' + new_fn;
            }

            // add suffix
            if (suffix == '') {
                // nothing to do
                new_fn = new_fn + ext;
            } else {
                new_fn = new_fn + '_' + suffix + ext;
            }

            return new_fn;
        },

        get_new_xmls_zipfile_folder_name: function() {
            var fn = this.dtd.name + '-' + this.txt_anns.length;
            fn = this.get_new_xml_filename(fn, '');
            return fn + '-xmls';
        },

        download_txt_xml: function(txt_ann_idx) {
            var txt_xml = this.txt_xmls[txt_ann_idx];
            var fn = this.get_new_xml_filename(txt_xml.fn);
            var blob = new Blob([txt_xml.text], {type: "text/xml;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_txt_xmls_as_zip: function() {
            // create an empty zip pack
            var zip = new JSZip();
            var folder_name = this.get_new_xmls_zipfile_folder_name();

            // add files to zip pack
            for (let i = 0; i < this.txt_xmls.length; i++) {
                const txt_xml = this.txt_xmls[i];
                var fn = this.get_new_xml_filename(txt_xml.fn);
                var ffn = folder_name + '/' + fn;

                // add to zip
                zip.file(ffn, txt_xml.text);
                
                console.log('* added xml file ' + fn);
            }

            // create zip file
            zip.generateAsync({ type: "blob" }).then(function (content) {
                saveAs(content, app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + '.zip');
            });
        },

        /////////////////////////////////////////////////////////////////
        // IAA Related
        /////////////////////////////////////////////////////////////////
        clear_iaa_all: function() {
            // clear everything related to iaa
            this.iaa_ann_list[0].anns = [];
            this.iaa_ann_list[1].anns = [];

            this.iaa_dict = null;

            this.iaa_display_tag_name = '__all__';
            this.iaa_display_hashcode = null;
        },

        add_iaa_ann: function(ann, iaa_id) {
            this.iaa_ann_list[iaa_id].anns.push(ann);
        },

        calc_iaa: function() {
            var iaa_dict = iaa_calculator.evaluate_anns_on_dtd(
                this.dtd,
                this.iaa_ann_list[0].anns,
                this.iaa_ann_list[1].anns,
                this.iaa_match_mode,
                this.iaa_overlap_ratio / 100
            );
            this.iaa_dict = iaa_dict;
            console.log('* iaa result:', iaa_dict);

            // and create
            this.make_default_adj();
        },

        get_rst: function(obj) {
            if (this.iaa_display_tag_name == '__all__') {
                return obj.all;
            } else {
                return obj.tag[this.iaa_display_tag_name];
            }
        },

        on_change_iaa_settings: function(event) {
            console.log('* changed attr in', event.target);
        },

        make_default_adj: function() {
            this.iaa_gs_dict = iaa_calculator.get_default_gs_dict(
                this.dtd, this.iaa_dict
            );
        },

        get_gs_zipfile_folder_name: function() {
            return this.dtd.name + '-goldstandards';
        },

        download_all_gs: function() {
            // create an empty zip pack
            var zip = new JSZip();
            var folder_name = this.get_gs_zipfile_folder_name();

            // add files to zip pack
            for (const hashcode in this.iaa_gs_dict) {
                if (Object.hasOwnProperty.call(this.iaa_gs_dict, hashcode)) {
                    const ann_rst = this.iaa_gs_dict[hashcode];
                    
                    // change to an ann obj
                    var ann = iaa_calculator.make_ann_by_rst(ann_rst, this.dtd);

                    // get the xmlText
                    var xml_doc = ann_parser.ann2xml(ann, this.dtd);
                    var xml_text = ann_parser.xml2str(xml_doc);

                    // put this xml in folder (virtually)
                    var ffn = folder_name + '/' + ann._filename;
                    
                    // put this xml to zip
                    zip.file(ffn, xml_text);
                }
            }

            // create zip file
            zip.generateAsync({ type: "blob" }).then(function (content) {
                saveAs(content, app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + '.zip');
            });
        },

        count_gs_tags: function(ann_hashcode) {
            if (this.iaa_display_tag_name == '__all__') {
                return this.count_iaa_gs_notnull(this.iaa_gs_dict[ann_hashcode]);
            } else {
                return this.count_iaa_gs_tag_notnull(
                    this.iaa_gs_dict[ann_hashcode].rst[this.iaa_display_tag_name]
                );
            }
        },

        count_iaa_gs_notnull: function(ann_rst) {
            var cnt = 0;
            for (const tag_name in ann_rst.rst) {
                if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                    const tag_rst = ann_rst.rst[tag_name];
                    cnt += this.count_iaa_gs_tag_notnull(tag_rst);
                }
            }
            return cnt;
        },

        count_iaa_gs_tag_notnull: function(tag_rst) {
            var cnt = 0;
            for (const cm in tag_rst) {
                if (Object.hasOwnProperty.call(tag_rst, cm)) {
                    const tags = tag_rst[cm];
                    
                    for (let i = 0; i < tags.length; i++) {
                        if (tags[i] != null) {
                            cnt += 1;
                        }
                    }
                }
            }
            return cnt;
        },

        accept_iaa_tag: function(hashcode, tag_name, cm, tag_idx, from) {
            console.log('* accept', hashcode, tag_name, cm, tag_idx, from);
            this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = {
                tag: this.iaa_dict.ann[hashcode].rst.tag[tag_name].cm.tags[cm][tag_idx][
                    {'a':0, 'b':1}[from]
                ],
                from: from
            };
            this.force_module_update = Math.random();
        },

        reject_iaa_tag: function(hashcode, tag_name, cm ,tag_idx) {
            console.log('* reject', hashcode, tag_name, cm, tag_idx);
            this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = null;
            this.force_module_update = Math.random();
        },

        count_tags_in_anns: function(anns) {
            var cnt = 0;
            for (let i = 0; i < anns.length; i++) {
                const ann = anns[i];
                cnt += ann.tags.length;
            }
            return cnt;
        },

        /////////////////////////////////////////////////////////////////
        // Ruleset Related
        /////////////////////////////////////////////////////////////////

        get_ruleset_base_name: function() {
            var fn = this.dtd.name + '-' + this.anns.length;
            return fn;
        },

        download_text_tsv: function() {
            var fn = this.get_ruleset_base_name() + '_text.tsv';
            var txt_tsv = nlp_toolkit.download_text_tsv(
                this.anns,
                this.dtd,
                this.hint_dict,
                fn
            );

            // update the text
            this.export_text = txt_tsv;
        },

        download_text_sent_tsv: function() {
            var fn = this.get_ruleset_base_name() + '_text_sentence.tsv';
            
            // convert the hint dict to a json obj
            var json = [];

            for (let i = 0; i < this.anns.length; i++) {
                const ann = this.anns[i];
                for (let j = 0; j < ann.tags.length; j++) {
                    const tag = ann.tags[j];
                    // now mapping the span to token index
                    if (!tag.hasOwnProperty('spans')) {
                        // this is not an entity tag
                        continue;
                    }
                    // there maybe multiple spans
                    // var spans = tag.spans.split(',');
                    var locs = ann_parser.spans2locs(tag.spans);

                    for (let k = 0; k < locs.length; k++) {
                        // const _span = spans[k];
                        // const span = nlp_toolkit.txt2span(_span);
                        const span = locs[k];
                        if (span[0] == -1 || span[1] == -1) {
                            // which means this tag is just a non-consuming tag
                            // at present, we won't use this kind of tag 
                            continue;
                        }

                        // find the offset in a sentence
                        var loc0 = nlp_toolkit.find_linech(
                            span[0], 
                            ann._sentences
                        );
                        if (loc0 == null) {
                            // something wrong?
                            continue;
                        }
                        // find the location for the right part
                        // var loc1 = this.find_linech(span[1], ann._sentences);
                        var loc1 = Object.assign({}, loc0);
                        loc1.ch += (span[1] - span[0]);

                        // create a new row/item in the output data
                        json.push({
                            concept: tag.tag,
                            text: tag.text,
                            doc_span: span,
                            sen_span: [
                                loc0.ch,
                                loc1.ch
                            ],
                            document: ann._filename,
                            sentence: ann._sentences[loc0.line].text
                        });
                    }
                }
            }

            // then convert the json to csv
            var csv = Papa.unparse(json, {
                delimiter: '\t'
            });

            // update the text
            this.export_text = csv;

            // download this csv
            var blob = new Blob([csv], {type: "text/tsv;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_dataset_iob2: function() {
            var txt_dataset = nlp_toolkit.download_dataset_bio(
                this.anns,
                this.dtd,
                'dataset-' + this.get_ruleset_base_name() + '-BIO.zip'
            );

            // update the text
            this.export_text = txt_dataset;
        },

        download_dataset_bioc: function() {
            var txt_dataset = bioc_parser.download_dataset_bioc(
                this.anns,
                this.dtd,
                'dataset-' + this.get_ruleset_base_name() + '-BioC.xml'
            );

            // update the text
            this.export_text = txt_dataset;
        },

        download_ruleset_medtagger_zip: function() {
            var rulepack = erp_toolkit.download_anns_as_zip(
                this.anns,
                this.dtd,
                'ruleset-medtagger-' + this.get_ruleset_base_name() + '.zip'
            );

            // update the text
            this.export_text = "Please unzip the file and check details";
        },

        download_ruleset_spacy_jsonl: function() {
            var text = spacy_toolkit.download_anns_as_jsonl(
                this.anns,
                this.dtd,
                'ruleset-spacy-' + this.get_ruleset_base_name() + '.jsonl'
            );

            // update the text
            this.export_text = text;
        },

        /////////////////////////////////////////////////////////////////
        // Menu Related
        /////////////////////////////////////////////////////////////////
        get_nc_etags: function() {
            var nc_etags = [];
            // no dtd yet?
            if (this.dtd == null) { return []; }
            // no file selected yet?
            if (this.ann_idx == null) { return []; }
            for (let i = 0; i < this.dtd.etags.length; i++) {
                const etag = this.dtd.etags[i];
                if (etag.is_non_consuming) {
                    nc_etags.push(etag);
                }
            }
            return nc_etags;
        },

        switch_mui: function(section) {
            console.log('* switch to section', section);
            this.section = section;

            if (section == 'annotation') {
                // refresh the code mirror
                this.set_ann_idx(this.ann_idx);
            }

            app_hotpot.resize();
        },

        close_ctxmenu: function() {
            app_hotpot.ctxmenu_sel.hide();
            app_hotpot.ctxmenu_nce.hide();
        },

        close_popmenu: function() {
            app_hotpot.popmenu_tag.hide();
        },

        on_click_tag: function(event, tag_id) {
            // set the clicked tag_id
            this.clicked_tag_id = tag_id;

            var mouseX = event.clientX;
            var mouseY = event.clientY;

            // then show the popmenu
            app_hotpot.show_tag_popmenu(mouseX, mouseY);
        },

        popmenu_del_tag: function() {
            // delete the clicked tag id
            app_hotpot.del_tag(
                this.clicked_tag_id, this.anns[this.ann_idx]
            );

            // hide the menu 
            app_hotpot.popmenu_tag.hide();

            // reset the clicked tag id
            this.clicked_tag_id = null;
        },

        popmenu_start_linking: function(ltag_def) {
            // first, set the working mode
            this.is_linking = true;

            // set the linking tag_def
            this.linking_tag_def = ltag_def;

            // create a ltag
            this.linking_tag = app_hotpot.make_empty_ltag_by_tag_def(ltag_def);

            // then get the linking atts for this ltag
            // this list contains all atts for this ltag
            // and during the linking, we will remove those linked att out
            this.linking_atts = this.get_idref_attlists(ltag_def);

            // let's set the first idref attlist
            // pop the first att from atts
            var att = this.linking_atts[0];
            this.linking_atts.splice(0, 1)
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            // maybe we could show a float panel
            // for showing the current annotation
            console.log('* start linking', ltag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );
        },

        popmenu_set_linking: function(att_idx) {
            // pop the target idx att from atts
            var att = this.linking_atts[att_idx];
            this.linking_atts.splice(att_idx, 1);

            // set current tag to this att
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            console.log('* set linking', this.linking_tag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );

            // final check the left?
            if (this.linking_atts.length == 0) {
                // which means we have tagged all idrefs
                // we could append this linking tag to ann
                var tag_id = ann_parser.get_next_tag_id(
                    this.anns[this.ann_idx],
                    this.linking_tag_def
                );
                this.linking_tag.id = tag_id;
                this.anns[this.ann_idx].tags.push(this.linking_tag);
                // mark _has_saved
                this.anns[this.ann_idx]._has_saved = false;

                // then, we could show this new link in cm
                app_hotpot.cm_draw_ltag(
                    this.linking_tag,
                    this.linking_tag_def,
                    this.anns[this.ann_idx]
                );

                // we could reset linking status
                this.cancel_linking();

            } else {
                // not finished yet?
                // keep working on it
            }
        },

        done_linking: function() {
            // no matter what decision, just done this linking,
            // we could append this linking tag to ann
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                this.linking_tag_def
            );
            this.linking_tag.id = tag_id;
            this.anns[this.ann_idx].tags.push(this.linking_tag);
            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // then, we could show this new link in cm
            app_hotpot.cm_draw_ltag(
                this.linking_tag,
                this.linking_tag_def,
                this.anns[this.ann_idx]
            );

            // we could reset linking status
            this.cancel_linking();
        },

        cancel_linking: function() {
            // so, user doesn't want to continue current linking
            this.is_linking = false;
            this.linking_tag_def = null;
            this.linking_tag = null;
            this.linking_atts = [];
        },

        dragMouseDown: function(event) {
            console.log('* drag start', event);
            event.preventDefault()
            // get the mouse cursor position at startup:
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            document.onmousemove = this.elementDrag
            document.onmouseup = this.closeDragElement
        },
        elementDrag: function (event) {
            event.preventDefault()
            this.pan_working_tag.pos.movementX = this.pan_working_tag.pos.clientX - event.clientX
            this.pan_working_tag.pos.movementY = this.pan_working_tag.pos.clientY - event.clientY
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            // set the element's new position:
            this.$refs.pan_working_tag_box.style.top = (this.$refs.pan_working_tag_box.offsetTop - this.pan_working_tag.pos.movementY) + 'px'
            this.$refs.pan_working_tag_box.style.left = (this.$refs.pan_working_tag_box.offsetLeft - this.pan_working_tag.pos.movementX) + 'px'
        },
        closeDragElement () {
            document.onmouseup = null
            document.onmousemove = null
        },

        /////////////////////////////////////////////////////////////////
        // Other utils
        /////////////////////////////////////////////////////////////////
        make_html_bold_tag_name: function(tag) {
            var html = '<span class="tag-list-row-name-id-prefix">' + tag.id_prefix + '</span>';
            var name = tag.name;
            name = name.replace(tag.id_prefix, '');
            html = html += name;
            return html;
        },

        count_n_tags: function(tag) {
            if (this.ann_idx == null) {
                return '';
            }
            var cnt = 0;
            if (tag == null) {
                return this.anns[this.ann_idx].tags.length;
            }
            for (let i = 0; i < this.anns[this.ann_idx].tags.length; i++) {
                if (this.anns[this.ann_idx].tags[i].tag == tag.name) {
                    cnt += 1;
                }
            }
            return cnt;
        },

        count_all_tags: function(anns) {
            var n = 0;
            for (let i = 0; i < anns.length; i++) {
                for (let j = 0; j < anns[i].tags.length; j++) {
                    n += 1;
                }
            }
            return n;
        },

        count_all_sentences: function(anns) {
            var n = 0;
            for (let i = 0; i < anns.length; i++) {
                const ann = anns[i];
                if (ann.hasOwnProperty('_sentences')) {
                    n += ann._sentences.length;
                }
            }
            return n;
        },

        calc_avg_sentences_per_doc: function(anns) {
            if (anns == null || anns.length == 0) {
                return '-';
            }
            var t = this.count_all_sentences(anns);
            return (t/anns.length).toFixed(2);
        },

        calc_avg_tags_per_doc: function(anns) {
            if (anns == null || anns.length == 0) {
                return '-';
            }
            var t = this.count_all_tags(anns);
            return (t/anns.length).toFixed(2);
        },

        calc_avg_tags_per_def: function(anns, dtd) {
            if (anns == null || anns.length == 0) {
                return '-';
            }
            if (dtd == null || dtd.etags.length == 0) {
                return '-';
            }
            return (anns.length / dtd.etags.length).toFixed(2);
        },

        is_match_filename: function(fn) {
            let p = this.fn_pattern.trim();
            if (p == '') {
                return true;
            }
            if (fn.lastIndexOf(p) >= 0) {
                return true;
            } else {
                return false;
            }
        },

        has_included: function(fn, anns) {
            for (let i = 0; i < anns.length; i++) {
                if (anns[i]._filename == fn) {
                    return true;
                }
            }

            return false;
        },

        has_included_ann_file: function(fn) {
            return this.has_included(fn, this.anns);
        },

        get_new_ann_fn_by_txt_fn: function(txt_fn) {
            var new_fn = txt_fn + '.xml';
            var i = 1;
            while (true) {
                if (this.has_included_ann_file(new_fn)) {
                    new_fn = txt_fn + '_' + i + '.xml';
                    i += 1;
                } else {
                    break;
                }
            }
            return new_fn;
        },

        has_included_txt_ann_file: function(fn) {
            return this.has_included(fn, this.txt_anns);
        },

        has_unsaved_ann_file: function() {
            for (let i = 0; i < this.anns.length; i++) {
                const ann = this.anns[i];
                if (ann._has_saved) {

                } else {
                    return true;
                }
            }
            return false;
        },

        get_tags_by_type: function(ann, dtd, type='etag') {
            var tags = [];
            for (let i = 0; i < ann.tags.length; i++) {
                const tag = ann.tags[i];
                if (dtd.tag_dict[tag.tag].type==type) {
                    tags.push(tag);
                }
            }
            return tags;
        },

        get_tag_by_tag_id: function(tag_id, ann) {
            for (let i = 0; i < ann.tags.length; i++) {
                if (ann.tags[i].id == tag_id) {
                    return ann.tags[i];
                }                
            }
            return null;
        },

        get_tag_def: function(tag_name) {
            if (this.dtd.tag_dict.hasOwnProperty(tag_name)) {
                return this.dtd.tag_dict[tag_name];
            } else {
                return null;
            }
        },

        get_idref_attlist_by_seq: function(ltag_def, seq=0) {
            var cnt = -1;
            for (let i = 0; i < ltag_def.attlists.length; i++) {
                if (ltag_def.attlists[i].vtype == 'idref') {
                    cnt += 1;
                    if (cnt == seq) {
                        // great! we get the attlist we want
                        return ltag_def.attlists[i];
                    }
                }
            }
            return null;
        },

        get_idref_attlists: function(ltag_def) {
            var attlists = [];
            for (let i = 0; i < ltag_def.attlists.length; i++) {
                const att = ltag_def.attlists[i];
                if (att.vtype == 'idref') {
                    attlists.push(att);
                }
            }
            return attlists;
        },

        to_fixed: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null || 
                isNaN(v)) {
                return '0.00';
            }
            return v.toFixed(2);
        },

        to_width: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null ||
                isNaN(v)) {
                return 1;
            }
            return v * 100;
        },

        has_FSA_API: function() {
            return isFSA_API_OK;
        },

        show_help: function(token) {
            if (typeof(token) == 'undefined') {
                // ?
                return;
            }

            // find this token
            if (this.texts.hasOwnProperty(token)) {
                var html_content = '';

                // add the title
                html_content += 
                    "<h4>" + 
                    this.texts[token].title + 
                    "</h4>";
                
                // add the content
                html_content += this.texts[token].html;

                // show the html content
                Metro.infobox.create(html_content);

            } else {
                // ???
            }
        },

        is_etag_doc_level: function(tag) {
            if (tag.spans == '-1~-1') {
                return true;
            }
            return false;
        },
        
        is_etag: function(tag) {
            if (tag.hasOwnProperty('spans')) {
                return true;
            }
            return false;
        }
    },

    // code mirror instance
    codemirror: null,
    // marked texts in code mirror
    marktexts: [],
    // the selected text
    selection: null,

    // the context menu for selection
    ctxmenu_sel: null,

    // the context menu for nc etags
    ctxmenu_nce: null,

    // the popup menu for tag
    popmenu_tag: null,

    init: function() {
        this.vpp = new Vue({
            el: this.vpp_id,
            data: this.vpp_data,
            methods: this.vpp_methods,

            mounted: function() {
                Metro.init();
            },

            updated: function() {
                this.$nextTick(function () {
                    // Code that will run only after the
                    // entire view has been re-rendered
                    if (this.section == 'annotation') {
                        if (this.cm.is_expire) {
                            this.set_ann_idx(this.ann_idx);
                            this.cm.is_expire = false;
                        }
                    }
                });
            }
        });

        // the code mirror
        this.init_codemirror();

        // the global event
        this.bind_events();

        // set the resize
        this.resize();
    },

    init_codemirror: function() {
        // init the code mirror instance
        this.codemirror = CodeMirror(
            document.getElementById('cm_editor'), {
                lineNumbers: true,
                lineWrapping: true,
                readOnly: true,
                // readOnly: 'nocursor',
                // styleActiveLine: true
            }
        );

        this.codemirror.on('contextmenu', function(inst, evt) {
            evt.preventDefault();

            // update the selection texts
            var selection = app_hotpot.cm_get_selection(inst);
            if (selection.sel_txts == '') {
                // if there is/are non-consuming tags
                // which makes it a document-level annotation
                // show the menu here
                if (app_hotpot.vpp.get_nc_etags().length>0) {
                    // show
                    var mouseX = evt.clientX;
                    var mouseY = evt.clientY;
                    app_hotpot.show_nce_ctxmenu(mouseX, mouseY);
                    return;

                } else {
                    // nothing selected and there is no NC etag
                    return;
                }

            }
            // show the menu
            var mouseX = evt.clientX;
            var mouseY = evt.clientY;
            app_hotpot.show_tag_ctxmenu(mouseX, mouseY);
        });
    },

    /**
     * Set the DTD for this annotation project
     * 
     * @param {Object} dtd An object of dtd
     */
    set_dtd: function(dtd) {
        console.log('* set dtd', dtd);
        this.vpp.$data.dtd = dtd;

        // update the color define
        this.update_tag_styles();

        // update the shortcuts
        this.update_tag_shortcuts();

        // update the context menu
        this.update_tag_ctxmenu();

        // update the context menu
        this.update_nce_ctxmenu();

        // update the pop menu
        this.update_tag_popmenu();

        // force update
        this.vpp.$forceUpdate();
    },

    clear_ann_all: function() {
        this.txt_anns = [];
        this.txt_xmls = [];

        this.anns = [];
        this.ann_idx = null;

        this.hint_dict = {};
    },

    reset_vpp: function() {
        this.dtd = null;
        this.clear_ann_all();
        this.clear_iaa_all();
    },

    add_ann: function(ann, is_switch_to_this_ann) {
        // check the schema first
        if (ann.dtd_name != this.vpp.$data.dtd.name) {
            console.log('* skip unmatched ann', ann);
            app_hotpot.msg('Skipped unmatched file ' + ann._filename, 'warning');
            return;
        }

        this.vpp.$data.anns.push(ann);

        // update hint_dict when add new ann file
        this.update_hint_dict_by_anns();

        if (is_switch_to_this_ann || this.vpp.$data.anns.length == 1) {
            this.vpp.$data.ann_idx = this.vpp.$data.anns.length - 1;

            // update the text display
            this.cm_set_ann(
                this.vpp.$data.anns[this.vpp.$data.ann_idx]
            );
    
            // update the marks
            this.cm_update_marks();
        }
        console.log("* added ann", ann);
    },

    /////////////////////////////////////////////////////////////////
    // Events related
    /////////////////////////////////////////////////////////////////

    bind_events: function() {
        // bind drop zone for dtd
        this.bind_dropzone_dtd();

        // bind drop zone for anns
        this.bind_dropzone_ann();

        // bind drop zone for anns
        this.bind_dropzone_txt();

        // bind drop zone for anns
        this.bind_dropzone_iaa();

        // bind global click event
        this.bind_click_event();

        // bind global key event
        this.bind_keypress_event();

        // bind the closing event
        this.bind_unload_event();
    },

    bind_click_event: function() {
        document.getElementById('app_hotpot').addEventListener(
            "click",
            function(event) {
                console.log('* clicked on', event.target);

                // var dom = event.target;
                // var obj = $(dom);

                // // show the menu
                // var mouseX = event.clientX;
                // var mouseY = event.clientY;

                // close the right click menu
                if (app_hotpot.ctxmenu_sel != null) {
                    app_hotpot.ctxmenu_sel.hide();
                }
                if (app_hotpot.ctxmenu_nce != null) {
                    app_hotpot.ctxmenu_nce.hide();
                }
                if (app_hotpot.popmenu_tag != null) {
                    app_hotpot.popmenu_tag.hide();
                }

                // if (obj.hasClass('mark-tag-text')) {
                //     // this is a mark in code mirror
                //     var tag_id = dom.getAttribute('tag_id');

                //     // set the clicked tag_id
                //     app_hotpot.vpp.$data.clicked_tag_id = tag_id;

                //     // show the menu
                //     app_hotpot.show_tag_popmenu(mouseX, mouseY);
                // } else {
                //     // what to do?
                // }
            }
        );
    },

    bind_keypress_event: function() {
        document.addEventListener(
            "keypress",
            function(event) {
                console.log('* pressed on', event);

                // first, check if there is any selection
                app_hotpot.vpp.add_etag_by_shortcut_key(
                    event.key.toLocaleLowerCase()
                );
            }
        );
    },

    bind_unload_event: function() {
        window.addEventListener('beforeunload', function (event) {
            if (app_hotpot.vpp.has_unsaved_ann_file()) {
                event.preventDefault();
                var msg = 'There are unsaved annotation files, are you sure to leave them unsaved?';
                event.returnValue = msg;
                return msg;
            }
        });
    },

    bind_dropzone_dtd: function() {
        let dropzone = document.getElementById("dropzone_dtd");

        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener("drop", function(event) {
            let items = event.dataTransfer.items;
        
            event.preventDefault();
        
            // user should only upload one folder or a file
            if (items.length>1) {
                console.log('* selected more than 1 item!');
                return;
            }

            for (let i=0; i<items.length; i++) {
                let item = items[i].webkitGetAsEntry();
        
                if (item) {
                    // ok, user select a folder ???
                    if (item.isDirectory) {
                        // show something?

                    } else {
                        // should be a dtd file
                        // so item is a fileEntry
                        app_hotpot.parse_dtd_file_entry(item);
                    }
                }

                // just detect one item, folder or zip
                break;
            }

        }, false);
    },

    bind_dropzone_ann: function() {
        let dropzone = document.getElementById("dropzone_ann");

        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener("drop", function(event) {
            // prevent the default download event
            event.preventDefault();
            
            let items = event.dataTransfer.items;
            for (let i=0; i<items.length; i++) {
                if (isFSA_API_OK) {
                    // get this item as a FileSystemHandle Object
                    // this could be used for saving the content back
                    // let item = items[i].webkitGetAsEntry();
                    let item = items[i].getAsFileSystemHandle();

                    // read this handle
                    item.then(function(fh) {
                        if (fh.kind == 'file') {
                            // if drop a txt!
                            if (app_hotpot.is_file_ext(fh.name, 'txt')) {
                                // create a new file name
                                var new_fn = app_hotpot.vpp.get_new_ann_fn_by_txt_fn(fh.name);

                                // create a empty ann
                                var p_txt_ann = fs_read_txt_file_handle(
                                    fh, 
                                    app_hotpot.vpp.$data.dtd,
                                    true
                                );

                                // load this ann
                                p_txt_ann.then((function(new_fn){
                                    return function(txt_ann) {
                                        // modify the txt_ann _fh
                                        // we couldn't save to an txt
                                        txt_ann._fh = null;

                                        // update the _filename
                                        txt_ann._filename = new_fn;

                                        // show some message
                                        app_hotpot.msg("Created a new annotation file " + new_fn);

                                        // add this ann
                                        app_hotpot.add_ann(txt_ann);
                                    }
                                })(new_fn));

                                return;
                            }

                            // show something or 
                            // check if this file name exists
                            if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
                                // exists? skip this file
                                app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
                                return;
                            }

                            // should be a ann txt/xml file
                            app_hotpot.parse_ann_file_fh(
                                fh,
                                app_hotpot.vpp.$data.dtd
                            );

                        } else {
                            // so item is a directory?
                        }
                    });
                } else {
                    // just load the file 
                    let item = items[i].webkitGetAsEntry();
                    console.log(item);
                    if (item) {
                        // ok, user select a folder ???
                        if (item.isDirectory) {
                            // show something?
    
                        } else {
                            // so item is a fileEntry
                            app_hotpot.parse_ann_file_entry(item);
                        }
                    }
                }
                
                
            }

        }, false);

    },

    bind_dropzone_txt: function() {
        let dropzone = document.getElementById("dropzone_txt");

        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener("drop", function(event) {
            let items = event.dataTransfer.items;
            // stop the download event
            event.preventDefault();

            for (let i=0; i<items.length; i++) {
                // let item = items[i].webkitGetAsEntry();
                let item = items[i].getAsFileSystemHandle();
        
                item.then(function(fh) {
                    if (fh.kind == 'file') {
                        // check exists
                        if (app_hotpot.vpp.has_included_txt_ann_file(fh.name)) {
                            // exists? skip this file
                            return;
                        }

                        // read the file
                        var p_txt_ann = fs_read_txt_file_handle(
                            fh,
                            app_hotpot.vpp.$data.dtd
                        );
                        p_txt_ann.then(function(txt_ann) {
                            app_hotpot.vpp.add_txt(txt_ann);
                        });
                        
                    } else {
                        // what to do with a directory
                    }
                })
                .catch(function(error) {
                    console.log('* error when drop txt', error);
                });
            }

        }, false);
    },

    bind_dropzone_iaa: function() {
        let dropzones = document.getElementsByClassName("dropzone-iaa");

        for (let i = 0; i < dropzones.length; i++) {
            var dropzone = dropzones[i];
            var iaa_id = parseInt(dropzone.getAttribute('iaa_id'));

            dropzone.addEventListener("dragover", function(event) {
                event.preventDefault();
            }, false);

            dropzone.addEventListener("drop", (function(iaa_id) {
                return function(event) {
                    // stop the download event
                    event.preventDefault();
                    // first, we need to which dropzone triggers event
    
                    console.log('* drop something on iaa ' + iaa_id);
                    // return;
        
                    let items = event.dataTransfer.items;
        
                    for (let i=0; i<items.length; i++) {
                        // check ext first
                        let fileEntry = items[i].webkitGetAsEntry();
                        if (!app_hotpot.is_file_ext(fileEntry.name, 'xml')) {
                            app_hotpot.msg('Skipped non-XML file ' + fileEntry.name, 'warning');
                            continue;
                        }
                        // we have two ways of loading data
                        // first using the basic entry
                        // second using the fs handle
                        // it depends the browser API
                        if (isFSA_API_OK) {
                            // just load in this way
                            let item = items[i].getAsFileSystemHandle();
                            item.then((function(iaa_id) {
                                return function(fh) {
                                    if (fh.kind == 'file') {
                                        // check exists
                                        if (app_hotpot.vpp.has_included(
                                            fh.name, 
                                            app_hotpot.vpp.$data.iaa_ann_list[iaa_id].anns)) {
                                            // exists? skip this file
                                            return;
                                        }
                
                                        // read the file
                                        var p_ann = fs_read_ann_file_handle(
                                            fh,
                                            app_hotpot.vpp.$data.dtd
                                        );
                                        p_ann.then((function(iaa_id) {
                                            return function(ann) {
                                                app_hotpot.vpp.add_iaa_ann(ann, iaa_id);
                                            }
                                        })(iaa_id)).catch(function(error) {
                                            app_hotpot.msg("Couldn't read ann, " + error.name);
                                            console.error(error);
                                        });
                                        
                                    } else {
                                        // what to do with a directory
                                    }
                                }
                            })(iaa_id))
                            .catch(function(error) {
                                console.log('* error when drop txt', error);
                            });
                        } else {
                            // just load the file 
                            let item = items[i].webkitGetAsEntry();
                            if (item) {
                                // ok, user select a folder ???
                                if (item.isDirectory) {
                                    // show something?
            
                                } else {
                                    // should be a dtd file
                                    // so item is a fileEntry
                                    var new_fn = item.name;
                                    app_hotpot.read_file_async(item, (function(new_fn, iaa_id){
                                        return function(evt) {
                                            var xml = evt.target.result;
                            
                                            // try to parse this xml file
                                            var ann = ann_parser.xml2ann(
                                                xml, 
                                                app_hotpot.vpp.$data.dtd
                                            );
                        
                                            // post processing
                                            // we don't have fh due to using fileEntry
                                            ann._fh = null;
                                            ann._filename = new_fn;
                                            ann._has_saved = true;
                                            var result = nlp_toolkit.sent_tokenize(ann.text);
                                            ann._sentences = result.sentences;
                                            ann._sentences_text = result.sentences_text;
                                            
                                            // ok, add this the dtd for annotator
                                            app_hotpot.vpp.add_iaa_ann(ann, iaa_id);
                                        }
                                    })(new_fn, iaa_id));
                                }
                            }
                        }


                        
                    }
        
                }
            })(iaa_id), false);
        }
        
    },

    resize: function() {
        var h = $(window).height();
        $('.main-ui').css('height', h - 145);

        // due the svg issue, when resizing the window,
        // redraw all ltag marks
        this.cm_clear_ltag_marks();
        this.cm_update_ltag_marks();
    },

    parse_dtd_file_entry: function(fileEntry) {
        app_hotpot.read_file_async(fileEntry, function(evt) {
            var text = evt.target.result;
            // console.log('* read dtd', text);

            // try to parse this dtd file
            var dtd = dtd_parser.parse(text);
            
            // ok, set the dtd for annotator
            app_hotpot.set_dtd(dtd);
        });
    },

    parse_ann_file_entry: function(fileEntry) {
        // first, decide type
        if (app_hotpot.is_file_ext(fileEntry.name, 'txt')) {
            // so, just read this file and get the content
            // to create new file name
            var new_fn = app_hotpot.vpp.get_new_ann_fn_by_txt_fn(fileEntry.name);

            app_hotpot.read_file_async(fileEntry, (function(new_fn){
                return function(evt) {
                    var text = evt.target.result;
    
                    // try to parse this txt file
                    var ann = ann_parser.txt2ann(
                        text, 
                        app_hotpot.vpp.$data.dtd
                    );

                    // post processing
                    ann._fh = null;
                    ann._filename = new_fn;
                    ann._has_saved = true;
                    var result = nlp_toolkit.sent_tokenize(ann.text);
                    ann._sentences = result.sentences;
                    ann._sentences_text = result.sentences_text;
                    
                    // ok, add this the dtd for annotator
                    app_hotpot.add_ann(ann);
                }
            })(new_fn));

        } else if (app_hotpot.is_file_ext(fileEntry.name, 'xml')) {
            // ok, this is an xml file, usually it's what we want
            // check existance first
            if (app_hotpot.vpp.has_included_ann_file(fileEntry.name)) {
                // exists? skip this file
                app_hotpot.msg('Skipped same name or duplicated ' + fileEntry.name);
                return;
            }

            // then create 
            var new_fn = fileEntry.name;
            app_hotpot.read_file_async(fileEntry, (function(new_fn){
                return function(evt) {
                    var xml = evt.target.result;
    
                    // try to parse this xml file
                    var ann = ann_parser.xml2ann(
                        xml, 
                        app_hotpot.vpp.$data.dtd
                    );

                    // post processing
                    // we don't have fh due to using fileEntry
                    ann._fh = null;
                    ann._filename = new_fn;
                    ann._has_saved = true;
                    var result = nlp_toolkit.sent_tokenize(ann.text);
                    ann._sentences = result.sentences;
                    ann._sentences_text = result.sentences_text;
                    
                    // ok, add this the dtd for annotator
                    app_hotpot.add_ann(ann);
                }
            })(new_fn));
            
        } else {
            // what???
            app_hotpot.msg('Skipped unknown format file ' + fileEntry.name);
            return;
        }
    },

    read_file_async: function(fileEntry, callback) {
        fileEntry.file(function(file) {
            let reader = new FileReader();
            reader.onload = callback;
            reader.readAsText(file)
        });
    },

    parse_ann_file_fh: function(fh, dtd) {
        // get the ann file
        var p_ann = fs_read_ann_file_handle(fh, dtd);
        p_ann.then(function(ann) {
            app_hotpot.add_ann(ann);
        }).catch(
            function(fh){return function(error) {
                app_hotpot.msg(
                    "Couldn't read annotation in ["+ fh.name +"]. <br>" + 
                    error.name + 
                    ": " + error.message + "",
                    'warning');
                console.error(error);
            }}(fh)
        );
    },

    /////////////////////////////////////////////////////////////////
    // DTD update related
    /////////////////////////////////////////////////////////////////
    // the default colors are from
    // https://colorbrewer2.org/#type=qualitative&scheme=Set3&n=12
    app_colors: [
        '#a6cee3',
        '#1f78b4',
        '#b2df8a',
        '#33a02c',
        '#fb9a99',
        '#e31a1c',
        '#fdbf6f',
        '#ff7f00',
        '#cab2d6',
        '#9654dc',
        '#d0aa3d',
        '#b15928',
        '#8dd3c7',
        '#9c9c64',
        '#bebada',
        '#fb8072',
        '#80b1d3',
        '#fdb462',
        '#b3de69',
        '#fccde5',
        '#d9d9d9',
        '#bc80bd',
        '#ccebc5',
        '#ffed6f',
    ],

    update_tag_styles: function() {
        var elem_style = document.getElementById ("dtd_style");
        var style = elem_style.sheet ? elem_style.sheet : elem_style.styleSheet;

        // clear all rules first
        while(style.cssRules.length>0) {
            style.deleteRule(0);
        }

        // check each tag
        var i = 0;
        for (const tag_name in this.vpp.$data.dtd.tag_dict) {
            if (Object.hasOwnProperty.call(this.vpp.$data.dtd.tag_dict, tag_name)) {
                const tag = this.vpp.$data.dtd.tag_dict[tag_name];
                
                // add a new style for this tag
                var color = 'white';
                if ( i < this.app_colors.length ) {
                    // use default color
                    color = this.app_colors[i];
                } else {
                    // we don't have enough colors now
                    // just use a random color
                    color = '#' + Math.floor(Math.random()*16777215).toString(16);
                }
                
                // add this tag as the given color
                // set this color for related css rules
                style.insertRule(
                    ".mark-tag-" + tag_name + " { background-color: " + color + "; }",
                    0
                );
                style.insertRule(
                    ".border-tag-" + tag_name + " { border-color: " + color + " !important; }",
                    0
                );
                style.insertRule(
                    ".fg-tag-" + tag_name + " { color: " + color + " !important; }",
                    0
                );

                // add this for svg
                style.insertRule(
                    ".svgmark-tag-" + tag_name + " { fill: " + color + "; }",
                    0
                );

                // add this tag as the hint
                style.insertRule(
                    ".mark-hint-" + tag_name + ":hover { background-color: " + color + "; }",
                    0
                );
                
                i += 1;
            }
        }
    },

    app_shortcuts: [
        '1',
        '2',
        '3',
        '4',
        '5',
        'q',
        'w',
        'e',
        'r',
        't',
        'a',
        's',
        'd',
        'f',
        'g',
        'z',
        'x',
        'c',
        'v',
        'b'
    ],

    update_tag_shortcuts: function() {
        for (let i = 0; i < this.vpp.dtd.etags.length; i++) {
            if (i < this.app_shortcuts.length) {
                // assign a key to this etag
                this.vpp.dtd.etags[i].shortcut = this.app_shortcuts[i];
                
                // now, we need to update the tag_dict
            }
        }
    },

    show_tag_ctxmenu: function(x, y) {
        console.log("* show tag ctx menu on ", x, y);
        var w = this.ctxmenu_sel.width();
        this.ctxmenu_sel.css('left', (x - 10 - w) + 'px')
            .css('top', (y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_nce_ctxmenu: function(x, y) {
        console.log("* show nce ctx menu on ", x, y);
        var w = this.ctxmenu_nce.width();
        this.ctxmenu_nce.css('left', (x - 10 - w) + 'px')
            .css('top', (y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_tag_popmenu: function(x, y) {
        console.log("* show tag pop menu on ", x, y);
        var w = this.popmenu_tag.width();
        this.popmenu_tag.css('left', (x - 10 - w) + 'px')
            .css('top', (y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    update_tag_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_sel = $('#ctxmenu_sel').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_nce_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_nce = $('#ctxmenu_nce').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_tag_popmenu: function() {
        // update the pop menu
        this.popmenu_tag = $('#popmenu_tag').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    del_tag: function(tag_id, ann, is_check_ltag=true, is_update_marks=true) {
        if (typeof(ann) == 'undefined') {
            ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        }

        if (is_check_ltag) {
            // when deleting etag, need to check if there is linked ltag
            var linked_ltags = ann_parser.get_linked_ltags(tag_id, ann);

            if (linked_ltags.length == 0) {
                // great! no links!
                // just keep going
            } else {
                // ok, are you sure?
                // let's make a long message
                var msg = ['There are ' + linked_ltags.length + ' link tag(s) related to [' + tag_id + ']:\n'];
                for (let i = 0; i < linked_ltags.length; i++) {
                    const ltag = linked_ltags[i];
                    msg.push('- ' + ltag.id + ' (' + ltag.tag + ') ' + '\n');
                }
                msg.push('\nDeleting [' + tag_id + '] will also delete the above link tag(s).\n');
                msg.push('Are you sure to continue?');
                msg = msg.join('');

                var ret = this.confirm(msg);

                if (ret) {
                    // ok, let's delete the links first
                    for (let i = 0; i < linked_ltags.length; i++) {
                        const ltag = linked_ltags[i];
                        // save some time when running this inner deletion
                        this.del_tag(ltag.id, ann, false, false);
                    }
                } else {
                    // nice choice! keep them all!
                    return;
                }
            }
        }

        // just remove this tag now
        this.vpp.$data.anns[this.vpp.$data.ann_idx] = this.remove_tag_from_ann(tag_id, ann);

        // mark _has_saved
        this.vpp.$data.anns[this.vpp.$data.ann_idx]._has_saved = false;
        console.log('* deleted tag ' + tag_id);

        // update the marks
        if (is_update_marks) {
            app_hotpot.cm_update_marks();
        }

        // toast
        app_hotpot.toast(
            'Successfully deleted tag ' + tag_id,
            ''
        );
    },

    update_hint_dict_by_anns: function() {
        if (this.vpp.$data.anns.length == 0) {
            this.vpp.hint_dict = {};
            return;
        }
        var hint_dict = ann_parser.anns2hint_dict(
            this.vpp.$data.dtd, 
            this.vpp.$data.anns
        );
        this.vpp.hint_dict = hint_dict;
        console.log('* updated hint_dict by anns', this.vpp.hint_dict);
    },

    update_hint_dict_by_tag: function(ann, tag) {
        this.vpp.hint_dict = ann_parser.add_tag_to_hint_dict(
            ann, tag, this.vpp.hint_dict
        );
        console.log('* updated hint_dict by a tag', this.vpp.hint_dict, tag);
    },

    /////////////////////////////////////////////////////////////////
    // Tag Related
    /////////////////////////////////////////////////////////////////
    make_etag: function(basic_tag, tag_def, ann) {
        // first, add the tag name
        basic_tag['tag'] = tag_def.name;

        // find the id number
        // var n = 0;
        // for (let i = 0; i < ann.tags.length; i++) {
        //     if (ann.tags[i].tag == tag_def.name) {
        //         // get the id number of this tag
        //         var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
        //         if (_id >= n) {
        //             n = _id + 1;
        //         }
        //     }
        // }
        // basic_tag['id'] = tag_def.id_prefix + n;
        basic_tag['id'] = ann_parser.get_next_tag_id(ann, tag_def);

        // add other attr
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
            } else {
                // set the default value
                basic_tag[att.name] = att.default_value;
            }
        }

        return basic_tag;
    },

    make_ltag: function() {

    },

    make_empty_etag_by_tag_def: function(tag_def) {
        var etag = {
            id: '',
            tag: tag_def.name,
            spans: '',
            text: ''
        };

        // then add other attr
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
                etag.spans = dtd_parser.NON_CONSUMING_SPANS;
            } else {
                // set the default value
                etag[att.name] = att.default_value;
            }
        }

        return etag;
    },

    make_empty_ltag_by_tag_def: function(tag_def) {
        var ltag = {
            id: '',
            tag: tag_def.name
        };

        // then add other attr
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
            } else {
                // set the default value
                ltag[att.name] = att.default_value;
            }
        }

        return ltag;
    },
    
    remove_tag_from_ann: function(tag_id, ann) {
        var tag_idx = -1;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                tag_idx = i;
                break;
            }            
        }

        // delete the found tag idx
        if (tag_idx == -1) {
            // ???
        } else {
            ann.tags.splice(tag_idx, 1); 
        }

        return ann;
    },

    /////////////////////////////////////////////////////////////////
    // Code Mirror Related
    /////////////////////////////////////////////////////////////////
    cm_set_ann: function(ann) {
        // make sure all clear
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_ltag_marks();

        // first, if ann is null, just remove everything in the editor
        if (ann == null) {
            this.codemirror.setValue('');
            return;
        }

        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            this.codemirror.setValue(
                ann.text
            );

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            this.codemirror.setValue(
                ann._sentences_text
            );
        } else {
            this.codemirror.setValue('');
        }
    },

    cm_get_selection: function(inst) {
        if (typeof(inst) == 'undefined') {
            inst = this.codemirror;
        }
        // update the selection
        var selection = {
            sel_txts: inst.getSelections(),
            sel_locs: inst.listSelections()
        };
        this.selection = selection;
        console.log("* found selection:", app_hotpot.selection);
        return selection;
    },

    cm_clear_selection: function(to_anchor=true) {
        var new_anchor = null;
        if (to_anchor) {
            new_anchor = this.selection.sel_locs[0].anchor;
        } else {
            new_anchor = this.selection.sel_locs[0].head;
        }
        this.codemirror.setSelection(new_anchor);
    },

    cm_make_basic_tag_from_selection: function() {
        var locs = [];
        var txts = [];

        // usually there is only one tag
        for (let i = 0; i < app_hotpot.selection.sel_locs.length; i++) {
            var sel_loc = app_hotpot.selection.sel_locs[i];
            var sel_txt = app_hotpot.selection.sel_txts[i];
            locs.push(
                app_hotpot.cm_range2spans(
                    sel_loc, 
                    this.vpp.$data.anns[this.vpp.$data.ann_idx]
                )
            );
            txts.push(sel_txt);
        }
        
        // now push new ann tag
        var tag = {
            'spans': locs.join(','),
            'text': txts.join(' ... ')
        };

        return tag;
    },

    cm_update_marks: function() {
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_ltag_marks();

        // update the hint marks
        this.cm_update_hint_marks();

        // update the tag marks
        this.cm_update_tag_marks();

        // force update UI, well ... maybe not work
        this.vpp.$forceUpdate();
    },

    cm_clear_etag_marks: function() {
        var marks = this.codemirror.getAllMarks();
        for (let i = marks.length - 1; i >= 0; i--) {
            marks[i].clear();
        }
    },

    cm_clear_ltag_marks: function() {
        // first, check if there is a layer for the plots
        if ($('#cm_svg_plots').length == 0) {
            $('.CodeMirror-sizer').prepend(`
            <div class="CodeMirror-plots">
            <svg id="cm_svg_plots">
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            </svg>
            </div>
        `);
        } else {
            $('#cm_svg_plots').html(`
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            `);
        }
    },

    cm_update_hint_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        if (!this.vpp.$data.cm.enabled_hints ||
            this.vpp.$data.cm.hint_mode == 'off') {
            // nothing to do when turn off hint
            return;
        }

        if (this.vpp.$data.dtd == null) {
            // nothing to do if no dtd given
            return;
        }

        // find markable hints for this ann
        var hints = ann_parser.search_hints_in_ann(
            this.vpp.hint_dict,
            this.vpp.$data.anns[this.vpp.$data.ann_idx]
        );
        console.log('* found hints', hints);

        // bind the hints to vpp
        this.vpp.$data.hints = hints;

        for (let i = 0; i < hints.length; i++) {
            const hint = hints[i];
            this.cm_mark_hint_in_text(
                hint,
                this.vpp.$data.anns[this.vpp.$data.ann_idx]
            );
        }
    },

    cm_update_tag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        // to ensure the link tag could be draw correctly,
        // draw the etags first
        this.cm_update_etag_marks();

        // since all etags have been rendered,
        // it's safe to render the link tags
        this.cm_update_ltag_marks();
    },

    cm_update_etag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }
        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'etag') {
                this.cm_mark_ann_etag_in_text(tag, tag_def, working_ann);
            }
        }
    },

    cm_update_ltag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }
        if (this.vpp.$data.cm.enabled_links) {
            // ok! show links
        } else {
            // well, if user doesn't want to show links,
            // it's ok
            return;
        }
        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'ltag') {
                this.cm_mark_ann_ltag_in_text(tag, tag_def, working_ann);
            }
        }
    },

    /**
     * Mark the hint in the code mirror
     * @param {object} hint it contains the range for rendering
     */
    cm_mark_hint_in_text: function(hint, ann) {
        var range = this.cm_spans2range(hint.spans, ann);
        // console.log("* marking hint", hint, 'on', range);
        
        if (this.vpp.$data.cm.mark_mode == 'node') {
            var hint_tag_id_prefix = dtd_parser.get_id_prefix(
                hint.tag, 
                this.vpp.$data.dtd
            );
            var markHTML = [
                '<span class="mark-hint mark-hint-'+hint.tag+'" id="mark-id-'+hint.id+'" onclick="app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')" title="Click to add this to tags">',
                '<span class="mark-hint-info mark-tag-'+hint.tag+'">',
                    hint_tag_id_prefix,
                '</span>',
                '<span class="mark-hint-text" hint_id="'+hint.id+'">',
                    hint.text,
                '</span>',
                '<span class="mark-hint-tooltip">',
                    hint.tag,
                '</span>',
                '</span>'
            ].join('');

            // convert this HTML to DOMElement
            var placeholder = document.createElement('div');
            placeholder.innerHTML = markHTML;
            var markNode = placeholder.firstElementChild;

            this.codemirror.markText(
                range.anchor,
                range.head,
                {
                    className: 'mark-hint mark-hint-' + hint.tag,
                    replacedWith: markNode,
                    attributes: {
                        hint_id: hint.id
                    }
                }
            );
        } else if (this.vpp.$data.cm.mark_mode == 'span') {
            this.codemirror.markText(
                range.anchor,
                range.head,
                {
                    className: 'mark-hint mark-hint-' + hint.tag,
                    attributes: {
                        hint_id: hint.id,
                        onclick: 'app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')'
                    }
                }
            );
        }
    },

    cm_mark_ann_tag_in_text: function(tag, tag_def, ann) {
        if (tag_def.type == 'etag') {
            this.cm_mark_ann_etag_in_text(tag, tag_def, ann);
        } else {
            this.cm_mark_ann_ltag_in_text(tag, tag_def, ann);
        }
    },

    cm_mark_ann_ltag_in_text: function(tag, tag_def, ann) {
        this.cm_draw_ltag(tag, tag_def, ann);
    },

    cm_mark_ann_etag_in_text: function(tag, tag_def, ann) {
        var raw_spans = tag['spans'];
        if (raw_spans == '' || raw_spans == null) { 
            return [-1]; 
        }

        // the spans may contains multiple parts
        // split them first
        var spans_arr = raw_spans.split(',');
        var text_arr = tag.text.split('...');
        
        for (let i = 0; i < spans_arr.length; i++) {
            const spans = spans_arr[i];
            const spans_text = text_arr[i];
            var range = this.cm_spans2range(spans, ann);

            if (this.vpp.$data.cm.mark_mode == 'node') {
                // the second step is to enhance the mark tag with more info
                var markHTML = [
                    '<span class="mark-tag mark-tag-'+tag.tag+'" id="mark-etag-id-'+tag.id+'">',
                    '<span onclick="app_hotpot.vpp.on_click_tag(event, \''+tag.id+'\')">',
                    '<span class="mark-tag-info">',
                        '<span class="mark-tag-info-inline fg-tag-'+tag.tag+'">',
                        tag.id,
                        '</span>',
                    '</span>',
                    '<span class="mark-tag-text" tag_id="'+tag.id+'">',
                        spans_text,
                    '</span>',
                    '</span>',
                    '<span class="mark-tag-info-offset" title="Delete tag '+tag.id+'" onclick="app_hotpot.del_tag(\''+tag.id+'\');">',
                        '<i class="fa fa-times-circle"></i>',
                    '</span>',
                    '</span>'
                ].join('');

                // convert this HTML to DOMElement
                var placeholder = document.createElement('div');
                placeholder.innerHTML = markHTML;
                var markNode = placeholder.firstElementChild;

                // add mark to text
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-tag mark-tag-' + tag.tag,
                        replacedWith: markNode,
                        attributes: {
                            tag_id: tag.id,
                            onclick: ''
                        }
                    }
                );

            } else if (this.vpp.$data.cm.mark_mode == 'span') {
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-tag mark-tag-' + tag.tag,
                        attributes: {
                            id: 'mark-etag-id-' + tag.id,
                            tag_id: tag.id,
                            onclick: 'app_hotpot.vpp.on_click_tag(event, \''+tag.id+'\')'
                        }
                    }
                );
            }
        }

    },

    cm_jump2tag: function(tag, ann) {
        // first, get the anchor location
        var range = this.cm_spans2range(
            tag.spans, ann
        );

        // set the anchor
        this.codemirror.doc.setCursor(
            range.anchor
        );
    },

    cm_spans2range: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_spans2range(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_spans2range(spans, ann);

        } else {
            return this.cm_doc_spans2range(spans, ann);
        }
    },

    cm_range2spans: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_range2spans(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_range2spans(spans, ann);

        } else {
            return this.cm_doc_range2spans(spans, ann);
        }
    },

    cm_sen_range2spans: function(sel_loc, ann) {
        var span0 = 0;

        // first, get the start span of this line
        var line_span0 = ann._sentences[
            sel_loc.anchor.line
        ].spans.start;
        var line_span1 = ann._sentences[
            sel_loc.head.line
        ].spans.start;

        // then move to the span of this line
        span0 = line_span0 + sel_loc.anchor.ch;
        span1 = line_span1 + sel_loc.head.ch;

        // the selection maybe from different direction
        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_sen_spans2range: function(spans, ann) {
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // find the line number of span0
        var anchor = nlp_toolkit.find_linech(span_pos_0, ann._sentences);
        var head = nlp_toolkit.find_linech(span_pos_1, ann._sentences);

        return {
            anchor: anchor,
            head: head
        }
    },

    cm_doc_range2spans: function(sel_loc, ann) {
        var full_text = ann.text;
        // console.log('* calc doc range2spans: ');
        // console.log(sel_loc);
        var lines = full_text.split('\n');
        var span0 = 0;
        for (let i = 0; i < sel_loc.anchor.line; i++) {
            span0 += lines[i].length + 1;
        }
        span0 += sel_loc.anchor.ch;
        var span1 = 0;
        for (let i = 0; i < sel_loc.head.line; i++) {
            span1 += lines[i].length + 1;
        }
        span1 += sel_loc.head.ch;
        // console.log('* span0: ' + span0 + ', span1: ' + span1);

        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_doc_spans2range: function(spans, ann) {
        var full_text = ann.text;

        // console.log('* calc doc spans2range: ');
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // calculate the line number
        var ln0 = full_text.substring(0, span_pos_0).split('\n').length - 1;
        var ln1 = full_text.substring(0, span_pos_1).split('\n').length - 1;

        // calculate the char location
        var ch0 = span_pos_0;
        for (let i = 1; i < span_pos_0; i++) {
            if (full_text[span_pos_0 - i] == '\n') {
                ch0 = i - 1;
                break;
            }
        }

        // TODO fix the potential cross lines bug
        var ch1 = ch0 + (span_pos_1 - span_pos_0);

        // return [ [ln0, ch0], [ln1, ch1] ];
        return {
            anchor: {line: ln0, ch: ch0},
            head:   {line: ln1, ch: ch1}
        }
    },

    cm_spans2coords: function(spans, ann) {
        var range = this.cm_spans2range(spans, ann);

        var coords_l = this.codemirror.charCoords(
            // { line: range[0][0], ch: range[0][1] },
            range.anchor,
            'local'
        );
        var coords_r = this.codemirror.charCoords(
            // { line: range[1][0], ch: range[1][1] },
            range.head,
            'local'
        );

        return { 
            l: coords_l, 
            r: coords_r 
        };
    },

    scroll_annlist_to_bottom: function() {
        var objDiv = document.getElementById("mui_annlist");
        objDiv.scrollTop = objDiv.scrollHeight;
    },

    cm_draw_ltag: function(ltag, ltag_def, ann) {
        // for showing the ltag, we need:
        // 1. the atts for accessing the ltag
        // 2. the values of att_a and att_b, which are tag_id for etag
        // 3. get the tag, then call cm_draw_polyline

        // so, get all attlists
        var atts = this.vpp.get_idref_attlists(ltag_def);

        // next, get the values fron this ltag
        var etags = [];
        for (let i = 0; i < atts.length; i++) {
            var att = atts[i];
            var etag_id = ltag[att.name];

            if (typeof(etag_id) == 'undefined' || 
                etag_id == null || 
                etag_id == '') {
                // this att is just empty
                continue;
            }

            // check this etag
            var etag = this.vpp.get_tag_by_tag_id(etag_id, ann);
            if (etag == null) { 
                continue; 
            }
            if (etag.spans == dtd_parser.NON_CONSUMING_SPANS) {
                continue;
            }

            // ok, save this etag for later use
            etags.push(etag);
        }
        // then, check if there are more than two etags
        console.log('* found ' + etags.length + ' etags available for this link');

        // first, draw dots
        for (let i = 0; i < etags.length; i++) {
            const etag = etags[i];
            this.cm_draw_linkdot(ltag, etag, ann);
        }

        if (!this.vpp.$data.cm.enabled_link_complex) {
            return;
        }

        // second, draw polyline
        if (etags.length < 2) {
            // which means not enough etag for drawing line
            return;
        }
        var tag_a = etags[0];
        var tag_b = etags[1];

        console.log(
            '* try to draw line ['+ltag.id+'] between', 
            '['+tag_a.id+']-', 
            '['+tag_a.id+']'
        );

        // last, draw!
        this.cm_draw_polyline(
            ltag, tag_a, tag_b, ann
        );
    },

    // cm_draw_ltag_first_two: function(ltag, ltag_def, ann) {
    //     // for showing the polyline, we need:
    //     // 1. the att_a and att_b for accessing the ltag
    //     // 2. the values of att_a and att_b, which are tag_id for etag
    //     // 3. get the tag, then call cm_draw_polyline

    //     // so, get the att_a and att_b first
    //     var att_a = this.vpp.get_idref_attlist_by_seq(ltag_def, 0);
    //     var att_b = this.vpp.get_idref_attlist_by_seq(ltag_def, 1);

    //     // next, get the values
    //     var etag_a_id = ltag[att_a.name];
    //     var etag_b_id = ltag[att_b.name];
    //     // console.log(
    //     //     '* try to draw line ['+ltag.id+'] between', 
    //     //     att_a.name, '['+etag_a_id+']-', 
    //     //     att_b.name, '['+etag_b_id+']'
    //     // );

    //     // if the value is null or empty, just skip
    //     if (etag_a_id == null || etag_a_id == '') { return; }
    //     if (etag_b_id == null || etag_b_id == '') { return; }

    //     // convert the tag_id to tag
    //     var tag_a = this.vpp.get_tag_by_tag_id(etag_a_id, ann);
    //     var tag_b = this.vpp.get_tag_by_tag_id(etag_b_id, ann);

    //     // if the tag is not available, just skip
    //     if (tag_a == null || tag_b == null) { return; }

    //     // if one of the tags is non-consuming tag, just skip
    //     if (tag_a.spans == dtd_parser.NON_CONSUMING_SPANS ||
    //         tag_b.spans == dtd_parser.NON_CONSUMING_SPANS) {
    //         return;
    //     }

    //     // last, draw!
    //     this.cm_draw_polyline(
    //         ltag, tag_a, tag_b, ann
    //     );
    // },

    cm_draw_linkdot: function(ltag, tag, ann) {
        // then get the coords
        var coords = this.cm_spans2coords(tag.spans, ann);

        var x = coords.l.left;
        var y = coords.l.top + 2;

        // find existing linkdot on this tag if there is
        var linkdots = $('#cm_svg_plots .tag-linkdot-' + tag.id);

        // add offset to x
        for (let i = 0; i < linkdots.length; i++) {
            const elem = linkdots[i];
            var shape = this.get_elem_shape(elem);
            x += shape.width + 1;
        }

        // make a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-dot-id-' + ltag.id + '-' + tag.id);
        svg_text.setAttribute('text-anchor', 'left');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', x);
        svg_text.setAttribute('y', y);
        svg_text.setAttribute('class', "tag-linkdot border-tag-" + tag.tag + " tag-linkdot-" + tag.id);

        // put the text
        var text_node_content = " ";
        if (this.vpp.$data.cm.enabled_link_name) {
            text_node_content = " " + ltag.id;
        }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // this.make_svg_text_bg(svg_text, 'svgmark-tag-' + ltag.tag);
    },

    cm_draw_polyline: function(ltag, tag_a, tag_b, ann) {
        // then get the coords of both tags
        var coords_a = this.cm_spans2coords(tag_a.spans, ann);
        var coords_b = this.cm_spans2coords(tag_b.spans, ann);

        // the setting for the polyline
        var delta_height = 2;
        var delta_width = 0;

        // get the upper coords, which is the lower one
        var upper_top = coords_a.l.top < coords_b.l.top ? 
            coords_a.l.top : coords_b.l.top;
        upper_top = upper_top - delta_height;

        // get the sign for relative location
        var sign = coords_b.l.left - coords_a.l.left > 0 ? 1 : -1;

        // then calc the points for the polyline
        var xys = [
            // point, start
            [
                (coords_a.l.left + coords_a.r.left)/2,
                (coords_a.l.top + 4)
            ],
            // point joint 1
            [
                (coords_a.l.left + coords_a.r.left)/2 + sign * delta_width,
                upper_top
            ],
            // point, joint 2
            [
                ((coords_b.l.left + coords_b.r.left)/2 - sign * delta_width),
                upper_top
            ],
            // point, end
            [
                (coords_b.l.left + coords_b.r.left)/2,
                (coords_b.l.top + 3)
            ]
        ];

        // put all points togather
        var points = [];
        for (let i = 0; i < xys.length; i++) {
            const xy = xys[i];
            // convert to int for better display
            var x = Math.floor(xy[0]);
            var y = Math.floor(xy[1]);
            points.push(x + ',' + y);
        }

        // convert to a string
        points = points.join(' ');

        // create a poly line and add to svg
        // Thanks to the post!
        // https://stackoverflow.com/questions/15980648/jquery-added-svg-elements-do-not-show-up
        var svg_polyline = document.createElementNS(
            'http://www.w3.org/2000/svg', 'polyline'
        );
        svg_polyline.setAttribute('id', 'mark-link-line-id-' + ltag.id);
        svg_polyline.setAttribute('points', points);
        svg_polyline.setAttribute('class', "tag-polyline");
        // svg_polyline.setAttribute('marker-end', "url(#arrow)");

        $('#cm_svg_plots').append(
            svg_polyline
        );

        // NEXT, draw a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-text-id-' + ltag.id);
        svg_text.setAttribute('text-anchor', 'middle');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', (xys[0][0] + xys[3][0]) / 2);
        svg_text.setAttribute('y', xys[1][1] + delta_height);
        svg_text.setAttribute('class', "tag-linktext");

        // put the text
        var text_node_content = ltag.id;
        // if (this.vpp.$data.cm.enabled_link_name) {
        //     text_node_content = ltag.tag + ': ' + ltag.id;
        // }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // then create a background color
        this.make_svg_text_bg(svg_text, 'svgmark-tag-' + ltag.tag);
    },

    cm_calc_points: function(coords_a, coords_b) {

    },
    
    /////////////////////////////////////////////////////////////////
    // Utils
    /////////////////////////////////////////////////////////////////
    is_file_ext: function(filename, ext) {
        var fn_lower = filename.toLocaleLowerCase();

        if (fn_lower.endsWith("." + ext)) {
            return true;
        }

        return false;
    },

    toast: function(msg, cls, timeout) {
        if (typeof(cls) == 'undefined') {
            cls = '';
        }
        if (typeof(timeout) == 'undefined') {
            timeout = 3000;
        }
        var options = {
            showTop: true,
            timeout: timeout,
            clsToast: cls
        };
        Metro.toast.create(msg, null, null, null, options);
    },

    msg: function(msg, cls) {
        if (typeof(cls) == 'undefined') {
            cls = 'info';
        }
        msg = '<i class="fa fa-info-circle"></i> ' + msg; 
        var notify = Metro.notify;
        notify.setup({
            width: 300,
            timeout: 3000,
            animation: 'swing'
        });
        notify.create(msg, null, { 
            cls: cls
        });
    },

    confirm: function(msg) {
        return window.confirm(msg);
        // Metro.dialog.create({
        //     title: "Use Windows location service?",
        //     content: "<div>Bassus abactors ducunt ad triticum...</div>",
        //     actions: [
        //         {
        //             caption: "Agree",
        //             cls: "js-dialog-close alert",
        //             onclick: function(){
        //                 alert("You clicked Agree action");
        //             }
        //         },
        //         {
        //             caption: "Disagree",
        //             cls: "js-dialog-close",
        //             onclick: function(){
        //                 alert("You clicked Disagree action");
        //             }
        //         }
        //     ]
        // });
    },

    get_elem_shape: function(elem) {
        // get the bounding box for this element
        var bounds = elem.getBBox();

        // get the extend style 
        var style = getComputedStyle(elem);
        var padding_top = parseInt(style["padding-top"])
        var padding_left = parseInt(style["padding-left"])
        var padding_right = parseInt(style["padding-right"])
        var padding_bottom = parseInt(style["padding-bottom"])

        // now, we could get the shape of this element
        var shape = {
            x: bounds.x - padding_left,
            y: bounds.y - padding_top,
            width: bounds.width + padding_left + padding_right,
            height: bounds.height + padding_top + padding_bottom
        }

        return shape;
    },

    make_svg_text_bg: function(elem, cls) {
        // get the shape
        var shape = this.get_elem_shape(elem);

        // create a background
        var bg = document.createElementNS(
            "http://www.w3.org/2000/svg", 
            "rect"
        );

        // set the attributes of this bg
        bg.setAttribute("x", shape.x);
        bg.setAttribute("y", shape.y);
        bg.setAttribute("width", shape.width);
        bg.setAttribute("height", shape.height);
        bg.setAttribute("class", 'tag-linktext-bg ' + cls);

        elem.parentNode.insertBefore(bg, elem);
    },

    start_tour_annotation: function() {
        if (this.tour.annotation == null) {
            this.tour.annotation = new Shepherd.Tour({
                defaultStepOptions: {
                    classes: '',
                    scrollTo: true
                }
            });

            // add step for dtd
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'Welcome!     This tool is very easy to use!<br>First, we could drop a schema (.dtd) file here.<br>The schema file defines all of the concepts you want to annotate in the documents.',
                attachTo: {
                  element: '#dropzone_dtd',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'Second, you need to drop some annotation files here.<br>You could drop raw text files (.txt) to start and add more anytime. Our tool will automatically convert the text files to xml format when saving. Then, next time you could drop those saved xml files here directly.',
                attachTo: {
                  element: '#dropzone_ann',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'That\'s all to start a new annotation task!<br>If you are not sure what each button does, here is a sample dataset for you to try. You could play with this sample data freely to see how each function works for annotation.<br>Have fun! ',
                attachTo: {
                  element: '#btn_annotation_load_sample',
                  on: 'left'
                },
                classes: '',
                buttons: [{
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }]
            });
        }

        this.tour.annotation.start();
    }
};

// extend the App
/**
 * This is an extension for app_hotpot text contents
 */

Object.assign(app_hotpot.vpp_data, {
texts: {
    "sentence_splitting_algorithm": {
        title: 'Sentence Splitting Algorithm',
        html: `MedTator can display text content in different ways, which include a sentence-mode display.
To display the split sentences correctly, the original content must be tokenized in sentence level.
There are several different methods / algorithms for sentence tokenization, and these methods are implemented in different packages / libraries.
MedTator provides some options for selecting different methods.

<ul>
    <li>The default method is a simple splitting algorithm based on symbol detection. This algorithm will check each character in the given text and compare it with pre-defined schema. The result of this algorithm works for most of cases, and has great performance. </li>
    <li>The <b>Compromise NLP</b> method is implemented based on <a target="_blank" href="https://github.com/spencermountain/compromise">Compromise NLP library</a>. It provides APIs for sentence spliting and formating. For more information, its <a target="_blank" href="https://observablehq.com/@spencermountain/compromise-sentences"></a> provides more technical details.</li>
    <li>The <b>Wink NLP</b> method is based on <a target="_blank" href="https://winkjs.org/">WinkJS NLP library</a>.</li>
</ul>
`
    }
}});

// The Tag Info Vue Module
Vue.component('iaa-tag-info', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {
        /**
         * Create a context HTML for showing the tag information
         * @param {Object} tag the annotated tag
         * @param {Object} ann the ann object
         */
         get_iaa_context_html: function(tag, ann) {
            // first, convert the tag spans for locating
            var loc = iaa_calculator.spans2loc(tag.spans);
            var spans_text = tag.text;

            // get the context start
            var c_start = loc[0] - 200;
            if (c_start < 0) { c_start = 0; }

            // get the context end
            var c_end = loc[1] + 200;
            if (c_end > ann.text.length) { c_end = ann.text.length; }

            // now create a text
            var html = [
                // the context before tag spans
                ann.text.substring(c_start, loc[0]),

                // the tag itself
                '<span class="mark-tag mark-tag-' + tag.tag + '">',
                spans_text,
                '</span>',

                // the context after tag spans
                ann.text.substring(loc[1], c_end)
            ];

            return html.join('');
        },

        accept_tag: function(hashcode, tag_name, cm, tag_idx, from) {
            // call app_hotpot directly
            app_hotpot.vpp.accept_iaa_tag(hashcode, tag_name, cm, tag_idx, from);
        },
    },

    computed: {
        
    },

    props: [
        'cm',
        'hashcode',
        'from',
        'tag',
        'tag_idx',
        'ann',
        'dtd',
        'iaa_display_tags_context',
        'force_module_update',
    ],

    template: `
<div class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-' + cm"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">

        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Accept this [' + tag.text + '] in goldstandard'"
                v-on:click="accept_tag(hashcode, tag.tag, cm, tag_idx, from)">
                Accept This
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-ab mr-2">
            <span class="mr-1"
                v-bind:class="'mark-tag-' + tag.tag">
                {{ tag.id }}
            </span>
            <span>
                {{ tag.spans }}: 
                <b>
                    {{ tag.text }}
                </b>
            </span>
        </div>
        
        <div v-for="(attlist, attlist_idx) in dtd.tag_dict[tag.tag].attlists"
            v-if="!['id','spans','text','tag'].contains(attlist.name)"
            class="iaa-tag-attlist mr-1 ml-1 d-flex flex-column">

            <div class="iaa-tag-attlist-name">
                &nbsp;{{ attlist.name }}:
            </div> 

            <div>
                &nbsp;{{ tag[attlist.name] }}
            </div>
            
        </div>
    </div>

    <div v-if="iaa_display_tags_context"
        v-html="get_iaa_context_html(tag, ann)"
        class="iaa-tag-context mt-1">
    </div>  
</div>   
`
});

// The Tag Info Vue Module for Gold Standard
Vue.component('iaa-tag-info-gs', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {

        reject_tag: function(hashcode, tag_name, cm, tag_idx) {
            // call app_hotpot directly
            tag_idx = parseInt(tag_idx);
            app_hotpot.vpp.reject_iaa_tag(hashcode, tag_name, cm, tag_idx);
        },

        upper: function(v) {
            return v.toLocaleUpperCase();
        }
    },

    computed: {
        
    },

    props: [
        'cm',
        'from',
        'hashcode',
        'tag_obj',
        'tag_idx',
        'ann',
        'dtd',
        'force_module_update',
    ],

    template: `
<div v-if="tag_obj != null"
    class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-gs'"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">
    
        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Reject this [' + tag_obj.tag.text + '] from goldstandard'"
                v-on:click="reject_tag(hashcode, tag_obj.tag.tag, cm, tag_idx)">
                Reject
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-gs mr-2">
            <span class="mr-1">
                <i class="fa fa-user"></i>
                <b>
                {{ upper(tag_obj.from) }}
                </b>
            </span>
            <span>
                {{ tag_obj.tag.spans }}: 
                <b>
                    {{ tag_obj.tag.text }}
                </b>
            </span>
        </div>
        
    </div>
</div>
<div v-else
    class="iaa-tag-detail-info w-100 d-flex flex-column">
    Rejected or Not Decided
</div>
`
});

var jarvis = {
    init: function() {
        // too bad ...
        if (isIE) { 
            this.ssmsg(_NOT_SUPPORT_MSG);
            return 0; 
        }

        app_hotpot.init();

        if (isCHROME) { 

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);
            } else {
                // old version chrome or not http

            }
        } else {

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);
                
            } else {
                jarvis.ssmsg(_LMT_SUPPORT_MSG);
            }

        }

        $(window).resize(function() {
            app_hotpot.resize();
        });

        // get some settings here
        var show_sample = this.get_url_paramter('ss');
        if (show_sample == 'yes') {
            app_hotpot.vpp.load_sample_ds();
        }

        // show the tour?
        var show_tour = this.get_url_paramter('st');
        if (show_tour == 'yes') {
            setTimeout('app_hotpot.start_tour_annotation();', 550);
        }
    },

    get_url_paramter: function(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    },

    ssmsg: function(msg) {
        $('#ss-msg').html(msg);
    },

    ssclose: function() {
        $('#start-screen').hide();
    },

    save_json: function(obj, fn) {
        var json_text = JSON.stringify(obj, null, 4);
        var blob = new Blob([json_text], {type: "text/json;charset=utf-8"});
        saveAs(blob, fn);
    },

    save_vpp_as: function(name) {
        if (app_hotpot.vpp.$data.dtd == null) {
            console.log('* no dtd yet');
        }
        var dtd_name = app_hotpot.vpp.$data.dtd.name;

        if (typeof(name) == 'undefined') {
            name = dtd_name;
        }

        // change to upper case for better looking
        name = name.toLocaleUpperCase();

        // save it!
        this.save_json(
            app_hotpot.vpp.$data,
            'vpp_data_'+name+'.json'
        );
    }
}

$(document).ready(function () {
    jarvis.init();
})
</script>

    
</body>
</html>