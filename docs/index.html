<!doctype html>
<html lang="en">
<head>
<!-- Required meta tags -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>MedTator</title>
<meta name="description" content="MedTator is a serverless text annotation tool for corpus development, which can process data 100% within your web browser and no need for a server support.">

<link href="./static/img/favicon.ico" rel="shortcut icon" type="image/x-icon" />

<!-- Font Awesome CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />

<!-- Metro UI style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/metro/4.3.5/css/metro-all.min.css">

<!-- jquery UI style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css" />

<!-- code mirror style -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css" />

<!-- for the metro UI -->
<meta name="metro4:init" content="false">

<style id="app_style">
.box {
    display: flex;
    flex-direction: column;
}

.box-header {
    width: 100%;
    padding: 3px 0;
    display: flex;
    flex-direction: row;
}

.box-header a {
    font-size: 1em;
}

.box-header h4 {
    padding: 0;
    margin: 0;
    font-size: 1.2em;
    height: 1.5em;
    line-height: 1.5em;
    margin: 3px 0;
}

.box-header button,
.box-body button,
.box-footer button {
    height: 1.6em;
    line-height: 1em;
    font-size: .9em;
    margin: 4px;
}

.box-header input,
.box-body input {
    height: 1.2em;
    line-height: 1.2em;
    font-size: 1em;
    margin: 4px 4px 0 4px;
    padding-bottom: 2px;
}

.box-header select {
    height: 2em;
    line-height: 1.2em;
    font-size: .9em;
    margin: 4px;
}

.box-header span {
    font-size: 1em;
}

.box-header-right {
    font-size: 1em;
    height: 2em;
    line-height: 2em;
    margin: 3px 0;
    text-align: right;
}

.box-body {
    width: 100%;
}

.box-body-item {
    padding: 5px 0 2px 0;
    display: flex;
    flex-direction: column;
    border-bottom: 1px dotted #cccccc;
}

.box-body-item ul {
    margin: 0;
}

.box-body-item ul input {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item ul label {
    vertical-align:middle;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.box-body-item-left {
    width: 73%;
}

.box-body-item-right {
    width: 24%;
    display: flex;
    flex-direction: row;
}

.box-body-item-label {
    width: 54%;
    font-size: 1em;
    line-height: 1.8em;
}

.box-body-item-value {
    width: 45%;
}

.box-body-item select {
    width: 100%;
}

.box-body h5 {
    padding: 0;
    margin: 0;
    font-size: 1em;
    height: 1.6em;
    line-height: 1.6em;
    margin: 3px 0;
}

.box-p {
    width: 100%;
    padding: 0;
    margin: 0;
    font-size: 1em;
}

.box-p-fixlen {
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
}

.box-footer {
    width: 100%;
    min-height: 20px;
    padding: 5px 0 5px 0;
}
html,body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-size: 12px;
}
.code {
    font-family: 'Courier New', Courier, monospace;
    background-color: #eeeeee;
    font-size: 12px;
}
.cursor-pointer {
    cursor: pointer;
}
/* a start screen for IE and hiding init */
#start-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    background: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
#ss-msg {
    width: 100%;
    padding: 10px 0;
    text-align: center;
}
.link-btn {
    color: #555555;
}
.h-splitter {
    width: 5px;
    height: 100%;
    background-color: #e9e9e9;
}
.h-splitter-menu {
    width: 1px;
    height: 64px;
    background-color: #dadbdc;
}
.v-splitter {
    width: 100%;
    height: 5px;
    background-color: #e9e9e9;
}
#app_info {
    position: absolute;
    top: 2px;
    right: 10px;
    color: #777777;
    z-index: 98;
}
#app_info a {
    color: #777777;
}
#app_info a:hover {
    color: black;
}
#mui_filelist {
    overflow-y: hidden;
    width: 250px;
}
#mui_filelist_toolbar {
    height: 32px;
    border-bottom: 1px solid #cccccc;
}
#mui_filelist_list {
    height: calc(100% - 32px);
    overflow-y: auto;
}
#mui_texteditor {
    width: calc(100% - 250px); 
    height: 100%;
}
#mui_dtdlist {
    overflow-y: auto;
    width: 250px;
}
#mui_annlist {
    padding-left: 5px;
    overflow-y: auto; 
    width: calc(100% - 250px);
}
#mui_stat_summary {
    width: 250px;
    border-right: 1px solid #e9e9e9;
}
#mui_stat_details {
    width: calc(100% - 250px);
}
#mui_iaa_summary {
    width: 240px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_anns {
    width: 300px;
    padding-right: 5px;
    border-right: 1px solid #e9e9e9;
    overflow-y: auto;
}
#mui_iaa_cohenk_summary {
    /* width: 540px; */
    padding-right: 5px;
    /* border-right: 1px solid #e9e9e9; */
    overflow-y: auto;
}
#mui_iaa_tags {
    width: calc(100% - 550px);
    /* flex-grow: 1; */
    padding-right: 5px;
    /* border-right: 1px solid #e9e9e9; */
    overflow-y: auto;
}
#mui_ruleset_result {
    
}
.stat-doc-sum-tags-box {
    border-left: 1px dotted #dedede; 
    padding: 0 0 0 1em;
}
.stat-doc-sum-tags-header {
    font-size: 1.2em;
    font-weight: bold;
    border-bottom: 1px solid #cccccc;
    padding: 0.2em 0;
    margin: 0 0 0.2em 0;
}
.stat-doc-sum-tags-body {
    width: 100%;
    height: 100%;
    max-height: 400px;
    overflow-y: auto;
}
.stat-tag-count {
    white-space: nowrap;
}
.stat-item-row {

}
.stat-item-row:hover {
    background-color: whitesmoke;
}
.stat-item-label {
    width: 120px;
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.stat-item-label-lg {
    width: 180px !important;
    max-width: 180px !important;
}
.stat-item-value {
    width: 120px;
    max-width: 120px;
    text-align: right;
}
.stat-item-value-sm {
    width: 70px;
    max-width: 70px;
    text-align: right;
}

input[type=range] {
    height: 24px;
    -webkit-appearance: none;
    margin: 0;
    width: 100%;
    background: transparent;
}

input[type=range]:focus {
    outline: none;
}

input[type=range]::-webkit-slider-runnable-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    box-shadow: 0px 0px 0px #000000;
    background: #E6E6E6;
    border-radius: 4px;
    border: 1px solid #A6A6A6;
}

input[type=range]::-webkit-slider-thumb {
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
    -webkit-appearance: none;
    margin-top: -5px;
}

input[type=range]:focus::-webkit-slider-runnable-track {
    background: #E6E6E6;
}

input[type=range]::-moz-range-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    box-shadow: 0px 0px 0px #000000;
    background: #E6E6E6;
    border-radius: 4px;
    border: 1px solid #A6A6A6;
}

input[type=range]::-moz-range-thumb {
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
}

input[type=range]::-ms-track {
    width: 100%;
    height: 8px;
    cursor: pointer;
    animate: 0.2s;
    background: transparent;
    border-color: transparent;
    color: transparent;
}

input[type=range]::-ms-fill-lower {
    background: #E6E6E6;
    border: 1px solid #A6A6A6;
    border-radius: 8px;
    box-shadow: 0px 0px 0px #000000;
}

input[type=range]::-ms-fill-upper {
    background: #E6E6E6;
    border: 1px solid #A6A6A6;
    border-radius: 8px;
    box-shadow: 0px 0px 0px #000000;
}

input[type=range]::-ms-thumb {
    margin-top: 1px;
    box-shadow: 1px 1px 1px #828282;
    border: 1px solid #8A8A8A;
    height: 16px;
    width: 16px;
    border-radius: 7px;
    background: #EBEBEB;
    cursor: pointer;
}

input[type=range]:focus::-ms-fill-lower {
    background: #E6E6E6;
}

input[type=range]:focus::-ms-fill-upper {
    background: #E6E6E6;
}

#app_hotpot {
    margin-top: 2px;
}
.dropzone:hover {
    border-color: rgb(0, 89, 255);
    font-weight: bold;
}
.disabled-zone {
    opacity: .5;
}
.zone-text {
    margin-top: 9px; 
    line-height: 14px;
    padding-left: 5px;
    padding-right: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
#dropzone_dtd {
    width: 170px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_ann {
    width: 170px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
#dropzone_txt {
    width: 176px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.dropzone-iaa {
    width: 166px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    font-size: 1em;
    border: 1px dotted rgb(17, 61, 110);
    border-radius: 4px;
}
.pos-corner-br {
    position: absolute; 
    right: 0; 
    bottom: 0;
}
.tag-list-row {
    background-color: white;
}
.tag-list-row-actived {
    background-color: #fffee8;
    border-bottom: 1px solid #999999;
    border-left: 5px solid #d3d3d3;
    padding-left: 5px !important;
}
.badge-shortcut {
    padding: 1px 1px 1px 2px;
    font-size: 10px;
    font-family: 'Courier New', Courier, monospace;
    color: black;
    background-color: #EAEAEA;
    border: 1px solid #EFEFEF;
    border-right: 1px solid #cccccc;
    border-bottom: 1px solid #cccccc;
}
.mark-hint {
    cursor: pointer;
    border: 2px dotted #999999;
    border-left: 0;
    border-right: 0;
    position: relative;
    /* display: inline-block; */
}
.mark-hint:hover {
    font-weight: bold;
    border-color: #333333;
}
.mark-hint-info {
    margin: 0 5px 0 0;
    padding: 0px 4px;
    color: white;
}
.mark-hint-text {

}
.mark-hint .mark-hint-tooltip {
    visibility: hidden;
    min-width: 100px;
    width: auto;
    background-color: #cccccc;
    color: black;
    text-align: center;
    font-size: .9em;
    font-weight: normal;
    font-family: sans-serif;
    border-radius: 6px;
    padding: 1px 5px;
    position: absolute;
    z-index: 999;
    top: 135%;
    left: 50%;
    margin-left: -50%;
    opacity: 0;
    transition: opacity 0.3s;
}
.mark-hint .tooltiptext::after {
    content: "";
    position: absolute;
    top: 130%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent #cccccc transparent;
}
.mark-hint:hover .mark-hint-tooltip {
    visibility: visible;
    opacity: 1;
}
.mark-tag {
    border-radius: 3px;
    /* padding: 1px 3px; */
    padding: 1px 0;
    margin-right: 0;
    cursor: pointer;
    border: 1px solid white;
    border-left: 0;
    border-right: 0;
}
.mark-tag:hover{
    border-color: red;
}
@keyframes glow {
    0% {
        border-color: #efefef;
        box-shadow: 0 0 5px #efefef;
    }
    100% {
        border-color: #333333;
        box-shadow: 0 0 10px #555555;
    }
}
.mark-tag-active {    
    border-top: 3px solid;
    border-bottom: 3px solid;
    animation: glow 500ms ease-out infinite alternate;
}
.mark-tag-info {
    font-size: .75em;
    margin: 0 2px;
    padding: 0px 2px;
    background: white;
    border-radius: 4px;
}
.mark-tag-info-inline {
}
.mark-tag-info-offset {
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: transparent;
    border-radius: .5em;
}
.mark-tag:hover .mark-tag-info-offset{
    display: inline;
    position: relative;
    right: -.7em;
    top: -.7em;
    font-size: .85em;
    color: grey;
    background-color: white;
}
.mark-tag:hover .mark-tag-info-offset:hover {
    color: black;
    background-color: white;
}
.mark-tag-text {
    margin-right: -.5em;
}
.mark-round {
    border-radius: 8px;
    padding: 0 1px 0 0;
    color: black !important;
}
#cm_editor {
    height: 100%;
}
.CodeMirror {
    height: 100%;
    font-size: 14px;
    line-height: 2em;
}
.CodeMirror-activeline-background {
    background-color: #e3f3fb;
}
.CodeMirror-plots {
    position: absolute;
    width: 100%;
    height: 100%;
}
#cm_svg_plots {
    width: 100%;
    height: 100%;
}
.tag-polyline {
	fill: none;
    stroke: black;
    stroke-width: 1;
    /* vector-effect: non-scaling-stroke; */
    /* stroke-dasharray: 2, 1; */
    opacity: .5;
}
.tag-polyline:hover {
    opacity: .95;
}
.tag-linkdot {
    font-size: 8px;
    padding: 0 1px;
    border-left: 1px solid;
    font-family: 'Courier New', Courier, monospace;
}
.tag-linktext {
    font-size: 9px;
    padding: 0 3px;
}
.tag-linktext-bg {
    stroke-width: 0;
    rx: 3px;
    opacity: 1;
}
.tag-cap {
    font-size: 9px;
    font-family: 'Courier New', Courier, monospace;
    /* font-weight: bold; */
}
.tag-cap-AB,
.tag-cap-ab {
    fill: green;
}
.tag-cap-A,
.tag-cap-a {
    fill: orangered;
}
.tag-cap-B,
.tag-cap-b {
    fill: royalblue;
}
.tag-cap-G,
.tag-cap-g {
    fill: goldenrod;
}
/* span[data-descr] {
    position: relative;
    cursor: help;
}
span[data-descr]:hover::after,
span[data-descr]:focus::after {
    content: attr(data-descr);
    position: absolute;
    left: 0;
    top: 20px;
    min-width: 150px;
    border: 1px solid #eeeeee;
    border-radius: 5px;
    background-color: rgba(218, 218, 218, 0.959);
    padding: 4px;
    color: #000000;
    font-size: 1rem;
    line-height: 1.2rem;
    z-index: 999;
} */
.tag-desc-item {
    padding: 0 0 0 3px;
    border-left: 1px solid #bdbdbd;
    margin-bottom: 1px;
}
.tag-desc-attr {
    font-style: italic;
}
.tag-desc-value {
    
}
#hoverbox_etag {
    position: absolute;
    background-color: #efefefee;
    color: black;
    padding: 5px;
    border: 1px solid #cccccc;
    border-radius: 5px;
    z-index: 888;
    max-width: 300px;
}

/* for the pop menu */
#popmenu_tag {
    z-index: 998;
    min-width: 100px;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
/* for the context menu */
#ctxmenu_sel {
    z-index: 999;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
#ctxmenu_nce {
    z-index: 998;
    position: absolute;
    left: -100px;
    padding: 1px 3px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
}
.ctxmenu-item {
    padding: 1px;
    cursor: pointer;
}
.ctxmenu-item:hover {
    background-color: rgb(221, 221, 221);
}
.ctxmenu-divider {
    height: 2px;
    margin: 2px 0;
    background-color: #dfdfdf;
}
.ui-widget-header {
    border: 0;
    height: 2em;
    line-height: 2em;
    text-indent: 0.5em;
    background-color: #EAEAEA;
}
.box-clear-times {
    margin-left: -16px;
    margin-right: 6px;
    z-index: 10;
    cursor: pointer;
    color: lightgrey;
}
.box-clear-times:hover {
    color: #333333;
}
.file-list {
    font-size: .9em;
    padding: 2px;
}
.file-list li {
    border-bottom: 1px dotted #eeeeee;
}
.file-list li.file-selected {
    font-weight: bold;
    background-color: #EFEFEF;
    border-left: 3px solid #1ba1e2;
    padding-left: 5px;
}
.file-list-item {
    margin-bottom: 1px;
}
.file-list-item:hover {
    background-color: #e9e8e8;
}
.file-list-item-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.file-list-item-name-unsaved {
    font-style: italic;
}
/* tag list */
.tag-list {
    font-size: 1em;
    padding: 2px;
}
.tag-list li {
    padding: 2px 0;
    border-bottom: 1px dotted #eeeeee;
}
.tag-list li:hover {
    background-color: #EAEAEA;
}
.tag-list-row-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;

    cursor: pointer;
    flex-grow: 1;
}
.tag-list-row-name-id-prefix {
    font-weight: bold;
    /* text-decoration: underline; */
}
.tag-list-row-count-0 {
    color: #bdbdbd;
    font-size: .95em;
}
.tag-list-row-all-tags {
    position: sticky;
    top: 0;
    z-index: 99;
}
.tag-table {
    font-size: .9em;
    position: relative;
}
.tag-table th, 
.tag-table td {
    padding: 2px;
}
.tag-table th {
    border-bottom: 1px solid #aaaaaa;
    text-align: left;
    position: sticky;
    top: 0;
    background-color: #efefef;
    z-index: 5;
    padding: 4px 0;
}
tr.tag-table-tr-actived {
    /* border-left: 5px solid #d3d3d3; */
    background-color: #fffee8; 
}
.tag-table th.tag-name {
    max-width: 200px;
    width: 180px;
}
.tag-table th.tag-id {
    max-width: 100px;
    width: 60px;
}
.tag-table th.tag-spans {
    max-width: 220px;
    width: 140px;
}
.tag-table td {
    border-bottom: 1px dotted #aaaaaa;
}
.tag-table tr:hover {
    background-color: #EAEAEA;
}
.tag-table td.td-text {
    max-width: 120px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.tag-attr-box {
    background-color: whitesmoke;
    border-radius: 3px;
    padding: 1px 5px;
    margin-bottom: 2px;
}
.tag-attr-box:hover{
    background-color: rgb(209, 209, 209);
}
.tag-attr-name {
    font-size: .9em;
}
input[type=text].tag-attr-input {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
select.tag-attr-select {
    padding: 0 3px;
    width: auto;
    max-width: 120px;
    line-height: 1.5em;
    height: 2em;
    display: inline;
    font-size: 1em;
    border: 0;
    border-bottom: 1px solid #999999;
}
.btn {
    padding: 2px 4px;
    border-top: 1px solid #EAEAEA;
    border-left: 1px solid #EAEAEA;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn:hover {
    border-top: 1px solid #aaaaaa;
    border-left: 1px solid #aaaaaa;
    border-right: 1px solid #858585;
    border-bottom: 1px solid #858585;
}
.btn:active {
    border-top: 1px solid #858585;
    border-left: 1px solid #858585;
    border-right: 1px solid #aaaaaa;
    border-bottom: 1px solid #aaaaaa;
}
.btn-xs {
    font-size: .9em;
}
.btn-dense {
    padding: 1px 2px !important;
}
.btn-black {
    color: #333333;
}
.btn-black:hover {
    color: #000000;
}
.btn-red {
    color: #b99090;
}
.btn-red:hover {
    color: red;
}
.btn-green {
    color: rgb(77, 118, 15);
}
.btn-green:hover {
    color: #68e22f;
}
.btn-orange {
    color: rgb(186, 107, 42);
}
.btn-orange:hover {
    color: rgb(239, 145, 45);
}
.btn-blue {
    color: rgb(24, 70, 139);
}
.btn-blue:hover {
    color: rgb(70, 166, 235);
}
input[type=text].ipt-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-md {
    font-size: 1.2em;
    line-height: 1.2em;
    height: 1.6em;
    padding: 2px 3px;
    max-width: 150px;
    display: inline;
    border: 0;
    border: 1px solid #999999;
}
input[type=text].ipt-spinner-xs {
    font-size: 1em;
    line-height: 1em;
    height: 1.4em;
    padding: 2px 3px;
    max-width: 80px;
    display: inline;
    border: 0;
}
.icon-fg-unsaved {
    color: #daaf5f;
}
.icon-fg-unsaved:hover {
    color: #ffa600;
}

.ruleset-tag-item {
    /* cursor: pointer; */
    border-bottom: 1px dotted #ececec;
}
.ruleset-tag-item:hover {
    background-color: whitesmoke;
}
.ruleset-tag-name {
    width: 180px;
    min-width: 180px;
    border-left: 1px solid;
}
.ruleset-tag-name-str {
    width: 140px;
    min-width: 140px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.ruleset-tag-text {
    padding: 0px 2px;
}
.ruleset-tag-text-str {
    padding: 0px 3px;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-count {
    padding: 0px 5px;
    background-color: #dadada;
    border-bottom: 1px solid #dadada;
}
.ruleset-tag-text-filelist {
    padding: 1px 0 1px 4px;
    border-left: 1px solid #EFEFEF;
    border-bottom: 1px solid #EFEFEF;
    max-height: 115px;
    overflow-y: auto;
}
.ruleset-tag-text-filelist-item {
    /* cursor: pointer; */
    color: #333333;
    padding: 2px 0;
}
.ruleset-tag-text-filelist-item:hover {
    color: rgb(1, 84, 207);
    background-color: #efefef;
}
.ruleset-tag-text-filelist-item-count {
    padding: 0px 2px;
    background-color: #eaeaea;
}
.iaa-tag-attr-name {
    font-size: 0.8em;
}
.iaa-annotator-AB,
.iaa-annotator-ab {
    color: green;
}
.iaa-annotator-A,
.iaa-annotator-a {
    color: orangered;
}
.iaa-annotator-B,
.iaa-annotator-b {
    color: royalblue;
}
.iaa-annotator-G,
.iaa-annotator-g {
    color: goldenrod;
}
.iaa-row-header {
    font-weight: bold;
}
.iaa-row {
    border-bottom: 1px dotted #efefef;
    padding-top: 3px;
    padding-bottom: 3px;
    cursor: pointer;
}
.iaa-row-actived {
    background-color: #dfdfdf;
}
.iaa-row:hover {
    background-color: #efefef;
}
.iaa-bar {
    background-color: #1ba1e2;
    height: 1em;
}
.iaa-bar-box {
    width: 120px;
}
.iaa-bar-name-box {
    width: 100px;
    /* fix the overflow of concept name */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-bar-filename {
    font-size: 0.8em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-bar-value {
    font-size: 0.9em;
    font-weight: bold;
}
.iaa-bar-filename-box {
    width: 150px;
}
.iaa-file-cm-box {
    font-size: 0.8em;
}
.iaa-file-gs-box {
    font-size: 0.8em;
}
.iaa-tag-name {
    text-align: center;
    padding-top: 5px;
    border-top: 2px dotted #dfdfdf;
    /* border-bottom: 1px dashed #dfdfdf; */
}
.iaa-tag-detail {
    /* border-bottom: 1px dashed #dfdfdf; */
    margin-top: 5px;
    margin-bottom: 5px;
}
.iaa-tag-detail:hover {
    background-color: #efefef;
}
.iaa-tag-detail-header {
    /* border-bottom: 1px dashed #dfdfdf; */
    font-weight: bold;
    text-align: center;
    font-size: 1.1em;
    margin-bottom: 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.iaa-tag-detail-info {
    border: 1px;
    border-radius: 5px;
    padding: 5px;
}
.iaa-tag-detail-info-tp {
    border: 1px solid #61a51d;
}
.iaa-tag-detail-info-fp {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-fn {
    border: 1px dotted #ff7878;
}
.iaa-tag-detail-info-gs {
    border: 1px dotted #dfdfdf;
}
.iaa-tag-detail-info-text-ab {
    margin-top: 14px;
}
.iaa-tag-detail-info-text-gs {
    margin-top: 14px;
}
.iaa-tag-detail-a {
    margin-right: 5px;
}
.iaa-tag-detail-b {
    margin-right: 5px;
}
.iaa-tag-detail-g-header {
    cursor: pointer;
}
.iaa-tag-detail-g {
    border-left: 1px dotted #dfdfdf;
    padding-left: 4px;
}
.iaa-tag-detail-g:hover {
    border-left-color: #999999;
    background-color: rgb(253, 236, 205);
}
.iaa-tag-detail-oper {
    display: none;
    position: absolute;
    top: -7px;
    left: -6px;
}
.iaa-tag-detail-info:hover 
.iaa-tag-detail-oper {
    display: block;
}
.iaa-tag-attlist {
    border-bottom: 1px solid #aaaaaa;
}
.iaa-tag-attlist-name {
    font-size: 0.8em;
}
.iaa-tag-context {
    font-size: 1.2em;
}
.iaa-w-100 {
    width: 100% !important;
}
.iaa-w-80 {
    width: 80% !important;
}
.iaa-w-50 {
    width: 50% !important;
}
.iaa-w-40 {
    width: 40% !important;
}
.iaa-w-20 {
    width: 20% !important;
}
.iaa-op-50 {
    opacity: 0.5;
}
.iaa-select-sm {
    width: 140px;
    padding: 0 !important;
    -webkit-appearance: auto !important;
}
/* for text display */
.clr-red {
    color: red;
}
.clr-grey {
    color: grey;
}
.txt-sm {
    font-size: 0.8em;
}
.txt-bold {
    font-weight: bold;
}
.txt-hover-bold:hover {
    font-weight: bold;
}
.txt-italic {
    font-style: italic;
}
/* fix for metro */
.radio .caption, .radio .check {
    font-size: 1em;
}
.switch .caption, .switch .check {
    font-size: 1em;
}
.switch {
    height: 30px;
}
.radio {
    height: 30px;
}
.ribbon-menu {
    min-width: 1340px;
}
.ribbon-toggle-group .ribbon-icon-button {
    height: 20px;
}
ol[class], ul[class] {
    list-style: none inside;
    margin: 0;
    padding: 0;
}
/* for the linking panel */
#pan_working_tag {
    position: absolute;
    top: 10px;
    left: 10px;
    max-width: 300px;
    max-height: 400px;
    overflow-x: hidden;
    overflow-y: auto;
    border: 1px solid #aaaaaa;
    background: white;
    box-shadow: 0 0 15px #828282;
    z-index: 999;
}
#pan_working_tag_title {
    cursor: grab;
    background-color: whitesmoke;
}
#pan_working_tag_title:active {
    cursor: grabbing;
}
.ltag-attr-name {
    align-items: center;
    min-width: 100px;
    max-width: 200px;
}
.ltag-attr-value {
    max-width: 150px;
}
.ltag-attr-row:hover {
    background-color: rgb(211, 211, 211) !important;
}
.ltag-attr-row:nth-child(even) {
    background-color: white;
}
.ltag-attr-row:nth-child(odd) {
    background-color: whitesmoke;
}

/* app_settings */
#app_settings {
    position: absolute;
    top: 20px;
    right: 5px;
    width: 280px;
    padding: 5px;
    background-color: white;
    border: 1px solid #828282;
    z-index: 10;
}
.setting-tab {
    border-bottom: 1px solid #aaaaaa;
    cursor: pointer;
}
.active-setting-tab {
    font-weight: bold;
    border: 1px solid #aaaaaa;
    border-bottom: 0;
}
/* fix for code mirror dialog style within metro */
.CodeMirror-dialog input,
.CodeMirror-dialog-top input {
    display: inline;
    height: 1.5rem;
    line-height: 1.5rem;
}
.CM-gutter-test {
    border-left: 2px solid red;
}

/* rules for the statistics tab */
.doctag-table {
    cursor: default;
}
.doctag-table tr:nth-child(even) {
    background: #ffffff;
}
.doctag-table tr:nth-child(odd) {
    background: #f5f5f5aa;
}

.doctag-table td:nth-child(even) {
    /* background: #f5f5f5aa; */
}
.doctag-table td:nth-child(odd) {
    background: #f5f5f5aa;
    /* background: #f5f5f5aa; */
}
.doctag-table tr {
    border-bottom: 1px solid transparent;
}
.doctag-table tr:hover {
    background-color: rgb(219, 219, 219);
    border-color: #646464 !important;
}
.doctag-table th {
    vertical-align: bottom;
    text-align: center;
    border-bottom: 1px solid #cccccc;
    min-width: 30px;
    max-width: 40px;
    padding-top: 5px;
}
.doctag-table th span.rotate-90 {
  -ms-writing-mode: tb-rl;
  -webkit-writing-mode: vertical-rl;
  writing-mode: vertical-rl;
  transform: rotate(180deg);
  white-space: nowrap;
}
.doctag-table td {
    vertical-align: center;
    text-align: center;
    padding: 2px;
}
.doctag-table td.td-summary {
    font-weight: bold;
}
.doctag-table td.td-filename {
    border-left: 5px solid transparent;
    padding-left: 5px;
    padding-right: 10px;
    width: 180px;
    max-width: 280px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
}
.doctag-table tr:hover td.td-filename{
    border-left-color: #646464;
    font-weight: bold;
    font-style: italic;
}
.doctag-table .td-count {
    display: inline-block;
    width: 100%;
    border: 1px solid transparent;
}
.doctag-table .td-count:hover {
    border-color: #646464;
}
.doctag-table .td-count-0 {
    font-size: 0.9em;
    color: #eeeeee;
}
/* schema_editor */
.schema-editor {
    min-width: 600px !important;
    max-width: 80% !important;
    z-index: 99;
    display: none;
    top: 5px;
}
.schema-editor .window-content {

    overflow-y: auto;
    overflow-x: hidden;
}
#schema_editor_menu {
    position: sticky;
    background: white;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid #cccccc;
}
.se-tag-row {

}
.se-tag-row:hover {
    background-color: #f5f5f5;
}
.se-tag-attr-cell {
    min-width: 150px;
}
.se-tag-attr-cell:hover {
    background-color: #e6e6e6;
}
.se-input-field-legend {
    font-size: .6em;
    position: absolute;
    z-index: 9;
    margin-top: -6px;
    margin-left: 5px;
    color: #777777;
    background: white;
    padding: 0 1px;
}
.se-input-tag-name {
    width: 120px !important;
    height: 24px !important;
    font-weight: bold !important;
    /* border-top: 0 !important;
    border-left: 0 !important;
    border-right: 0 !important; */
}
.se-btn-link {
    color: #444444 !important;
    padding: 3px 5px;
    cursor: pointer;
}
.se-btn-link:hover {
    color: #333333 !important;
    background-color: rgb(255, 255, 255);
}
.se-tag-attr-del {
}
.se-tag-attr-del:hover {
    color: #fc6262 !important;
}
.se-input-att-name {
    width: 120px !important;
    height: 24px !important;
    /* border-top: 0 !important;
    border-left: 0 !important;
    border-right: 0 !important; */
}
.se-input-att-value {
    width: 90px !important;
    height: 20px !important;
    font-size: .9em !important;
    font-style: italic;
}
.se-input-att-list-values {
    max-width: 150px !important;
    height: 20px !important;
    font-size: .9em !important;
    font-style: italic;
    cursor: pointer;
    pointer-events: auto !important;
}
.se-select-att-value {
    font-size: .9em !important;
    font-style: italic;
    height: 20px !important;
    width: 65px !important;
    line-height: 20px !important;
}
.se-select-att-type {
    font-size: .9em !important;
    font-style: italic;
    height: 20px !important;
    width: 50px !important;
    line-height: 20px !important;
}

/* labels */
.label-red {
    color: #ff4e2f;
}
.label-yellow {
    color: #f3dd34;
}
.label-green {
    color: #61a51d;
}
.label-blue {
    color: #3287e8;
}
.label-purple {
    color: #f200f2;
}

/* annotator-actions */
.box-annotator-actions { 
    display: none;
}
.tag-table-row:hover .box-annotator-actions {
    display: inline;
}

/* for converter */
.converter-dropzone {
    border: 1px solid #999999;
    padding: 5px;
    width: 300px;
    height: calc(100% - 20px);
    max-height: 400px;
}
.converter-dropzone h5 {
    background-color: white;
}
.converter-button {
    height: auto !important;
    line-height: 1.2em;
}
.converter-file-list {
    height: calc(100% - 50px);
    overflow-y: auto;
}
.converter-file-row {
    border-bottom: 1px dotted #cccccc;
    text-indent: 1em;
}

/* for changelog display */
.changelog-h3 {
    margin: 0.5em 0;
}
.changelog-p {
    margin: 0;
}
</style>

<style id="dtd_style">
</style>

</head>

<body>

<div id="start-screen">
    <h1>
        <i class="fa fa-highlighter"></i>
        MedTator
    </h1>
    <div id="ss-msg">Loading data and initializing GUI ...</div>
</div>

<div id="app_hotpot">

    <nav data-role="ribbonmenu">
        <ul class="tabs-holder">
            <li v-on:click="switch_mui('annotation')"
                v-bind:class="{'active': section=='annotation'}">
                <a id="tab_link_annotation" href="#section-1-1">
                    <i class="fa fa-highlighter"></i>
                    Annotation
                </a>
            </li>
            <li v-on:click="switch_mui('statistics')"
                v-bind:class="{'active': section=='statistics'}">
                <a href="#section-1-5">
                    <i class="fa fa-chart-bar"></i>
                    Statistics
                </a>
            </li>
            <li v-on:click="switch_mui('ruleset')"
                v-bind:class="{'active': section=='ruleset'}">
                <a href="#section-1-4">
                    <i class="fa fa-file-export"></i>
                    Export
                </a>
            </li>
            <li v-on:click="switch_mui('iaa')"
                v-bind:class="{'active': section=='iaa'}">
                <a href="#section-1-6">
                    <i class="fa fa-people-arrows"></i>
                    Adjudication
                </a>
            </li>

            <li v-on:click="switch_mui('corpus')"
                v-bind:class="{'active': section=='corpus'}">
                <a href="#section-1-2">
                    <i class="fas fa-mortar-pestle"></i>
                    Converter
                </a>
            </li>
        </ul>

        <div class="content-holder">
            
            <!-- the section for annotation -->
<div class="section" id="section-1-1" 
v-bind:class="{'active': section=='annotation'}">

<div class="group">

    <div id="dropzone_dtd" 
        class="dropzone"
        title="Drop a schema file (.dtd) that contains the annotation task"
        v-on:click="open_dtd_file">
        <div v-if="dtd != null" class="zone-text">
            <b>{{ dtd.name }}</b><br>
            {{ dtd.etags.length }} Entity Tags<br>
            {{ dtd.ltags.length }} Link Tags
        </div>
        <div v-else>
            Drop a <b>Schema</b> File Here
        </div>
    </div>

    <!-- <button class="ribbon-button"
        v-on:click="open_dtd_file">
        <span class="icon">
            <i class="far fa-file"></i>
        </span>
        <span class="caption">Open DTD</span>
    </button> -->

    <span class="title">

        Schema File (.dtd)

        <span v-if="dtd != null">
            <a href="javascript:void(0);"
                title="Download the current schema file"
                class="link-btn"
                v-on:click="download_schema_as_dtd">
                <i class="fa fa-download"></i>
            </a>
        </span>
    </span>
</div>

<div class="group">

    <div id="dropzone_ann" 
        title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
        v-on:click="open_ann_files"
        v-bind:class="{'disabled-zone': dtd == null, 'dropzone': dtd != null}">
        <div v-if="ann_idx != null" class="zone-text">
            <b>{{ anns[ann_idx]._filename }}</b><br>
            {{ anns[ann_idx].text.length }} chars<br>
            {{ anns[ann_idx].tags.length }} tags
        </div>
        <div v-else-if="dtd != null"
            title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
            class="zone-text">
            Drop <b>Annotation</b> <br>
            File(s) / Folder Here
        </div>
        <div v-else
            title="Load the schema for annotation task first">
            <i class="fa fa-arrow-left"></i>
            Load schema file first
        </div>
    </div>

    <span class="title">Annotation File (.xml/.txt)</span>
</div>

<div v-if="ann_idx != null"
    class="group">
    <button class="ribbon-button"
        title="Save the current editing annotation file to local disk"
        v-if="has_FSA_API()"
        v-on:click="save_xml">
        <span class="icon">
            <i class="far fa-save"></i>
        </span>
        <span class="caption">Save</span>
    </button>

    <!-- 
    <button class="ribbon-button"
        title="Save a copy of the current editing annotation file"
        v-if="has_FSA_API()"
        v-on:click="save_as_xml">
        <span class="icon">
            <i class="far fa-copy"></i>
        </span>
        <span class="caption">Save as</span>
    </button> 
    -->

    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            title="Save a copy of the current editing annotation file"
            v-on:click="save_as_xml">
            <span class="icon">
                <i class="far fa-copy"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Save as</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Download a copy of the current annotation as MedTator XML format"
                v-on:click="download_copy_as_xml">
                <a href="javascript:void(0);">Download a copy</a>
            </li>

            <li title="Download a copy of the current annotation as BioC XML format"
                v-on:click="download_copy_as_bioc">
                <a href="javascript:void(0);">Download a copy as BioC format</a>
            </li>

            <li class="divider"></li>

            <li title="Download all annotation files as a ZIP file"
                v-on:click="download_all_as_zip(true)">
                <a href="javascript:void(0);">Download all as a ZIP file</a>
            </li>

            <li title="Download all annotation files and the schema file as a ZIP file"
                v-on:click="download_all_as_zip(false)">
                <a href="javascript:void(0);">Download all with schema as a ZIP file</a>
            </li>
        </ul>
    </div>

    <button class="ribbon-button"
        title="Due to limited browser support, the current annotation file could only be downloaded."
        v-if="!has_FSA_API()"
        v-on:click="download_copy_as_xml">
        <span class="icon">
            <i class="fa fa-file-download"></i>
        </span>
        <span class="caption">Download</span>
    </button>
    
    <a id="downloadAnchorElem" style="display:none"></a>

    <span class="title">Save</span>
</div>

<div v-if="ann_idx != null"
    class="group">
    
    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            title="Set a Green label to the current file"
            v-on:click="set_label('green')">
            <span class="icon">
                <i class="far fa-bookmark"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Set Labels</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Set a Green label to the current file"
                v-on:click="set_label('green')">
                <a href="javascript:void(0);">Set <b class="label-green"> <i class="fa fa-bookmark"></i> Green</b> Label</a>
            </li>
            <li title="Set a red label to the current file"
                v-on:click="set_label('red')">
                <a href="javascript:void(0);">Set <b class="label-red"> <i class="fa fa-bookmark"></i> Red</b> Label</a>
            </li>
            <li title="Set a yellow label to the current file"
                v-on:click="set_label('yellow')">
                <a href="javascript:void(0);">Set <b class="label-yellow"> <i class="fa fa-bookmark"></i> Yellow</b> Label</a>
            </li>
            <li title="Set a blue label to the current file"
                v-on:click="set_label('blue')">
                <a href="javascript:void(0);">Set <b class="label-blue"> <i class="fa fa-bookmark"></i> Blue</b> Label</a>
            </li>
            <!-- <li title="Set a purple label to the current file"
                v-on:click="set_label('purple')">
                <a href="javascript:void(0);">Set <b class="label-purple"> <i class="fa fa-bookmark"></i> Purple</b> Label</a>
            </li> -->

            <li class="divider"></li>

            <li title="Download all annotation files and the schema file as a ZIP file"
                v-on:click="remove_labels()">
                <a href="javascript:void(0);">Remove Labels</a>
            </li>
        </ul>
    </div>
    
    <span class="title">File Label</span>
</div>

<div class="group">
    <div title="Display the current annotation file in its original format or sentence by sentence">
        <input type="radio" 
            name="display_mode" 
            value="document" 
            data-role="radio" 
            data-caption="Document" 
            checked 
            title="Display the current annotation file in its original format"
            v-model="cm.display_mode"
            @change="on_change_display_mode">
        <br>
        <input type="radio" 
            name="display_mode" 
            value="sentences" 
            data-role="radio" 
            data-caption="Sentences" 
            title="Display the current annotation file sentence by sentence. The sentence tokenization algorithm could be changed in settings."
            v-model="cm.display_mode"
            @change="on_change_display_mode">
    </div>

    <span class="title">Display Mode</span>
</div>

<div class="group">
    <div class="d-flex flex-column">
        <button class="ribbon-icon-button"
            title="Show search bar"
            style="height: 30px;"
            v-on:click="show_search_bar">
            <span class="icon">
                <i class="fa fa-search"></i>
            </span>
            <span class="caption">Search</span>
        </button>

        <button class="ribbon-icon-button"
            title="Clear highlights of the search results"
            style="height: 30px;"
            v-on:click="clear_search_result">
            <span class="icon">
                <i class="fa fa-eraser"></i>
            </span>
            <span class="caption">Clear</span>
        </button>
    </div>
    <!-- <div>

        <button class="ribbon-button" 
            title="Show search bar"
            v-on:click="show_search_bar">
            <span class="icon">
                <i class="fa fa-search"></i>
            </span>
            <span class="caption">Search</span>
        </button>
        
        <button class="ribbon-button" 
            title="Clear highlights of the search results"
            v-on:click="clear_search_result">
            <span class="icon">
                <i class="fa fa-eraser"></i>
            </span>
            <span class="caption">Clear</span>
        </button>
        
    </div> -->

    <span class="title">Search</span>
</div>

<div class="group">
    <div>
        <input type="radio" 
            name="mark_mode" 
            value="node" 
            data-role="radio" 
            data-caption="Color + ID" 
            checked 
            title="Display the entity tags on a background color with the tag ID"
            v-model="cm.mark_mode"
            @change="on_change_mark_mode">
        <br>
        <input type="radio" 
            name="mark_mode" 
            value="span" 
            data-role="radio" 
            data-caption="Color Only" 
            title="Display the entity tags on the corresponding background color only"
            v-model="cm.mark_mode"
            @change="on_change_mark_mode">
    </div>
    <span class="title">Entity Marks</span>
</div>

<div class="group">
    <div title="Display the link tags and lines">
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Links"
            title="Visualize link tags in the current document"
            v-model="cm.enabled_links"
            @change="on_change_link_settings">
        <br>
        
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Show Lines"
            title="Visualize the line drawing of link tag"
            v-model="cm.enabled_link_complex"
            @change="on_change_link_settings">
    </div>

    <!-- <div v-show="is_linking">
        <button class="ribbon-button"
            title="Create a new link tag with selected tags"
            v-on:click="done_linking">
            <span class="icon">
                <span class="fa fa-check-circle"></span>
            </span>
            <span class="caption">Done Linking</span>
        </button>
    </div>

    <div v-show="is_linking">
        <button class="ribbon-button"
            title="Stop linking tags and discard selected tags"
            v-on:click="cancel_linking">
            <span class="icon">
                <span class="far fa-times-circle"></span>
            </span>
            <span class="caption">Cancel Linking</span>
        </button>
    </div> -->
    <span class="title">Link Marks</span>
</div>

<div class="group">
    <div class="ribbon-toggle-group">
        <button class="ribbon-icon-button active"
            title="Show simple hints based on annotated tags"
            v-on:click="on_change_hint_mode('simple')">
            <span class="icon">
                <span class="mif-list"></span>
            </span>
            <span class="caption">Simple Hint</span>
        </button>

        <!-- <button class="ribbon-icon-button"
            v-on:click="on_change_hint_mode('smart')">
            <span class="icon">
                <span class="fa fa-magic"></span>
            </span>
            <span class="caption">Smart</span>
        </button> -->

        <button class="ribbon-icon-button"
            title="Turn off hint display"
            v-on:click="on_change_hint_mode('off')">
            <span class="icon">
                <span class="fa fa-ban"></span>
            </span>
            <span class="caption">No Hint</span>
        </button>
    </div>

    <div>

        <button class="ribbon-button" 
            title="Accept all hints in the current annotation"
            v-on:click="accept_all_hints">
            <span class="icon">
                <i class="fa fa-check-double"></i>
            </span>
            <span class="caption">Accept All</span>
        </button>
        
    </div>

    <span class="title">Hint Marks</span>
</div>


<div class="group">

    <div class="ribbon-split-button"
        id="btn_annotation_load_sample">
        <button class="ribbon-main"
            title="Load a minimal task"
            v-on:click="load_sample_ds('MINIMAL_TASK')">
            <span class="icon">
                <i class="far fa-edit"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Sample</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            
            
            <li title="A minimal annotation task"
                v-on:click="load_sample_ds('MINIMAL_TASK');">
                <a href="javascript:void(0);">Minimal Annotation Task</a>
            </li>
            
            
            
            <li title="A sample for entity and relation annotation"
                v-on:click="load_sample_ds('ENTITY_RELATION_TASK');">
                <a href="javascript:void(0);">Entity and Relation Annotation</a>
            </li>
            
            
            
            <li title="A sample for document level annotation samples"
                v-on:click="load_sample_ds('DOCUMENT_LEVEL_TASK');">
                <a href="javascript:void(0);">Document-Level Annotation</a>
            </li>
            
            
            
            <li title="A sample for IAA calculation"
                v-on:click="load_sample_ds('IAA_TASK');">
                <a href="javascript:void(0);">IAA Calculation</a>
            </li>
            
            
            <li class="divider"></li>
            <li title="Sample Text: COVID vaccine note for annotation test"
                v-on:click="load_sample_txt">
                <a href="javascript:void(0);">Sample Text: COVID Vaccine Note</a>
            </li>
            <li title="Sample Text from user's input"
                v-on:click="load_sample_txt_from_input">
                <a href="javascript:void(0);">Customize a Sample Text</a>
            </li>
        </ul>
    </div>

    <div style="margin-top: -2px;">
        <div class="ribbon-split-button">
            <button v-on:click="show_schema_editor(0)"
                style="height: 40px;"
                title="Edit current schema or create a new schema"
                class="ribbon-main">
                <span class="icon">
                    <span class="mif-cell-setting"></span>
                </span>
            </button>
            <span class="ribbon-split dropdown-toggle">Schema</span>
            <ul class="ribbon-dropdown text-left" 
                data-role="dropdown" data-duration="100">
                <li v-if="dtd != null"
                    title="Show the schema editor with the current schema in the annotation tab">
                    <a href="javascript:void(0);"
                    v-on:click="show_schema_editor(2)">
                    Edit Current Schema File
                </a></li>
                <li title="Show the schema editor with a new blank schema file">
                    <a href="javascript:void(0);"
                    v-on:click="show_schema_editor(1)">
                    Create New Schema File
                </a></li>
                <!-- <li><a href="javascript:void(0);" class="dropdown-toggle">
                    Sample Schema Files
                    </a>
                    <ul class="ribbon-dropdown" data-role="dropdown">
                        <li><a href="javascript:void(0);">
                            COVID-19 Symptons
                        </a></li>
                        <li><a href="javascript:void(0);">
                            Long COVID-19
                        </a></li>
                    </ul>
                </li> -->
                <li class="divider"></li>
                <li title="Show wiki page of how to use schema editor">
                    <a href="javascript:void(0);"
                    v-on:click="show_se_help">
                    How to Use Schema Editor?
                </a></li>
                <li title="Show more sample schema files in MedTator GitHub repo">
                    <a href="javascript:void(0);"
                    v-on:click="show_sample_schema_files">
                    More Sample Schema Files ...
                </a></li>
            </ul>
        </div>
    </div>

    <div class="ribbon-split-button">
        <button class="ribbon-main"
            title="MedTator document"
            data-role="popover"
            data-popover-position="right"
            data-popover-text="MedTator wiki that includes quick start, <br>manual, and technical details."
            v-on:click="show_wiki">
            <span class="icon">
                <i class="fa fa-info"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Wiki</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">

            <li title="MedTator wiki that includes quick start, manual, and technical details."
                v-on:click="show_wiki">
                <a href="javascript:void(0);">MedTator Wiki</a>
            </li>

            <li title="The best practices for corpus annotation."
                v-on:click="show_best_practice">
                <a href="javascript:void(0);">Annotation Best Practice</a>
            </li>

            <li class="divider"></li>

            <li title="Found anything not working? Report an issue or send feedback"
                v-on:click="report_an_issue">
                <a href="javascript:void(0);">Report an Issue</a>
            </li>
        </ul>
    </div>

    <!-- <button class="ribbon-button" 
        data-role="popover"
        data-popover-position="right"
        data-popover-text="MedTator wiki that includes quick start, <br>manual, and technical details."
        v-on:click="show_wiki">
        <span class="icon">
            <i class="fa fa-info"></i>
        </span>
        <span class="caption">Wiki</span>
    </button> -->

    <span class="title">Help</span>
</div>

</div>

            <!-- the section for corpus schema -->
<div class="section" id="section-1-2"
v-bind:class="{'active': section=='corpus'}">

<div class="group">
    <button class="ribbon-button"
        title="Clear all files for conversion"
        v-on:click="clear_converter_corpus_all">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All</span>
    </button>

    <span class="title">&nbsp;</span>
</div>

<div class="group">

    <div class="d-flex flex-column">

        <button class="ribbon-icon-button"
            title="Set the input format as MedTagger .ann format"
            v-on:click="switch_corpus('medtagger')">
            <span class="icon">
                <i class="far fa-file-code"></i>
            </span>
            <span class="caption">MedTagger <i>.ann</i> Format</span>
        </button>
    </div>

    <!-- 
    <button class="ribbon-button"
        title="Set the input format as Brat format"
        v-on:click="switch_corpus('brat')">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">Brat Format</span>
    </button>
    -->

    <span class="title">
        Input Format: 
        <b>{{ converter_corpus_task }}</b>
    </span>
</div>

<div class="group">

    <button class="ribbon-button"
        title="Convert the loaded files to MedTator format"
        v-on:click="convert_from_medtagger_txt_and_ann">
        <span class="icon">
            <i class="fas fa-mortar-pestle"></i>
        </span>
        <span class="caption">Convert Files</span>
    </button>

    <span class="title">Conversion</span>
</div>

<div class="group">

    <button class="ribbon-button"
        title="Download the converted MedTator format files as a zip file"
        v-on:click="download_converted_files_as_zip">
        <span class="icon">
            <i class="fas fa-download"></i>
        </span>
        <span class="caption">Download as zip</span>
    </button>

    <span class="title">Results</span>
</div>

<div class="group">

    <button class="ribbon-button"
        title="Open the wiki page to show how to use the converter"
        v-on:click="show_converter_how_to_user">
        <span class="icon">
            <i class="fas fa-question"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">Help</span>
</div> 

<!-- 
<div class="group">
    <div id="dropzone_txt" class="dropzone">
        <div v-if="txt_anns.length == 0" class="zone-text">
            Drop <b>Raw Text</b> File <br>
            Here
        </div>
        <div v-else>
            {{ txt_anns.length }} txt files
        </div>
    </div>

    <button class="ribbon-button"
        :disabled="dtd == null"
        v-on:click="open_txt_files">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">Open .txt Files</span>
    </button>

    <span class="title">Raw Text Files</span>
</div>

<div class="group">
    
    <div class="d-flex flex-column ml-2">
        <div class="mt-1 mb-2">
            <label for="">Prefix for XML Files</label>
            <input type="text" class="ipt-md"
                v-model="txt_xml_prefix">
        </div>
        <div>
            <label for="">Suffix for XML Files</label>
            <input type="text" class="ipt-md"
                v-model="txt_xml_suffix">
        </div>
    </div>

    <button class="ribbon-button"
        :disabled="dtd == null || txt_anns.length == 0"
        v-on:click="convert_txt_anns_to_xmls">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">Convert to XMLs</span>
    </button>

    <span class="title">Annotation XML File</span>
</div>

<div class="group">

    <button class="ribbon-button"
        :disabled="txt_xmls.length == 0 || txt_xmls.length != txt_anns.length"
        v-on:click="download_txt_xmls_as_zip">
        <span class="icon">
            <i class="fa fa-download"></i>
        </span>
        <span class="caption">All as a ZIP</span>
    </button>

    <span class="title">Download</span>
</div> 
-->

</div>

            <!-- the section for statistics -->
<div class="section" id="section-1-5"
v-bind:class="{'active': section=='statistics'}">
<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="update_hint_dict">
        <span class="icon">
            <i class="fa fa-sync"></i>
        </span>
        <span class="caption">Refresh</span>
    </button>

    <span class="title">&nbsp;</span>    
</div>

<div class="group">
    <button class="ribbon-button" 
        title="Download the summary of the statistics"
        :disabled="dtd == null"
        v-on:click="download_stat_summary">
        <span class="icon">
            <i class="far fa-clipboard"></i>
        </span>
        <span class="caption">Summary (.csv)</span>
    </button>

    <button class="ribbon-button" 
        title="Download the detailed statistics"
        :disabled="dtd == null"
        v-on:click="download_stat_details">
        <span class="icon">
            <i class="fas fa-clipboard-list"></i>
        </span>
        <span class="caption">Details (.xlsx)</span>
    </button>

    <span class="title">Download</span>    
</div>

<div class="group">
    <button class="ribbon-button" 
        title="Reset all filters to default values"
        :disabled="dtd == null"
        v-on:click="reset_stat_filters">
        <span class="icon">
            <i class="fas fa-undo"></i>
        </span>
        <span class="caption">Reset All</span>
    </button>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <div>
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Token Text"
            v-model="stat_filter_token_text"
            v-bind:disabled="dtd == null"
            @change="on_change_stat_filters">
        <br>
    </div>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <div class="d-flex flex-column"
        style="width: 90px;">
        <div style="width: 100px;">
            Show Token: 
            <b v-if="stat_filter_min_tokens == 0">
                ALL
            </b>
            <b v-else>
                &leq;{{ stat_filter_min_tokens }}
            </b>
        </div>
        <input v-model.number='stat_filter_min_tokens'
            type="range" 
            name="volume"
            min="0" 
            max="10"
            style="width: 90px;">
        <div class="d-flex flex-row flex-justify-between">
            <div>
                All
            </div>
            <div>
                5
            </div>
            <div>
                10
            </div>
        </div>

    </div>

    <span class="title">Filters</span>    
</div>

</div>

            <!-- the section for ruleset -->
<div class="section" id="section-1-4"
v-bind:class="{'active': section=='ruleset'}">

<div v-if="dtd != null"
     class="group">
    <div>
        <p class="mb-1">
            <i class="fa fa-list"></i>
            Summary:
        </p>
        <p class="mb-1 mt-1">
            <b>
                {{ anns.length }}
            </b>
            Documents
            <br>
            <b>
                {{ count_tags_in_anns(anns)}}
            </b>
            Annotated Tags
        </p>
    </div>

    <span class="title">&nbsp;</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_text_tsv">
        <span class="icon">
            <i class="far fa-file-excel"></i>
        </span>
        <span class="caption">Tag Text</span>
    </button>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_text_sent_tsv">
        <span class="icon">
            <i class="far fa-file-excel"></i>
        </span>
        <span class="caption">Tag &amp; Sentence</span>
    </button>

    <span class="title">Text</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        title="Download IOB2/BIO format"
        v-on:click="download_dataset_iob2">
        <span class="icon">
            <i class="far fa-file"></i>
        </span>
        <span class="caption">IOB2/BIO (.tsv)</span>
    </button>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        title="Download BioC format"
        v-on:click="download_dataset_bioc">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">BioC (.xml)</span>
    </button>

    <span class="title">Dataset</span>
</div>

<div class="group">
    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_ruleset_medtagger_zip">
        <span class="icon">
            <i class="far fa-file-archive"></i>
        </span>
        <span class="caption">MedTagger (.zip)</span>
    </button>

    <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>

    <button class="ribbon-button" 
        :disabled="dtd == null"
        v-on:click="download_ruleset_spacy_jsonl">
        <span class="icon">
            <i class="far fa-file-code"></i>
        </span>
        <span class="caption">spaCy (.jsonl)</span>
    </button>
    <span class="title">Ruleset</span>
</div>

<div class="group">

    <button class="ribbon-button" 
        data-role="popover"
        data-popover-position="right"
        data-popover-text="Examples of how to use the exported ruleset files."
        v-on:click="show_howtouse">
        <span class="icon">
            <i class="fa fa-terminal"></i>
        </span>
        <span class="caption">How to use</span>
    </button>

    <span class="title">Help</span>
</div>

</div>

            <!-- the section for iaa -->
<div class="section" id="section-1-6"
v-bind:class="{'active': section=='iaa'}">

<div class="group">
    <button class="ribbon-button"
        title="Clear all annotation files and calculated IAA results"
        v-on:click="clear_iaa_all(null)">
        <span class="icon">
            <i class="far fa-times-circle"></i>
        </span>
        <span class="caption">Clear All</span>
    </button>

    <span class="title">&nbsp;</span>
</div> 


<div class="group">

    <div id="dropzone_iaa_0" class="dropzone-iaa"
        iaa_id="0">
        <div v-if="dtd == null" 
            class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="iaa_ann_list[0].anns.length == 0" 
            class="zone-text">
            Drop Annotation <br>
            File(s) or Folder
        </div>
        <div v-else 
            class="zone-text">
            Annotated {{ count_tags_in_anns(iaa_ann_list[0].anns) }} Tags
            <br>
            in {{ iaa_ann_list[0].anns.length }} Files
        </div>

        <button class="ribbon-tool-button pos-corner-br"
            title="Clear all annotations from annotator A"
            v-if="iaa_ann_list[0].anns.length != 0"
            v-on:click="clear_iaa_all(0)">
            <span class="icon">
                <i class="far fa-times-circle"></i>
            </span>
        </button>

    </div>

    <span class="title">
        Annotator A
    </span>

</div>

<div class="group">

    <!-- <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div> -->

    <div id="dropzone_iaa_1" class="dropzone-iaa"
        iaa_id="1">
        <div v-if="dtd == null" class="zone-text">
            Load DTD file first<br>
            in the Annotation Tab
        </div>
        <div v-else-if="iaa_ann_list[1].anns.length == 0" 
            class="zone-text">
            Drop Annotation <br>
            File(s) or Folder
        </div>
        <div v-else class="zone-text">
            Annotated {{ count_tags_in_anns(iaa_ann_list[1].anns) }} Tags
            <br>
            in {{ iaa_ann_list[1].anns.length }} Files
        </div>

        <button class="ribbon-tool-button pos-corner-br"
            title="Clear all annotations from annotator B"
            v-if="iaa_ann_list[1].anns.length != 0"
            v-on:click="clear_iaa_all(1)">
            <span class="icon">
                <i class="far fa-times-circle"></i>
            </span>
        </button>
    </div>

    <span class="title">
        Annotator B
    </span>
</div>

<div class="group">
    <!-- 
    <div class="mr-1">
        <input type="radio" name="match_mode" 
            value="overlap" 
            data-role="radio" 
            data-caption="<i class='fa fa-align-center'></i> Overlap" checked 
            v-model="iaa_match_mode"
            @change="on_change_iaa_settings">
        <br>
        <input type="radio" name="match_mode" 
            value="exact" 
            data-role="radio" 
            data-caption="<i class='fa fa-align-justify'></i> Exact" 
            v-model="iaa_match_mode"
            @change="on_change_iaa_settings"> 
    </div>
    -->
    
    <div v-if="iaa_match_mode == 'overlap'"
        class="p-1 ml-1 mr-1 border bd-gray border-radius">

        <div class="mt-1 mb-1">
            Overlap
            <i class="fa fa-percentage"></i>
        </div>

        <div>        
            <input id="iaa_form_overlap_ratio" 
                name="iaa_form_overlap_ratio" 
                style="width: 36px"
                type="text" 
                class="ipt-md" 
                v-model.number="iaa_overlap_ratio">
            <span class="mr-1">
                %
            </span>

            <!-- <button title="Reset the overlap ratio"
                v-on:click="iaa_overlap_ratio = iaa_overlap_ratio_default">
                <i class="fa fa-undo"></i>
            </button> -->
        </div>
    </div>

    <div class="mr-1">
        <input type="checkbox" 
            class="check"
            title="Include attributes in IAA calculation?"
            data-role="switch" 
            data-caption="Attribute"
            v-model="iaa_use_attributes"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_use_attributes">
        <br>
        <button class="ribbon-icon-button dropdown-toggle"
            title="Select the attributes to be included in IAA calculation"
            v-bind:disabled="!iaa_use_attributes">
            <span class="icon">
                <i class="fas fa-tasks"></i>
            </span>
            <span class="caption">
                Select Attributes
            </span>
        </button>
        <ul v-if="dtd != null && iaa_use_attributes"
            class="ribbon-dropdown" 
            data-role="dropdown" 
            data-duration="100">
            <li v-for="tag in dtd.etags">
                <a href="javascript:void(0);" class="dropdown-toggle">
                    {{ tag.name }}:
                    
                    <span v-for="att in tag.attlists"
                        v-show="iaa_use_tag_attrs[tag.name][att.name]"
                        class="mr-1 iaa-tag-attr-name">
                        {{ att.name }}
                    </span>
                </a>
                <ul class="ribbon-dropdown" data-role="dropdown">
                    <li v-for="att in tag.attlists"
                        v-bind:class="{'checked': iaa_use_tag_attrs[tag.name][att.name] }">
                        <a href="javascript:void(0);" 
                            v-on:click="toggle_iaa_tag_attrs(tag.name, att.name)">
                            {{ att.name }}
                        </a>
                    </li>
                </ul>
            </li>
            <li class="divider"></li>
            <li title="Select all attributes for IAA calcuation">
                <a href="javascript:void(0);"
                    v-on:click="set_all_iaa_use_tag_attrs(true)">
                    Select All Attributes
                </a>
            </li>
            <li title="Select none attributes for IAA calcuation">
                <a href="javascript:void(0);"
                    v-on:click="set_all_iaa_use_tag_attrs(false)">
                    Select None Attributes
                </a>
            </li>
        </ul>
    </div>


    <button class="ribbon-button"
        title="Calculate the IAA for the given annotation files"
        :disabled="dtd == null || iaa_ann_list[0].anns.length == 0 || iaa_ann_list[1].anns.length == 0"
        v-on:click="calc_iaa">
        <span class="icon">
            <i class="fa fa-calculator"></i>
        </span>
        <span class="caption">Calculate</span>
    </button>
<!-- 
    <div class="ribbon-split-button">
        <button class="ribbon-main">
            <span class="icon">
                <span class="mif-cogs"></span>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Measure</span>
        <ul class="ribbon-dropdown" data-role="dropdown" data-duration="100">
            <li v-bind:class="{'checked': iaa_display_measure == 'f1' }">
                <a href="javascript:void(0);"
                    v-on:click="set_iaa_display_measure('f1')">
                    F1 Score
                </a>
            </li>
            <li v-bind:class="{'checked': iaa_display_measure == 'cohen_kappa' }">
                <a href="javascript:void(0);"
                    v-on:click="set_iaa_display_measure('cohen_kappa')">
                    Cohen's Kappa Coefficient
                </a>
            </li>
        </ul>
    </div> 
-->


    <button class="ribbon-button" 
        :disabled="dtd == null || iaa_gs_dict == null"
        title="Download current IAA calculation result report"
        v-on:click="export_iaa_report">
        <span class="icon">
            <i class="fa fa-clipboard-list"></i>
        </span>
        <span class="caption">Report</span>
    </button>

    <span class="title">Inter-Annotator Agreement (IAA)</span>
</div>

<div class="group">
    <div>
        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Agreed Tags"
            v-model="iaa_display_tags_tp"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_settings">
        <br>

        <input type="checkbox" 
            class="check"
            data-role="switch" 
            data-caption="Tag Context"
            v-model="iaa_display_tags_context"
            v-bind:disabled="dtd == null"
            @change="on_change_iaa_settings">

    </div>
    <span class="title">Tag Display</span>
</div>


<div v-show="dtd != null && iaa_gs_dict != null"
    class="group">
    <!-- <div>
        <div>
            <input type="checkbox" 
                class="check"
                data-role="switch" 
                data-caption="Adj. Panel"
                v-model="iaa_display_adj_panel"
                @change="on_change_iaa_settings">
        </div>

        <button class="ribbon-icon-button"
            :disabled="dtd == null || iaa_dict == null"
            title="Reset current adjudication result to default status"
            v-on:click="make_default_adj">
            <span class="icon">
                <i class="far fa-object-group"></i>
            </span>
            <span class="caption">Reset Adjudication</span>
        </button>
    </div>

-->

    <!-- <div>
        <button class="ribbon-button"
            :disabled="dtd == null || iaa_dict == null"
            title="Reset current adjudication result to default status"
            v-on:click="make_default_adj">
            <span class="icon">
                <i class="far fa-object-group"></i>
            </span>
            <span class="caption">Reset</span>
        </button>

        <button class="ribbon-button" 
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Edit adjudication result in annotation tab"
            v-on:click="transfer_to_annotation_tab">
            <span class="icon">
                <i class="far fa-edit"></i>
            </span>
            <span class="caption">Edit</span>
        </button>

    </div> -->

    <!-- <div class="h-splitter-menu ml-2 mr-2">&nbsp;</div>  -->

    <!-- <div class="d-flex flex-row">

        <button class="ribbon-button" 
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Download current adjudication result"
            v-on:click="download_all_gs">
            <span class="icon">
                <i class="fa fa-file-download"></i>
            </span>
            <span class="caption">Download</span>
        </button>

    </div> -->

    <div class="ribbon-split-button"
        id="btn_annotation_save_">
        <button class="ribbon-main"
            :disabled="dtd == null || iaa_gs_dict == null"
            title="Download all tags from both annotator A and B"
            v-on:click="download_all_iaa_anns">
            <span class="icon">
                <i class="far fa-copy"></i>
            </span>
        </button>
        <span class="ribbon-split dropdown-toggle">Download</span>
        <ul class="ribbon-dropdown text-left" 
            data-role="dropdown" 
            data-duration="100">
            <li title="Download all tags from both annotator A and B"
                v-on:click="download_all_iaa_anns">
                <a href="javascript:void(0);">All Tags from A and B</a>
            </li>

            <li title="Download the adjudicated tags as shown below"
                v-on:click="download_all_gs">
                <a href="javascript:void(0);">Simple Adjudicated Tags</a>
            </li>
        </ul>
    </div>
    
    <span class="title">Adjudication</span>
</div>

</div>

        </div>

        <div id="app_info">
            MedTator 1.2.41 | 
            <a title="MedTator Settings"
                href="javascript:void(0);"
                v-on:click="cfg.is_show_settings = true">
                <i class="fa fa-cog"></i>
                Settings
            </a> | 
            <a title="MedTator Settings"
                href="javascript:void(0);"
                v-on:click="show_changelog">
                <i class="fas fa-newspaper"></i>
                Changelog
            </a> | 
            <a target="_blank" 
                title="MedTator Source Code at GitHub"
                href="https://github.com/OHNLP/MedTator">
                <i class="fab fa-github"></i>
            </a>
        </div>

    </nav>

    <!-- the ui for main settings -->
    <div id="app_settings"
    v-show="cfg.is_show_settings"
    class="box">
    <div class="box-header d-flex flex-justify-between">
        <h4>
            <i class="fa fa-cog"></i>
            MedTator Settings
        </h4>
        <div class="d-flex flex-row">
            <div style="line-height: 2em;">
                MEM: {{ get_metator_mem() }} MB
            </div>
            <button v-on:click="cfg.is_show_settings = false">
                <i class="fa fa-times"></i>
            </button>
        </div>
    </div>
    <div class="box-body">
        <div class="d-flex flex-row">
            <div class="px-2 setting-tab"
                v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='import'}"
                v-on:click="switch_setting_tab('import')">
                <i class="far fa-file"></i>
                Import
            </div>

            <div class="px-2 setting-tab"
                v-bind:class="{'active-setting-tab':cfg.active_setting_tab=='gui'}"
                v-on:click="switch_setting_tab('gui')">
                <i class="fa fa-table"></i>
                GUI
            </div>
        </div>

        <!-- import setting tab -->
        <div v-if="cfg.active_setting_tab == 'import'">
            <div class="box-body-item">
                <p>
                    Sentence Splitting Algorithm
                    <a href="javascript:void(0);"
                        v-on:click="show_help('sentence_splitting_algorithm')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_ssa_v1" 
                            value="simpledot" 
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v1">Simple Method (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_ssa_v2" 
                            value="compromise" 
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v2">Compromise NLP</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_ssa_v3" 
                            value="wink_nlp" 
                            v-model="cfg.sentence_splitting_algorithm">
                        <label for="cfg_ssa_v3">Wink NLP Sentence Tokenization</label>
                    </li>
                </ul>
            </div>
        </div>

        <!-- data setting tab -->
        <div v-else-if="cfg.active_setting_tab == 'gui'">
            <div class="box-body-item">
                <p>
                    Linking marks selection between editor and concept list 
                    <a href="javascript:void(0);"
                        v-on:click="show_help('linking_marks_selection')">
                        <i class="far fa-question-circle"></i>
                    </a>:
                </p>
                <ul class="box">
                    <li>
                        <input type="radio" id="cfg_lms_v1" 
                            value="all_concepts" 
                            v-model="cfg.linking_marks_selection">
                        <label for="cfg_lms_v1">Render all marks (Default)</label>
                    </li>
                    <li>
                        <input type="radio" id="cfg_lms_v2" 
                            value="selected_concepts" 
                            v-model="cfg.linking_marks_selection">
                        <label for="cfg_lms_v2">Render marks of selected concept</label>
                    </li>
                </ul>
                
            </div>
        </div>

        <div v-else>
            &nbsp;
        </div>

    </div>
</div>

    <!-- the ui for main annotation -->
    <div v-show="section=='annotation'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 60%;">
        <div id="mui_filelist"
            class="d-flex flex-column flex-justify-start flex-align-start h-100">
            <div id="mui_filelist_toolbar"
                class="d-flex flex-row flex-justify-between flex-align-center w-100">
                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <button class="btn-xs mr-1 dropdown-toggle">
                        {{ get_sort_by_label(this.sort_anns_by) }}
                    </button>
                    <ul class="ribbon-dropdown text-left" 
                        data-role="dropdown" 
                        data-duration="100">
                        <li title="Sort the file list by the file name A-Z"
                            v-on:click="sort_filelist_by('alphabet')">
                            <a href="javascript:void(0);">By file name (A->Z)</a>
                        </li>
                        <li title="Sort the file list by the file name Z-A"
                            v-on:click="sort_filelist_by('alphabet_r')">
                            <a href="javascript:void(0);">By file name (Z->A)</a>
                        </li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('tags')">
                            <a href="javascript:void(0);">By annotated tags (0->N)</a>
                        </li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('tags_r')">
                            <a href="javascript:void(0);">By annotated tags (N->0)</a>
                        </li>

                        <li title="Sort the file list by the color of labels"
                            v-on:click="sort_filelist_by('label')">
                            <a href="javascript:void(0);">By label color (Green first)</a>
                        </li>

                        <li title="Sort the file list by the color of labels"
                            v-on:click="sort_filelist_by('label_r')">
                            <a href="javascript:void(0);">By label color (Non-color first)</a>
                        </li>

                        <li class="divider"></li>

                        <li title="Sort the file list by the number of annotated tags"
                            v-on:click="sort_filelist_by('default')">
                            <a href="javascript:void(0);">By default import sequence</a>
                        </li>
                    </ul>

                    <span class="mr-1"
                        title="Filter the files by file name">
                        Filter: 
                    </span>
                    <input type="text" 
                        class="ipt-xs mr-1"
                        style="width: 55px;"
                        v-model="fn_pattern">
                    <span v-on:click="clear_filter_box"
                        class="box-clear-times"
                        title="Clear the filter input box">
                        <i class="fa fa-times"></i>
                    </span>
                
                    <span v-if="anns.length > 0">
                        {{ anns.length }} 
                        <span class="txt-sm">files</span>
                    </span>
                </div>

                <div class="d-flex flex-row flex-justify-start flex-align-center mr-1">
                    <button class="btn-xs"
                        title="Remove all files"
                        v-on:click="remove_all_ann_files">
                        <i class="far fa-trash-alt"></i>
                        All
                    </button>
                </div>
            </div>
            <div id="mui_filelist_list" 
                v-if="anns.length > 0"
                class="d-flex flex-column flex-justify-start flex-align-start w-100 h-100">
                <ul class="w-100 file-list">
                    <li v-for="v_ann in sort_v_anns(anns)"
                        v-show="is_current_ann(v_ann) || is_match_filename(v_ann._filename)"
                        v-bind:class="{'file-selected':is_current_ann(v_ann)}"
                        class="file-list-item">
                        <div class="d-flex flex-row flex-justify-between">
                            <div class="file-list-item-name"
                                style="flex-grow: 1;"
                                v-on:click="set_ann_idx_by_ann(v_ann)"
                                v-bind:title="v_ann._filename"
                                v-bind:class="{'file-list-item-name-unsaved':!anns[v_ann.idx]._has_saved}">

                                <a href="javascript:void(0);"
                                    v-show="!anns[v_ann.idx]._has_saved" 
                                    v-on:click="save_xml_by_ann(v_ann)"
                                    title="Save this annotation file"
                                    class="icon-fg-unsaved mr-1">
                                    <i class="fa fa-save"></i>
                                </a>
                                <span v-if="has_any_label(anns[v_ann.idx])">
                                    <span v-for="ann_label in anns[v_ann.idx].meta.label"
                                        :class="'label-' + ann_label.color">
                                        <i class="fas fa-bookmark"></i>
                                    </span>
                                </span>
                                <span>
                                    {{ v_ann._filename }}
                                </span>
                            </div>

                            <div class="d-flex flex-row">
                                <div class="mr-2"
                                    v-bind:title="'Annotated ' + anns[v_ann.idx].tags.length + ' tags'">
                                    {{ anns[v_ann.idx].tags.length }}
                                </div>

                                <div v-bind:title="'Remove ' + v_ann._filename">
                                    <a v-on:click="remove_ann_file_by_ann(v_ann)"
                                        class="btn btn-red btn-xs"
                                        href="javascript:void(0);">
                                        <i class="fa fa-minus-circle"></i>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
            <div id="mui_filelist_list"
                class="d-flex text-center flex-align-center flex-justify-center w-100"
                v-else>
                
                    
                <p v-if="dtd == null"
                    class="clr-grey">
                    <i class="fa fa-arrow-up"></i>
                    Load schema file first
                </p>
                <p v-else
                    title="Drop the file(s) for annotation (.xml or .txt) or folder(s) containing annotation files"
                    class="txt-hover-bold">
                    Drop <b>Annotation</b> File(s) / Folder Here
                    <br>
                    (.xml / .txt)
                </p>
               
            </div>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_texteditor">
            <div id="cm_editor" class="w-100">
                
            </div>
        </div>
        
    </div>
    <div class="v-splitter"></div>
    <div class="d-flex flex-row flex-justify-start flex-align-start w-100"
        style="height: 40%;">
        <div id="mui_dtdlist" 
            class="d-flex h-100">
            <ul v-if="dtd != null"
                class="w-100 tag-list">

                <li v-on:click="update_tag_table()"
                    class="tag-list-row tag-list-row-all-tags d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == '__all__'}">
                    <div class="tag-list-row-name">
                        <span class='mif-folder fg-red'></span>
                        All Tags
                    </div>
                    <div class="mr-1">
                        {{ count_n_tags(null) }}
                    </div>
                </li>

                <!-- show all etags -->
                <li v-for="etag in dtd.etags"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == etag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="update_tag_table(etag)">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + etag.name">
                        </i>
                        <span v-if="etag.hasOwnProperty('shortcut')"
                            class="badge-shortcut mr-1">
                            {{ etag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(etag)">
                            
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null && etag.is_non_consuming"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty entity tag"
                                v-on:click="add_empty_etag(etag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(etag)">
                            {{ count_n_tags(etag) }}
                        </div>
                    </div>
                </li>

                <!-- show all link tags -->
                <li v-for="ltag in dtd.ltags"
                    class="tag-list-row d-flex flex-row flex-justify-between"
                    v-bind:class="{'tag-list-row-actived':display_tag_name == ltag.name}">
                    <div class="tag-list-row-name"
                        v-on:click="update_tag_table(ltag)">
                        <i class="fa fa-link"
                            v-bind:class="'fg-tag-' + ltag.name">
                        </i>
                        <span v-if="ltag.hasOwnProperty('shortcut')"
                            class="badge-shortcut mr-1">
                            {{ ltag.shortcut }}
                        </span>
                        <span v-html="make_html_bold_tag_name(ltag)">
                            
                        </span>
                    </div>
                    <div class="mr-1 d-flex flex-row">
                        <div v-if="ann_idx != null"
                            class="mr-2">
                            <button class="btn-xs"
                                title="Add an empty link tag"
                                v-on:click="add_empty_ltag(ltag)">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                        <div v-bind:class="'tag-list-row-count-'+count_n_tags(ltag)">
                            {{ count_n_tags(ltag) }}
                        </div>
                    </div>

                </li>

            </ul>
        </div>

        <div class="h-100 h-splitter">
        </div>

        <div id="mui_annlist" 
            class="d-flex flex-justify-start flex-align-start h-100">
            <table v-if="dtd!=null && ann_idx != null" class="tag-table w-100 mt-0 mb-0">
                <thead>
                    <tr>
                        <th class="tag-name">Tag</th>
                        <th class="tag-id">ID</th>
                        <th class="tag-spans">Spans</th>
                        <th class="tag-text">Text</th>
                        <th class="tag-attr">Attributes</th>
                    </tr>
                </thead>

                <tbody style="overflow-y: auto;">
                    <tr v-for="tag, tag_idx in anns[ann_idx].tags"
                        v-if="tag.tag == display_tag_name || display_tag_name == '__all__'"
                        v-bind:id="'tag-table-row-' + tag.id"
                        class="tag-table-row">
                        <td v-on:click="on_click_tag_table_row(tag)">
                            <div class="d-flex flex-row flex-justify-between">
                                <div>
                                    <i v-if="get_tag_def(tag.tag).type == 'etag'" 
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    <i v-else class="fa fa-link"
                                        class="fa fa-tag"
                                        v-bind:class="'fg-tag-' + tag.tag">
                                    </i>
                                    {{ tag.tag }}
                                </div>

                                <div class="mr-2">
                                    <button class="btn btn-xs btn-red"
                                        title="Delete this tag"
                                        v-on:click="del_tag(tag.id)">
                                        <i class="fa fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </td>

                        <td class="c-pointer"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span>
                                {{ tag.id }}
                            </span>
                        </td>

                        <td v-bind:class="{'c-pointer': !is_etag_doc_level(tag)}"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span v-if="tag.hasOwnProperty('_annotator')"
                                v-bind:class="'iaa-annotator-' + tag._annotator"
                                class="mr-2">
                                <i v-if="tag._annotator == 'AB'" class="fa fa-user-check"></i>
                                <i v-else class="fa fa-user-edit"></i>
                                {{ tag._annotator }}
                            </span>
                            <!-- <span v-else
                                class="mr-2">
                                &nbsp;
                            </span> -->
                                    
                            <span v-if="is_etag_doc_level(tag)">
                                DOCUMENT
                            </span>
                            <span v-else-if="is_etag(tag)"
                                class="c-pointer">
                                {{ tag.spans }}
                            </span>
                            <span v-else
                                class="c-pointer">
                                LINK
                            </span>

                            <span v-if="tag.hasOwnProperty('_annotator')"
                                class="box-annotator-actions">
                                <!-- this is a adjudication tag -->
                                <br>
                                <button class="btn btn-xs btn-green"
                                    title="Set this tag as both agreed"
                                    v-if="tag._annotator != 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'AB')">
                                    <i class="far fa-handshake"></i>
                                    Both A and B
                                </button>
                                

                                <button class="btn btn-xs btn-orange"
                                    title="Set annotator to A"
                                    v-if="tag._annotator == 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'A')">
                                    <i class="fas fa-user-edit"></i>
                                    Only A
                                </button>

                                <button class="btn btn-xs btn-blue"
                                    title="Set annotator to B"
                                    v-if="tag._annotator == 'AB'"
                                    v-on:click="set_tag_annotator(tag.id, 'B')">
                                    <i class="fas fa-user-edit"></i>
                                    Only B
                                </button>
                            </span>
                        </td>

                        <td class="td-text c-pointer"
                            v-on:click="on_click_tag_table_row(tag)">
                            <span v-if="is_etag(tag)">
                                {{ tag.text }}
                            </span>
                            <span v-else>
                            </span>
                        </td>

                        <td class="d-flex flex-row flex-justify-start flex-align-start flex-wrap">
                            <div v-for="(attlist, attlist_idx) in dtd.tag_dict[tag.tag].attlists"
                                v-if="!['id','spans','text','tag'].contains(attlist.name)"
                                class="tag-attr-box mr-1 d-flex flex-column">
                                <div class="tag-attr-name">
                                    {{ attlist.name }}
                                    <span v-if="attlist.require == 'REQUIRED'"
                                        class="clr-red">
                                        *
                                    </span>
                                    <span v-else>
                                        &nbsp;
                                    </span>
                                </div>
                                
                                <div v-if="attlist.vtype == 'list'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @change="on_change_attr_value">
                                        <option v-for="val in attlist.values"
                                            v-bind:value="val">
                                            {{ val }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else-if="attlist.vtype == 'text'">
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name"
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @input="on_input_attr_value">
                                </div>
                                <div v-else-if="attlist.vtype == 'idref'">
                                    <select class="tag-attr-select"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @change="on_change_idref_value">
                                        <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                            v-bind:value="s_etag.id">
                                            {{ s_etag.id }}
                                            |
                                            {{ s_etag.tag }}
                                            -
                                            {{ s_etag.text }}
                                        </option>
                                        <option value="">-- EMPTY --</option>
                                    </select>
                                </div>
                                <div v-else>
                                    <input type="text"
                                        class="tag-attr-input"
                                        v-bind:id="'form-'+ann_idx+'-' + anns[ann_idx].tags[tag_idx].id + '-' + attlist.name" 
                                        v-model="anns[ann_idx].tags[tag_idx][attlist.name]"
                                        @input="on_input_attr_value">
                                </div>
                            </div>
                            
                            
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div v-if="is_linking"
        ref="pan_working_tag_box"
        id="pan_working_tag"
        class="d-flex flex-column">
        <div class="p-2 mb-1"
            id="pan_working_tag_title"
            @mousedown="dragMouseDown">
            Creating a Link Tag
            <b>{{ linking_tag.tag }}</b>
        </div>
        <div class="d-flex flex-row p-1 border-bottom">
            <button class="btn-xs mr-1"
                title="Using the following values to create a link tag"
                v-on:click="done_linking();">
                <i class="fa fa-check-circle"></i>
                Done Linking
            </button>
            <button class="btn-xs"
                title="Stop creating a link tag and drop the following values"
                v-on:click="cancel_linking();">
                <i class="far fa-times-circle"></i>
                Cancel Linking
            </button>
        </div>
        <div class="d-flex flex-column p-1 pr-2">
            <div v-for="attlist in linking_tag_def.attlists"
                class="d-flex flex-row ltag-attr-row p-1 mb-1">
                <div class="d-flex ltag-attr-name pr-1">
                    &nbsp;- 
                    {{ attlist.name }}
                </div>
                <div class="d-flex ltag-attr-value">
                    <div v-if="attlist.vtype == 'idref'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attlist.name]">
                            <option v-for="s_etag, s_etag_idx in get_tags_by_type(anns[ann_idx], dtd, 'etag')"
                                v-bind:value="s_etag.id">
                                {{ s_etag.id }}
                                |
                                {{ s_etag.tag }}
                                -
                                {{ s_etag.text }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else-if="attlist.vtype == 'text'"
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attlist.name]">
                    </div>
                    <div v-else-if="attlist.vtype == 'list'"
                        class="w-100">
                        <select class="tag-attr-select"
                            v-model="linking_tag[attlist.name]">
                            <option v-for="val in attlist.values"
                                v-bind:value="val">
                                {{ val }}
                            </option>
                            <option value="">-- EMPTY --</option>
                        </select>
                    </div>
                    <div v-else
                        class="w-100">
                        <input type="text"
                            class="tag-attr-input"
                            v-model="linking_tag[attlist.name]">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <!-- the ui for corpus -->
    <div v-show="section=='corpus'" id="main_ui" 
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

        <div class="box w-100">
            <div class="box-header">
                <h4>
                    <i class="fa fa-list-ul"></i>
                    MedTagger Files
                </h4>
            </div>

            <div v-if="converter_corpus_task == 'medtagger'"
                class="box-body" 
                style="overflow-y: auto; height: 100%;">
                <p>
                    For converting the MedTagger format, 
                    you need to prepare the following two types of files.
                    Please make sure the file names are matched.
                </p>

                <div class="d-flex flex-row h-100">


                    <div id="mui_converter_medtagger_txt_filelist"
                        class="converter-dropzone mr-2">
                        <h5>
                            <i class="far fa-file-alt"></i>
                            Raw .txt Text Files
                        </h5>
                        <p v-if="converter_corpus_medtagger_txt_files.length == 0">
                            Drag and drop the <b>.txt</b> files or the folder contains <b>.txt</b> files in this box
                        </p>
                        <p v-else>
                            Loaded <b>{{ converter_corpus_medtagger_txt_files.length }} </b> text files (.txt)
                        </p>

                        <div v-if="converter_corpus_medtagger_txt_files.length != 0"
                            class="d-flex flex-column converter-file-list">
                            <div v-for="f in converter_corpus_medtagger_txt_files"
                                class="converter-file-row">
                                {{ f.fh.name }}
                            </div>
                        </div>
                    </div>
    


                    <div id="mui_converter_medtagger_ann_filelist"
                        class="converter-dropzone mr-2">
                        <h5>
                            <i class="far fa-file-code"></i>
                            MedTagger .ann Files
                        </h5>
                        <p v-if="converter_corpus_medtagger_ann_files.length == 0">
                            Drag and drop the <b>.ann</b> files or the folder contains <b>.ann</b> files in this box
                        </p>
                        <p v-else>
                            Loaded <b>{{ converter_corpus_medtagger_ann_files.length }} </b> MedTagger files (.ann)
                        </p>

                        <div v-if="converter_corpus_medtagger_ann_files.length != 0"
                            class="d-flex flex-column converter-file-list">
                            <div v-for="f in converter_corpus_medtagger_ann_files"
                                class="converter-file-row">
                                <span class="bg-blue fg-white mr-1 pl-1"
                                    :title="f.lines.length + ' lines of records'">
                                    {{ f.lines.length }}
                                </span>
                                {{ f.fh.name }}
                            </div>
                        </div>
                    </div>
<!-- 
                    <div>
                        <button class="converter-button"
                            v-on:click="convert_from_medtagger_txt_and_ann">
                            Convert 
                            <br>
                            the given files to 
                            <br>
                            <b>MedTator XML</b> Format
                        </button>
                    </div>
     -->
                    <div v-if="converter_corpus_medtagger_results.length != 0"
                        class="converter-dropzone mr-2 bd-green">
                        <h5 class="fg-green">
                            <i class="far fa-file-code"></i>
                            Generated MedTator XML Files
                        </h5>
                        
                        <p>
                            Converted <b>{{ converter_corpus_medtagger_results.length }} </b> pairs to xml files
                        </p>

                        <div class="d-flex flex-column converter-file-list">
                            <div v-for="obj in converter_corpus_medtagger_results"
                                class="converter-file-row">
                                <span class="bg-green fg-white mr-1 pl-1"
                                    :title="'Converted ' + obj.medtator_ann.tags.length + ' tags'">
                                    {{ obj.medtator_ann.tags.length }}
                                </span>
                                {{ obj.medtator_ann._filename }} 
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- /.box -->
        

    </div>
</div>

    <!-- the ui for ruleset / export -->
    <div v-show="section=='ruleset'" id="main_ui"
    class="main-ui container-fluid">
    <div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">
        <div id="mui_ruleset_result" class="d-flex w-100 h-100">
            <div class="box w-100">
                <div class="box-header">
                    <h4>
                        <i class="far fa-file-alt"></i>
                        Export Preview
                    </h4>
                </div>

                <div v-if="export_text != null"
                    class="box-body h-100">

                    <textarea v-model="export_text" class="w-100 h-100" style="font-family: 'Courier New', Courier, monospace;"></textarea>
                    
                </div>
            </div>
            <!-- /.box -->
        </div>
    </div>
</div>

    <!-- the ui for iaa -->
    <div v-show="section=='iaa'" id="main_ui" 
    class="main-ui container-fluid">
    <div v-if="iaa_display_measure == 'f1'"
        class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

        <div id="mui_iaa_summary" class="d-flex h-100 mr-1">
            <div v-if="dtd != null && iaa_dict != null" class="box h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-list-ul"></i>
                        IAA: 
                    </h4>
                    <div>
                        <select class="iaa-select-sm"
    v-model="iaa_display_measure">
    <option value="f1">F1 Score</option>
    <option value="cohen_kappa">Cohen's Kappa Coefficient</option>
</select>
                    </div>
                </div>
                <div class="box-body">

                    <div>
                        <div class="iaa-row iaa-row-header d-flex flex-row">
                            <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                Tag Name
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                                F1
                            </div>
                        </div>

                        <!-- special for the overall result -->
                        <div class="iaa-row d-flex flex-row"
                            v-bind:class="{'iaa-row-actived': iaa_display_tag_name == '__all__'}"
                            v-on:click="iaa_display_tag_name = '__all__'">
                            <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                OVERALL
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                                <div v-bind:style="'width:' + per2width(iaa_dict.all.f1) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="ml-1">
                                    <span style="font-size: 1.2em; font-weight: bold;">
                                        {{ to_fixed(iaa_dict.all.f1) }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- for each tag -->
                        <div v-for="etag in dtd.etags"
                            class="iaa-row d-flex flex-row"
                            v-bind:class="{'iaa-row-actived': iaa_display_tag_name == etag.name}"
                            v-on:click="iaa_display_tag_name = etag.name">
                            <div v-bind:title="etag.name" 
                                class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + etag.name">
                                </i>
                                <span>
                                    {{ etag.name }}
                                </span>
                            </div>
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <div v-bind:style="'width:' + per2width(iaa_dict.tag[etag.name].f1) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="ml-1">
                                    {{ to_fixed(iaa_dict.tag[etag.name].f1) }}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-3">
                        <p>
                            Text Matched Files: <b>{{ iaa_dict.stat.matched_hashcodes.length }}</b>
                        </p>
                        <p>
                            Duplicated Files: <b>{{ iaa_dict.stat.duplicates.length }}</b>
                        </p>
                        <p>
                            Unmatched Files: <b>{{ iaa_dict.stat.unmatched.length }}</b>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div id="mui_iaa_anns" class="d-flex h-100 ml-1 mr-1">
            <div v-if="dtd != null && iaa_dict != null" class="box w-100 h-100">
                <div class="box-header">

                    <div>
                        <button class="btn-xs mr-1 dropdown-toggle"
                            style="margin-left: 0;">
                            {{ iaa_get_sort_by_label(iaa_get_sort_by()) }}
                        </button>
                        <ul class="ribbon-dropdown text-left" 
                            data-role="dropdown" 
                            data-duration="100">
                            <li title="Sort the file list by the A's file name A-Z"
                                v-on:click="iaa_sort_filelist_by('a.alphabet')">
                                <a href="javascript:void(0);">By A's file name (A->Z)</a>
                            </li>
                            <li title="Sort the file list by the A's file name Z-A"
                                v-on:click="iaa_sort_filelist_by('a.alphabet_r')">
                                <a href="javascript:void(0);">By A's file name (Z->A)</a>
                            </li>
    
                            <li title="Sort the file list by the B's file name A-Z"
                                v-on:click="iaa_sort_filelist_by('b.alphabet')">
                                <a href="javascript:void(0);">By B's file name (A->Z)</a>
                            </li>
                            <li title="Sort the file list by the B's file name Z-A"
                                v-on:click="iaa_sort_filelist_by('b.alphabet_r')">
                                <a href="javascript:void(0);">By B's file name (Z->A)</a>
                            </li>
    
                            <li title="Sort the file list by F1 Score 0-1"
                                v-on:click="iaa_sort_filelist_by('f1_asc')">
                                <a href="javascript:void(0);">By F1 Score (0->1)</a>
                            </li>
                            <li title="Sort the file list by F1 Score 1-0"
                                v-on:click="iaa_sort_filelist_by('f1_desc')">
                                <a href="javascript:void(0);">By F1 Score (1->0)</a>
                            </li>
    
                            <li class="divider"></li>
    
                            <li title="Sort the file list by the number of annotated tags"
                                v-on:click="iaa_sort_filelist_by('default')">
                                <a href="javascript:void(0);">By default import sequence</a>
                            </li>
                        </ul>
                    </div>
                    <h4>
                        <i class="fa fa-list"></i>
                        Annotation Files
                    </h4>
                </div>

                <div class="box-body">

                    <div class="iaa-row iaa-row-header d-flex flex-row">
                        <div class="iaa-bar-filename-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                            File names
                        </div>
                        <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start">
                            <span v-if="iaa_display_tag_name == '__all__'">
                                OVERALL
                            </span>
                            <span v-else>
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + iaa_display_tag_name">
                                </i>
                                <span>
                                    {{ iaa_display_tag_name }}
                                </span>
                            </span>
                            &nbsp;
                            <span>
                                F1
                            </span>
                        </div>
                    </div>

                    <div v-for="v_ann in iaa_sort_v_anns(iaa_dict)"
                        class="iaa-row d-flex flex-row"
                        v-bind:class="{'iaa-row-actived': iaa_display_hashcode == v_ann.ann_hashcode}"
                        v-on:click="iaa_display_hashcode = v_ann.ann_hashcode">
                        <div class="iaa-bar-filename-box d-flex flex-column flex-align-center flex-justify-start mr-1">
                            <div class="iaa-bar-filename w-100">
                                A: {{ iaa_dict.ann[v_ann.ann_hashcode].anns[0]._filename }}
                            </div>
                            <div class="iaa-bar-filename w-100">
                                B: {{ iaa_dict.ann[v_ann.ann_hashcode].anns[1]._filename }}
                            </div>
                            <div class="iaa-bar-filename w-100">
                                <!-- <span title="Set check"
                                    v-on:click="iaa_gs_dict[v_ann.ann_hashcode].ann._has_star = !iaa_gs_dict[v_ann.ann_hashcode].ann._has_star">
                                    <span v-if="iaa_gs_dict[v_ann.ann_hashcode].ann._has_star">
                                        <i class="fa fa-check-circle fg-emerald"></i>
                                    </span>
                                    <span v-else>
                                        <i class="far fa-circle"></i>
                                    </span>
                                </span> -->
                                <a href="javascript:void(0);"
                                    v-on:click="download_gs_file(v_ann.ann_hashcode)"
                                    v-bind:title="'Download adjudicated file ' + iaa_gs_dict[v_ann.ann_hashcode].ann._filename"
                                    class="btn btn-xs btn-dense btn-black">
                                    <i class="far fa-arrow-alt-circle-down"></i>
                                </a>
                                
                                GS: {{ iaa_gs_dict[v_ann.ann_hashcode].ann._filename }}
                            </div>
                        </div>

                        <div class="d-flex flex-column">
                            <div class="iaa-bar-box d-flex flex-row flex-align-center flex-justify-start mr-1">
                                <div v-bind:style="'width:' + per2width(get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst)['f1']) + 'px'"
                                    class="iaa-bar">
                                    &nbsp;
                                </div>
                                <div class="iaa-bar-value ml-1">
                                    {{ to_fixed(get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst)['f1']) }}
                                </div>
                            </div>
                            <div class="iaa-file-cm-box">
                                <span class="mr-2">
                                    <span class="iaa-op-50">AB: </span>
                                    {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.tp }}
                                </span>
                                <span class="mr-2">
                                    <span class="iaa-op-50">A+: </span>
                                    {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.fp }}
                                </span>
                                <span class="mr-2">
                                    <span class="iaa-op-50">B+: </span>
                                    {{ get_rst(iaa_dict.ann[v_ann.ann_hashcode].rst).cm.fn }}
                                </span>
                            </div>
                            <div class="iaa-file-gs-box">
                                <span class="mr-2">
                                    <span class="iaa-op-50">
                                        <span v-if="iaa_display_tag_name == '__all__'">
                                            OVERALL
                                        </span>
                                        <span v-else>
                                            {{ iaa_display_tag_name }}
                                        </span>
                                        in GS:
                                    </span> 
                                    {{ count_gs_tags(v_ann.ann_hashcode) }}
                                </span>
                            </div>
                        </div>
                    </div>

                </div>

            </div>
        </div>

        <div id="mui_iaa_tags" class="d-flex h-100 ml-1">
            <div v-if="dtd != null && iaa_dict != null && iaa_display_hashcode != null" class="box w-100 h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-tag"></i>
                        Annotated Tags
                    </h4>
                </div>

                <div v-if="iaa_display_hashcode != null"
                    class="box-body d-flex flex-column">
                    <div class="w-100 d-flex flex-row">

                        <div class="iaa-tag-detail-header iaa-tag-detail-a"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <i class="fa fa-user"></i>
                            A 
                            {{ iaa_dict.ann[iaa_display_hashcode].anns[0]._filename }}
                        </div>

                        <div class="iaa-tag-detail-header"
                            :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                            <i class="fa fa-user"></i>
                            B
                            {{ iaa_dict.ann[iaa_display_hashcode].anns[1]._filename }}
                        </div>

                        <div v-if="iaa_display_adj_panel"
                            v-on:click="iaa_gs_dict[iaa_display_hashcode].ann._has_star = !iaa_gs_dict[iaa_display_hashcode].ann._has_star"
                            title="Set check"
                            class="iaa-tag-detail-header iaa-tag-detail-g iaa-tag-detail-g-header iaa-w-20">
                            <span v-if="iaa_gs_dict[iaa_display_hashcode].ann._has_star">
                                <i class="fa fa-check-circle fg-emerald"></i>
                            </span>
                            <span v-else>
                                <i class="far fa-circle"></i>
                            </span>
                            <span>
                                {{ iaa_gs_dict[iaa_display_hashcode].ann._filename }}
                            </span>
                            
                        </div>
                        
                    </div>

                    <div v-for="tag_rst, tag_name in iaa_dict.ann[iaa_display_hashcode].rst.tag"
                        v-if="iaa_display_tag_name == '__all__' || iaa_display_tag_name == tag_name"
                        class="w-100 mb-2">
                            
                        <div class="iaa-tag-name d-flex flex-row">
                            <div class="iaa-tag-name-ab mr-1"
                                :class="{'iaa-w-80': iaa_display_adj_panel, 'iaa-w-100': !iaa_display_adj_panel}">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + tag_name">
                                </i>
                                <span class="mr-2">
                                    {{ tag_name }}
                                </span>
                                <span class="mr-2">
                                    AB: {{ tag_rst.cm.tp }}
                                </span>
                                <span class="mr-2">
                                    A+: {{ tag_rst.cm.fp }}
                                </span>
                                <span class="mr-2">
                                    B+: {{ tag_rst.cm.fn }}
                                </span>
                            </div>

                            <div v-if="iaa_display_adj_panel"
                                class="iaa-tag-name-g iaa-tag-detail-g iaa-w-20">
                                <i class="fa fa-tag mr-1"
                                    v-bind:class="'fg-tag-' + tag_name">
                                </i>
                                <span class="mr-2">
                                    {{ tag_name }}
                                </span>
                                <span v-if="iaa_gs_dict != null">
                                    Total: {{ count_iaa_gs_tag_notnull(iaa_gs_dict[iaa_display_hashcode].rst[tag_name]) }}
                                </span>
                                <span v-else>
                                    &nbsp;
                                </span>
                            </div>
                        </div>

                        <div v-if="iaa_display_tags_tp"
                            class="iaa-tag-rsts-tp w-100">
                            <!-- last, show the TP group -->
                            <div v-for="tags_tp, tag_idx in tag_rst.cm.tags.tp"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:from="'A'"
                                        v-bind:tag="tags_tp[0]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>
                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:from="'B'"
                                        v-bind:tag="tags_tp[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>
                                <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'tp'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].tp[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>

                                </div>
                            </div>

                        </div>                            

                        <div class="iaa-tag-rsts-fp w-100">
                            <!-- first, show the FP group -->
                            <div v-for="tags_fp, tag_idx in tag_rst.cm.tags.fp"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:from="'A'"
                                        v-bind:tag="tags_fp[0]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[0]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-if="tags_fp[1] != null"
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:from="'B'"
                                        v-bind:tag="tags_fp[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div v-if="iaa_display_adj_panel && iaa_gs_dict != null"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fp'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fp[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>
                                </div>
                            </div>
                        </div>

                        <div class="iaa-tag-rsts-fn w-100">
                            <!-- second, show the FN group -->
                            <div v-for="tags_fn, tag_idx in tag_rst.cm.tags.fn"
                                class="iaa-tag-detail w-100 d-flex flex-row">
                                <div class="iaa-tag-detail-a"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    &nbsp;
                                </div>
                                <div class="iaa-tag-detail-b"
                                    :class="{'iaa-w-40': iaa_display_adj_panel, 'iaa-w-50': !iaa_display_adj_panel}">
                                    <iaa-tag-info
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fn'"
                                        v-bind:from="'B'"
                                        v-bind:tag="tags_fn[1]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_dict.ann[iaa_display_hashcode].anns[1]"
                                        v-bind:dtd="dtd"
                                        v-bind:iaa_display_tags_context="iaa_display_tags_context"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info>
                                </div>

                                <div v-if="iaa_display_adj_panel"
                                    class="iaa-tag-detail-g iaa-w-20">
                                    <iaa-tag-info-gs
                                        v-bind:hashcode="iaa_display_hashcode"
                                        v-bind:cm="'fn'"
                                        v-bind:tag_obj="iaa_gs_dict[iaa_display_hashcode].rst[tag_name].fn[tag_idx]"
                                        v-bind:tag_idx="tag_idx"
                                        v-bind:ann="iaa_gs_dict[iaa_display_hashcode].ann"
                                        v-bind:dtd="dtd"
                                        v-bind:force_update="force_module_update"
                                    ></iaa-tag-info-gs>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div v-else-if="iaa_display_measure == 'cohen_kappa'"
        class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">
        
        <div id="mui_iaa_cohenk_summary"
            class="d-flex h-100 mr-1">
            <div v-if="dtd != null && iaa_dict != null && iaa_dict.all.hasOwnProperty('cohen_kappa')" class="box h-100">
                <div class="box-header">
                    <h4>
                        <i class="fa fa-list-ul"></i>
                        IAA: 
                    </h4>
                    
                    <div>
                        <select class="iaa-select-sm"
    v-model="iaa_display_measure">
    <option value="f1">F1 Score</option>
    <option value="cohen_kappa">Cohen's Kappa Coefficient</option>
</select>
                    </div>
                </div>

                <div class="box-body d-flex flex-column">
                    <div>
    Overall Cohen's Kappa: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.kappa) }} 
    </b>
    &nbsp;
    &nbsp;
    Percentage Agreement: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.Po) }}
    </b>

    <br>
    
    <i class="ml-1">TP</i>: <b>{{ iaa_dict.all.cm.tp }}</b>
    &nbsp;
    <i class="ml-1">FP</i>: <b>{{ iaa_dict.all.cm.fp }}</b>
    &nbsp;
    <i class="ml-1">FN</i>: <b>{{ iaa_dict.all.cm.fn }}</b>
    &nbsp;
    <i class="ml-1">N</i>: <b>{{ iaa_dict.all.cohen_kappa.N }}</b>
    <br>

    <i class="ml-1">Po</i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.Po) }}</b>
    &nbsp;
    <i class="ml-1">Pe</i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.Pe) }}</b>
    &nbsp;
    <i class="ml-1">SE<sub>k</sub></i>: <b>{{ to_fixed(iaa_dict.all.cohen_kappa.SE_k) }}</b>
    &nbsp;
    <i class="ml-1">95% CI</i>: 
    <b>
        {{ to_fixed(iaa_dict.all.cohen_kappa.lower) }}, 
        {{ to_fixed(iaa_dict.all.cohen_kappa.upper) }}
    </b>

</div>

<!-- 
<div class="mr-2">
    <p>
        Cohen's Kappa of each document
    </p>

    <div v-for="ann_rst, ann_hashcode in iaa_dict.ann"
        v-bind:class="{'iaa-row-actived': iaa_display_hashcode == ann_hashcode}"
        class="iaa-row d-flex flex-row">
        <div class="iaa-bar-name-box d-flex flex-row flex-align-center flex-justify-start mr-1">
            {{ ann_rst.anns[0]._filename }}
        </div>
        <div>
            <b>
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.kappa ) }}
            </b>&nbsp;
            (
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.lower) }} , 
                {{ to_fixed(ann_rst.rst.all.cohen_kappa.upper) }}
            )
        </div>
    </div>


</div> 
-->

<div class="mr-2">
    <table id="table_cohen_kappa_confusion_matrix" class="doctag-table">
        <thead>
            <tr style="background: white;">
                <th style="border: 0;"
                    colspan="2">
                    &nbsp;
                </th>
                <th v-bind:colspan="dtd.etags.length+2">
                    <b>
                        Annotator B
                    </b>
                </th>
            </tr>
            <tr>
                <th>&nbsp;</th>
                <th>&nbsp;</th>
                <th v-for="tag_def in dtd.etags"
                    v-bind:class="'fg-tag-' + tag_def.name">
                    <span class="rotate-90">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + tag_def.name">
                        </i>
                        {{ tag_def.name }}
                    </span>
                </th>
                <!-- 
                <th v-for="tag_def in dtd.ltags"
                    v-bind:class="'fg-tag-' + tag_def.name">
                    <span class="rotate-90">
                        <i class="fa fa-link"
                            v-bind:class="'fg-tag-' + tag_def.name">
                        </i>
                        {{ tag_def.name }}
                    </span>
                </th> 
                -->
    
                <th>EMPTY</th>
                <th>
                    <i>P<sub>b</sub></i>
                </th>
            </tr>
        </thead>
        <tbody>
            <tr v-for="tag_def_row, row_idx in dtd.etags">
                <td v-if="row_idx == 0"
                    style="vertical-align: middle; padding: 10px;"
                    v-bind:rowspan="dtd.etags.length+2">
                    <b>Annotator A</b>
                </td>
                <td v-bind:class="'fg-tag-' + tag_def_row.name">
                    <span class="txt-bold">
                        <i class="fa fa-tag"></i>
                        {{ tag_def_row.name }}
                    </span>
                </td>
                <td v-for="tag_def_col in dtd.etags">
                    <span v-if="tag_def_col.name == tag_def_row.name">
                        {{ iaa_dict.tag[tag_def_row.name].cm.tp }}
                    </span>
                    <span v-else>
                        &nbsp;
                    </span>
                </td>
                <td class="clr-grey">
                    {{ iaa_dict.tag[tag_def_row.name].cm.fp }}
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.b[tag_def_row.name]) }}
                    </span>
                </td>
            </tr>
    
            <tr>
                <td class="txt-bold">EMPTY</td>
                <td v-for="tag_def_col in dtd.etags"
                    class="clr-grey">
                    <span>
                        {{ iaa_dict.tag[tag_def_col.name].cm.fn }}
                    </span>
                </td>
                <td class="clr-grey">
                    0
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.b['_EMPTY_']) }}
                    </span>
                </td>
            </tr>
            <tr>
                <td class="txt-bold">
                    <i>P<sub>a</sub></i>
                </td>
                <td v-for="tag_def_col in dtd.etags"
                    class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.a[tag_def_col.name]) }}
                    </span>
                </td>
                <td class="txt-italic">
                    <span>
                        {{ to_fixed(iaa_dict.all.cohen_kappa.Pes.a['_EMPTY_']) }}
                    </span>
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        
        
    </p>
</div>
                </div>
            </div>
        </div>
    </div>
</div>
    
    <!-- the ui for statistics -->
    <div v-show="section=='statistics'" id="main_ui" 
    class="main-ui container-fluid">
<div class="w-100 d-flex flex-row" style="height: calc(100% + 10px);">

<!-- stat summary -->
<div id="mui_stat_summary" class="d-flex h-100">
    <div class="box w-100">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Corpus Summary
            </h4>
        </div>

        <div v-if="dtd != null && anns.length != 0"
            class="box-body"
            style="overflow-y: auto;">

            <div v-for="stat_item in stat_summary"
                class="stat-item-row box-body-item d-flex flex-row flex-justify-between">

                <!-- the stat label -->
                <div v-if="stat_item[2] == null"
                    class="stat-item-label stat-item-label-lg">
                    <span v-html="stat_item[0]"
                        :title="stat_item[0]">
                    </span>: 
                </div>
                <div v-else
                    class="stat-item-label">
                    <span v-html="stat_item[0]"
                        :title="stat_item[0]">
                    </span>: 
                </div>

                <!-- the stat result -->
                <div v-if="stat_item[2] == null"
                    :title="stat_item[0] + ': ' + stat_item[1]"
                    class="stat-item-value-sm mr-2 text-align">
                    <span >
                        {{ stat_item[1] }}
                    </span>
                </div>
                <div v-else-if="stat_item[2].stat_type == 'tag_count'"
                    :title="stat_item[0] + ': ' + stat_item[1]"
                    class="stat-item-value mr-2 d-flex flex-row flex-align-center flex-justify-end">
                    <div class="mr-1">
                        {{ stat_item[1] }}
                    </div>
                    <div class="iaa-bar"
                        v-bind:class="'mark-tag-' + stat_item[2].tag"
                        v-bind:style="{width: stat_value2width(stat_item[1], stat_docs_by_tags.stat.max_by_tag) + 'px', }">
                    </div>
                </div>
            </div>
            
        </div>
    </div>
    <!-- /.box -->
</div>

<!-- stat details -->
<div id="mui_stat_details" class="d-flex ml-2">

<div class="w-100 d-flex flex-row flex-wrap h-100"
        style="overflow-y: auto;">
    <div class="box w-100 mb-2">
        <div class="box-header">
            <h4>
                <i class="fas fa-table"></i>
                Annotation Overview
            </h4>
        </div>
        <div v-if="dtd != null && anns.length > 0"
            class="box-body">
            <table class="doctag-table" style="float: left;">
                <thead>
                    <tr>
                        <th>File Name</th>
                        <th>Total</th>
                        <th v-for="tag_def in dtd.etags"
                            v-bind:class="'fg-tag-' + tag_def.name">
                            <span class="rotate-90">
                                <i class="fa fa-tag"
                                    v-bind:class="'fg-tag-' + tag_def.name">
                                </i>
                                {{ tag_def.name }}
                            </span>
                        </th>
                        <th v-for="tag_def in dtd.ltags"
                            v-bind:class="'fg-tag-' + tag_def.name">
                            <span class="rotate-90">
                                <i class="fa fa-link"
                                    v-bind:class="'fg-tag-' + tag_def.name">
                                </i>
                                {{ tag_def.name }}
                            </span>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="stat, stat_idx in stat_docs_by_tags.rs">
                        <td v-if="stat_idx == 0"
                            class="td-summary">
                            {{ stat.file_name }}
                        </td>
                        <td v-else
                            class="td-filename"
                            title="Check this file in the Annotation tab"
                            v-on:click="show_ann_file(stat.file_name)">
                            {{ stat.file_name }}
                        </td>
                        <td>
                            {{ stat._total_tags }}
                        </td>
                        <td v-for="tag_def in dtd.etags">
                            <span v-if="stat_idx == 0"
                                class="td-count"
                                v-bind:class="'td-count-' + stat[tag_def.name]">
                                {{ stat[tag_def.name] }}
                            </span>
                            <span v-else
                                class="td-count cursor-pointer"
                                title="Click to check these tags"
                                v-bind:style="'background-color:'+ stat_value2bgcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + '; color:' + stat_value2ftcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + ';'"
                                v-bind:class="'td-count-' + stat[tag_def.name]"
                                v-on:click="on_click_stat_ann_tag(stat.file_name, tag_def.name)">
                                {{ stat[tag_def.name] }}
                            </span>
                        </td>
                        <td v-for="tag_def in dtd.ltags">
                            <span v-if="stat_idx == 0"
                                class="td-count"
                                v-bind:class="'td-count-' + stat[tag_def.name]">
                                {{ stat[tag_def.name] }}
                            </span>
                            <span v-else
                                class="td-count cursor-pointer"
                                title="Click to check these tags"
                                v-bind:style="'background-color:'+ stat_value2bgcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + '; color:' + stat_value2ftcolor(stat[tag_def.name], stat_docs_by_tags.stat.max_by_ann_tag) + ';'"
                                v-bind:class="'td-count-' + stat[tag_def.name]"
                                v-on:click="on_click_stat_ann_tag(stat.file_name, tag_def.name)">
                                {{ stat[tag_def.name] }}
                            </span>
                        </td>
                    </tr>
                </tbody>
            </table>

            <!-- the tag list of selected file and concept -->
            <div v-if="display_stat_doc_sum_selected != null && has_doc_sum_selected_tags()"
                class="d-flex flex-column ml-2 stat-doc-sum-tags-box" 
                style="float: left; position: sticky; top: 0;">
                <div class="stat-doc-sum-tags-header">
                    <i class="fa fa-tags"></i>
                    {{ display_stat_doc_sum_selected.file_name }} - 
                    <span v-bind:class="'fg-tag-' + display_stat_doc_sum_selected.tag_name">
                        <i class="fa fa-tag"
                            v-bind:class="'fg-tag-' + display_stat_doc_sum_selected.tag_name">
                        </i>
                        {{ display_stat_doc_sum_selected.tag_name }}
                    </span>
                    <span>
                        {{ stat_doc_sum_selected_tags.length }} tags
                    </span>
                </div>

                <div class="stat-doc-sum-tags-body">
                    <div v-for="tag in stat_doc_sum_selected_tags"
                        class="d-flex flex-row flex-wrap flex-align-end mb-2">
                        <div class="iaa-tag-detail-info-text-ab mr-2">
                            <!-- <span class="mr-1"
                                v-bind:class="'mark-tag-' + tag.tag">
                                
                            </span> -->
                            {{ tag.id }}
                        </div>

                        <div class="mr-1 ml-1 d-flex flex-column">
                            <div class="iaa-tag-attlist-name">
                                {{ get_tag_spans_text(tag) }}:
                            </div> 
                
                            <div>
                                <b>{{ tag.text }}</b>
                            </div>
                        </div>

                        <div v-for="(attlist, attlist_idx) in dtd.tag_dict[tag.tag].attlists"
                            v-if="!['id','spans','text','tag'].contains(attlist.name)"
                            class="iaa-tag-attlist mr-1 ml-1 d-flex flex-column">
                
                            <div class="iaa-tag-attlist-name">
                                {{ attlist.name }}:
                            </div> 
                
                            <div>
                                {{ tag[attlist.name] }}&nbsp;
                            </div>
                            
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div class="box w-100">
        <div class="box-header">
            <h4>
                <i class="fa fa-list-ul"></i>
                Token Summary
            </h4>
        </div>
        <div v-if="dtd != null && anns.length > 0"
            class="box-body" style="overflow-y: auto;">
            <div class="d-flex flex-column w-100 h-100">

                <div v-for="(tag_def, tag_def_idx) in dtd.etags"
                    class="ruleset-tag-item d-flex flex-row mb-1 pt-1 pb-1">
                    <div class="ruleset-tag-name pl-2 d-flex flex-row flex-justify-between"
                        v-bind:class="'border-tag-' + tag_def.name">
                        <div class="ruleset-tag-name-str"
                            v-bind:title="tag_def.name">
                            <i class="fa fa-tag"
                                v-bind:class="'fg-tag-' + tag_def.name">
                            </i>
                            {{ tag_def.name }}
                        </div>
                        <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                            v-bind:title="'[' + tag_def.name + '] has ' + hint_dict[tag_def.name].texts.length + ' unique tokens'"
                            class="mr-2 stat-tag-count">
                            <span v-if="stat_filter_min_tokens == 0">
                                {{ hint_dict[tag_def.name].texts.length }}
                            </span>
                            <span v-else>
                                {{ count_texts_by_stat_fileter(tag_def) }}
                                /
                                {{ hint_dict[tag_def.name].texts.length }}
                            </span>
                        </div>
                        <div v-else>
                            -
                        </div>
                    </div>

                    <div v-if="hint_dict.hasOwnProperty(tag_def.name)"
                        class="ruleset-tag-info d-flex flex-row flex-wrap">

                        <!-- for the NC etags -->
                        <div v-if="hint_dict[tag_def.name].nc_dict.count > 0"
                            class="ruleset-tag-text mr-2 mb-2 d-flex flex-column">

                            <div v-on:click="hint_dict[tag_def.name].nc_dict._is_shown = !hint_dict[tag_def.name].nc_dict._is_shown">
                                <span class="ruleset-tag-text-count"
                                    v-bind:title="'Annotated ' + hint_dict[tag_def.name].nc_dict.count + ' times'">
                                    <i v-if="hint_dict[tag_def.name].nc_dict._is_shown"
                                        class="fa fa-caret-down"></i>
                                    <i v-else
                                        class="fa fa-caret-right"></i>
                                    {{ hint_dict[tag_def.name].nc_dict.count }}
                                </span>
                                <span class="ruleset-tag-text-str">
                                    <i class="far fa-file"></i>
                                    DOC-LEVEL
                                </span>
                            </div>

                            <div v-show="hint_dict[tag_def.name].nc_dict._is_shown"
                                class="ruleset-tag-text-filelist">
                                <div v-for="(fn_v, fn) in hint_dict[tag_def.name].nc_dict.ann_fn_dict"
                                    v-on:click="show_ann_file(fn)"
                                    class="ruleset-tag-text-filelist-item">
                                    <span class="ruleset-tag-text-filelist-item-count">
                                        {{ fn_v }}
                                    </span>
                                    <i class="fa fa-angle-right ml-1 mr-1"></i>
                                    <span>
                                        {{ fn }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- for general etags -->
                        <div v-for="v_text_info in sort_text_dict_in_hint_dict(hint_dict[tag_def.name].text_dict)"
                            v-if="stat_filter_min_tokens == 0 || hint_dict[tag_def.name].text_dict[v_text_info.text].count <= stat_filter_min_tokens"
                            class="ruleset-tag-text mr-1 mb-1 d-flex flex-column">
                            <div v-on:click="hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown = !hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                class="cursor-pointer"
                                title="Click to check which document contains this tag">
                                <span class="ruleset-tag-text-count"
                                    v-bind:title="'Annotated ['+v_text_info.text+'] ' + hint_dict[tag_def.name].text_dict[v_text_info.text].count + ' time(s)'"
                                    :style="{ color: stat_value2ftcolor(hint_dict[tag_def.name].text_dict[v_text_info.text].count, stat_docs_by_tags.stat.max_by_tag), backgroundColor: stat_value2bgcolor(hint_dict[tag_def.name].text_dict[v_text_info.text].count, stat_docs_by_tags.stat.max_by_tag) }">
                                    <i v-if="hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                        v-show="stat_filter_token_text"
                                        class="fa fa-caret-down"></i>
                                    <i v-else
                                        v-show="stat_filter_token_text"
                                        class="fa fa-caret-right"></i>
                                    {{ hint_dict[tag_def.name].text_dict[v_text_info.text].count }}
                                </span>
                                <span v-show="stat_filter_token_text"
                                    class="ruleset-tag-text-str">
                                    {{ v_text_info.text }}
                                </span>
                            </div>
                            <div v-show="stat_filter_token_text && hint_dict[tag_def.name].text_dict[v_text_info.text]._is_shown"
                                class="ruleset-tag-text-filelist">
                                <div v-for="(fn_v, fn) in hint_dict[tag_def.name].text_dict[v_text_info.text].ann_fn_dict"
                                    v-on:click="show_ann_file(fn)"
                                    v-bind:title="'Click to check this tag in ' + fn"
                                    class="ruleset-tag-text-filelist-item cursor-pointer">
                                    <span class="ruleset-tag-text-filelist-item-count"
                                    :style="{ color: stat_value2ftcolor(fn_v, stat_docs_by_tags.stat.max_by_tag), backgroundColor: stat_value2bgcolor(fn_v, stat_docs_by_tags.stat.max_by_tag) }">
                                        {{ fn_v }}
                                    </span>
                                    <i class="fa fa-angle-right ml-1 mr-1"></i>
                                    <span>
                                        {{ fn }}
                                    </span>
                                </div>
                            </div>
                        </div>

                    </div>

                </div>

            </div>
        </div>
    </div>
</div>
</div>
<!-- /#mui_stat_details -->

</div>

</div>
<!-- /#main_ui -->
    

    <!-- the context menu -->
    <div v-if="dtd != null"
        style="display: none;"
        id="ctxmenu_sel">
        <li class="ui-widget-header"
            v-on:click="close_ctxmenu">Entity Tags:</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in dtd.etags"
            v-on:click="add_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_sel">

    </div>

    <!-- the context menu for non-consuming tags -->
    <div v-if="dtd != null && get_nc_etags().length > 0"
        style="display: none;"
        id="ctxmenu_nce">
        <li class="ui-widget-header"
            style="padding-right: 5px;"
            v-on:click="close_ctxmenu">Document-Level Tag</li>
        <li class="ctxmenu-item"
            v-for="etag, tag_idx in get_nc_etags()"
            v-on:click="add_nc_etag_by_ctxmenu(etag)">
            <div v-bind:id="'ctxmenu-item-' + etag.name">
                <i v-bind:class="'fa fa-tag fg-tag-' + etag.name"></i>
                <span v-if="etag.hasOwnProperty('shortcut')"
                    class="badge-shortcut mr-1">
                    {{ etag.shortcut }}
                </span>
                <span>
                    {{ etag.name }}
                </span>
            </div>
        </li>
    </div>
    <div v-else
        id="ctxmenu_nce">

    </div>

    <!-- the tag click menu -->
    <div v-if="dtd != null && get_clicked_tag()!=null"
        style="display: none;"
        id="popmenu_tag">
        <li class="ui-widget-header"
            v-on:click="close_popmenu">
            <i class="fa fa-tag"></i>
            <span>
                {{ get_clicked_tag()['tag'] }}
            </span>
            <span>
                <b>{{ clicked_tag_id }}</b>
            </span>
        </li>

        <div v-if="is_linking">
            <li v-for="att, att_idx in linking_atts"
                v-on:click="popmenu_set_linking(att_idx)"
                class="ctxmenu-item">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + linking_tag_def.name">
                    </i>
                    <b>{{ linking_tag_def.name }}</b>
                    -
                    <i>{{ att.name }}</i>
                </div>
            </li>

            <li class="ctxmenu-divider"></li>
            <li class="ctxmenu-item"
                v-on:click="cancel_linking()">
                <div>
                    <i class="far fa-times-circle"></i>
                    Cancel current linking
                </div>
            </li>
        </div>

        <div v-else>
            <li class="ctxmenu-item"
                v-for="ltag, ltag_idx in dtd.ltags"
                v-on:click="popmenu_start_linking(ltag)">
                <div>
                    <i class="fa fa-link"
                        v-bind:class="'fg-tag-' + ltag.name">
                    </i>
                    <b>{{ ltag.name }}</b>
                    -
                    <i>{{ get_idref_attlist_by_seq(ltag).name }}</i>
                </div>
            </li>
        </div>

        <li class="ctxmenu-divider"></li>
        <li class="ctxmenu-item"
            v-on:click="popmenu_del_tag()">
            <div>
                <i class="far fa-trash-alt"></i>
                Delete this tag
            </div>
        </li>
    </div>
    <div v-else
        id="popmenu_tag">

    </div>

    <div id="hoverbox_etag"
        v-show="hovered_tag != null">

        <div v-if="hovered_tag != null">
            <div>
                <span v-if="hovered_tag.hasOwnProperty('_annotator')"
                    v-bind:class="'iaa-annotator-' + hovered_tag._annotator">
                    <i class="fa fa-user"></i>
                    {{ hovered_tag._annotator }}
                </span>
                
                <i class="fa fa-tag" v-bind:class="'fg-tag-' + hovered_tag.tag"></i>
                {{ hovered_tag.tag }}.{{ hovered_tag.id }} {{ hovered_tag.spans }} 
            </div>
            
            <div v-html="get_tag_desc_html(hovered_tag)">
            </div>
        </div>
    </div>

    <div id="schema_editor"
    data-cls-window="schema-editor"
    class="p-2" 
    data-draggable="true"
    data-btn-min="false"
    data-btn-max="false"
    data-btn-close="false"
    data-shadow="true"
    data-height="600px"
    data-top="10px"
    data-left="55px"
    data-title="&nbsp;&nbsp;<i class='fa fa-edit'></i> Schema Editor"
    data-cls-caption="bg-light fg-black"
    data-role="window" >

    <div>
        <div id="schema_editor_menu"
            class="pt-2 pb-2 mb-2 d-flex flex-row">

            <div v-if="se_dtd != null"
                class="mr-1">
                <span class="se-input-field-legend">
                    SCHEMA NAME
                </span>
                <input type="text" 
                    style="width: 150px; height: 30px;"
                    class=""
                    v-on:keypress="on_keypress_se_dtd_input($event)"
                    v-model="se_dtd.name">
            </div>
            <div v-else
                class="mr-1">

            </div>
            
            <ul class="h-menu horizontal">
                <li class="border-right bd-gray"
                    title="Create a new annotation schema"
                    v-on:click="create_new_se_dtd">
                    <a href="javascript:void(0);">
                    <i class="far fa-file"></i>
                    <span class="caption">New</span>
                </a></li>

                <li class="mr-1 border-right bd-gray"
                    title="Open local annotation schema"
                    v-on:click="open_se_dtd">
                    <a href="javascript:void(0);">
                    <i class="far fa-folder-open"></i>
                    <span class="caption">Open</span>
                </a></li>

                <li>
                    <select style="width: 120px; height: 30px; line-height: 30px;"
                        v-model="se_dtd_tpl_id">
                        <optgroup label="Sample 1: Simple Tasks">
                            <option value="MINIMAL_TASK">1.1 Minimal Task</option>
                            <option value="ENTITY_RELATION_TASK">1.2 Two Entities and One Relation</option>
                            <option value="IAA_TASK">1.3 Nine Entities and One Relation</option>
                            <option value="DOCUMENT_LEVEL_TASK">1.4 Eleven Entities for Document-Level Annotation</option>
                        </optgroup>
                    
                        <!-- <optgroup label="Sample 2: Large Tasks">
                            <option value="s-2-1">2.1 COVID-19 Symptoms (8E)</option>
                            <option value="s-2-2">2.2 COVID-19 Vaccine Adverse Events (9E1R)</option>
                            <option value="s-2-3">2.3 Symptoms of long COVID (10E)</option>
                        </optgroup> -->
                    </select>
                </li>

                <li v-on:click="load_se_dtd_sample"
                    class="border-right bd-gray"
                    title="Load the selected sample schema">
                    <a href="javascript:void(0);">
                    <i class="far fa-folder-open"></i>
                    <span class="caption">Load</span>
                </a></li>

                
                <li v-if="se_dtd != null" 
                    v-on:click="use_se_dtd_for_annotation(se_dtd)"
                    class=""
                    title="Use this schema for annotation">
                    <a href="javascript:void(0);">
                    <span class="mif-rocket icon"></span>
                    <span class="caption">Use</span>
                </a></li>
                
                <li v-if="se_dtd != null" 
                    class="border-right bd-gray"
                    title="Download current schema file"
                    v-on:click="download_se_dtd(se_dtd)">
                    <a href="javascript:void(0);">
                    <span class="mif-download icon"></span>
                    <span class="caption">Download</span>
                </a></li>

                <li class="border-right bd-gray"
                    title="Show how to use schema editor"
                    v-on:click="show_se_help">
                    <a href="javascript:void(0);">
                    <span class="mif-question icon"></span>
                    <span class="caption">Help</span>
                </a></li>
                
                <li class="mr-1"
                    title="Close schema editor"
                    v-on:click="close_schema_editor"
                    ><a href="javascript:void(0);">
                    <span class="mif-cross icon"></span>
                    <span class="caption">Close</span>
                </a></li>
            </ul>
        </div>


        <div v-if="se_dtd != null"
            class="w-100">
            <div class="d-flex flex-row">
                

            </div>

            <div class="d-flex flex-column">
                <div v-for="tags, idx in [se_dtd.etags, se_dtd.ltags]"
                    class="d-flex flex-column mb-4">
                    <h5 class="mt-0 mb-2 pt-2 pb-2 bg-light">
                        <span v-if="idx == 0">
                            <i class="fa fa-tags"></i>
                            ENTITY TAGS - 
                        </span>
                        <span v-else>
                            <i class="fa fa-link"></i>
                            RELATION TAGS -
                        </span>
                        <span class="txt-sm">
                            {{ tags.length }} tag(s)
                        </span>
                        |
                        <a class="se-btn-link mr-2"
                            v-on:click="add_se_dtd_tag(se_dtd, idx)">
                            <i class="fa fa-plus"></i>
                            Tag
                        </a>
                    </h5>
                    <div v-for="tag_def, tag_idx in tags"
                        class="se-tag-row d-flex flex-row pt-3 pb-2 border-bottom bd-gray">
                        <div class="se-tag-name mr-4 d-flex flex-column flex-align-end">
                            <div class="mb-1 p-1 d-flex flex-row">
                                <span class="se-input-field-legend">
                                    TAG NAME
                                </span>
                                <input type="text"
                                    class="se-input-tag-name mr-1"
                                    v-on:keypress="on_keypress_se_dtd_input($event)"
                                    v-model="tag_def.name">
                                
                                <a class="se-btn-link se-tag-attr-del"
                                    title="Delete this tag"
                                    v-on:click="remove_se_dtd_tag(se_dtd, tag_def, idx, tag_idx)">
                                    <i class="fa fa-minus"></i>
                                </a>
                            </div>
                            
                            <div class="d-flex flex-row pr-1">
                                <div>
                                    <div v-if="idx==0" class="mr-1">
                                        <span class="se-input-field-legend">
                                            ANN.TYPE
                                        </span>
                                        <select v-model="tag_def.is_non_consuming"
                                            title="The tag can be assigned to a whole document for document-level annotation task. Otherwise just span-based annotation."
                                            class="se-select-att-type">
                                            <option :value="true">
                                                DOCUMENT + SPAN
                                            </option>
                                            <option :value="false">
                                                SPAN
                                            </option>
                                        </select>
                                    </div>
                                </div>

                                <div>
                                    <a class="se-btn-link"
                                        v-on:click="add_se_dtd_tag_attr(se_dtd, tag_def)"
                                        v-bind:title="'Add new attribute to this [' + tag_def.name + ']'">
                                        <i class="fa fa-plus"></i>
                                        Attr
                                    </a>
                                </div>
                            </div>

                        </div>
                        <div class="d-flex flex-row flex-wrap">

                            <div v-for="att, att_idx in tag_def.attlists"
                                v-show="att.vtype != 'dfix'"
                                class="se-tag-attr-cell mr-2 mb-2 p-1">
                                <div class="mb-2 d-flex flex-row">
                                    <span class="se-input-field-legend">
                                        ATTRIBUTE
                                    </span>
                                    <input type="text"
                                        class="se-input-att-name"
                                        v-on:keypress="on_keypress_se_dtd_input($event)"
                                        v-model="att.name">

                                    <a class="se-btn-link se-tag-attr-del"
                                        title="Remove this attribute"
                                        v-on:click="remove_se_dtd_tag_attr(se_dtd, tag_def, att, idx, tag_idx, att_idx)">
                                        <i class="fa fa-minus"></i>
                                    </a>
                                </div>

                                <div class="d-flex flex-row">
                                    <div class="mr-1">
                                        <span class="se-input-field-legend">
                                            TYPE
                                        </span>
                                        <select v-model="att.vtype"
                                            class="se-select-att-type">
                                            <option value="text">
                                                TEXT
                                            </option>
                                            <option value="list">
                                                LIST
                                            </option>
                                            <option v-if="idx==1" value="idref">
                                                LINK
                                            </option>
                                        </select>
                                    </div>

                                    <div v-if="att.vtype == 'text'">
                                        <span class="se-input-field-legend">
                                            DEFAULT
                                        </span>
                                        <input type="text"
                                            title="The default value for"
                                            class="se-input-att-value"
                                            v-model="att.default_value">
                                    </div>
                                    <div v-else-if="att.vtype == 'list'"
                                        class="d-flex flex-row">
                                        <div class="mr-1">
                                            <span class="se-input-field-legend">
                                                DEFAULT
                                            </span>
                                            <select v-model="att.default_value"
                                                title="The default item for this attribute"
                                                class="se-select-att-value">
                                                <option v-for="att_opt_val in att.values"
                                                    v-bind:value="att_opt_val">
                                                    {{ att_opt_val }}
                                                </option>
                                            </select>
                                        </div>
                                        <div>
                                            <span class="se-input-field-legend">
                                                ITEMS ({{ att.values.length }})
                                            </span>
                                            <input type="text"
                                                class="se-input-att-list-values"
                                                readonly
                                                title="Click to edit the item list"
                                                v-on:click="show_att_list_editor(att)"
                                                v-bind:value="att.values.join('|')">
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

            </div>
        </div>
        <div v-else>
            <p>
                You can click the "New" button to create an empty annotation schema.
                <br>
                Or click the "Open" button to open an existing schema file to edit.
            </p>
            <p>
                Once the schema design is finished, you can download it as a DTD format file for backup, or use it directly in annotation.
                <br>
                The specification of the annotation schema file can be found in <a href="https://github.com/OHNLP/MedTator/wiki/Annotation-Schema">MedTator Wiki</a>.
            </p>
            <p>
                For more schema samples, you can check <a target="_blank" href="https://github.com/OHNLP/MedTator/tree/main/sample">MedTator sample schemas on GitHub repo</a>.
            </p>

        </div>
    </div>
    
</div>
    
</div>

<script>
function get_browser() {
    var ua = navigator.userAgent,tem,M=ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; 
    if(/trident/i.test(M[1])){
        tem=/\brv[ :]+(\d+)/g.exec(ua) || []; 
        return {name:'IE',version:(tem[1]||'')};
        }   
    if(M[1]==='Chrome'){
        tem=ua.match(/\bOPR|Edge\/(\d+)/)
        if(tem!=null)   {return {name:'Opera', version:tem[1]};}
        }   
    M=M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem=ua.match(/version\/(\d+)/i))!=null) {M.splice(1,1,tem[1]);}
    return {
      name: M[0],
      version: M[1]
    };
}
var _browser = get_browser();

var isIE = /*@cc_on!@*/false || !!document.documentMode;
var isCHROME = _browser.name == 'Chrome';
var isSAFARI = _browser.name == 'Safari';
var isFIREFOX = _browser.name == 'Firefox';
// var isCB_BRAVE = (navigator.brave && await navigator.brave.isBrave() || false);
var isCB_BRAVE = typeof(navigator.brave) != 'undefined';
if (isCB_BRAVE) {
    _browser.name = 'Brave';
}
// for HTTPS check
var isHTTPS = window.location.protocol == 'https:';
var isLOCALFILE = window.location.protocol == 'file:';
var isLOCALHOST = !window.location.host.replace(/(localhost|127\.0\.0\.1)(:\d+)?/i, "");

// the file system access api
var isFSA_API_OK = typeof(window.showOpenFilePicker) == 'function';

console.log("* Browser:", _browser);
console.log('* isHTTPS: ' + isHTTPS);
console.log('* isLOCALFILE: ' + isLOCALFILE);
console.log('* isLOCALHOST: ' + isLOCALHOST);
console.log('* isIE: ' + isIE);
console.log('* isCHROME: ' + isCHROME);
console.log('* isSAFARI: ' + isSAFARI);
console.log('* isFIREFOX: ' + isFIREFOX);
console.log('* isCB_BRAVE: ' + isCB_BRAVE);
console.log('* isFSA_API_OK: ' + isFSA_API_OK);

var _NOT_SUPPORT_MSG = 'The visualization and annotation features require advanced web techniques, which are <b>NOT</b> supported by the web browser you are using.<br>'+
'Try using latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.';

var _LMT_SUPPORT_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> require latest HTML5 techniques, which are <b>NOT</b> supported by the web browser [' + _browser.name + '] you are using. <br>' +
'Try using the latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or other <a target="_blank" href="https://download-chromium.appspot.com/">Chromium</a> based browsers (e.g., <a target="_blank" href="https://www.microsoft.com/en-us/edge">Microsoft Edge</a>, <a target="_blank" href="https://vivaldi.com/">Vivaldi</a>) to get full supports.<br> '+
'Except for the file saving limitation, you can use all other functions.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

var _DISABLED_API_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> are <b>NOT</b> enabled by your current web browser [' + _browser.name + '] you are using. <br>' +
'Try using the latest <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> or enabling the File System Access API. <br> '+
'We provide a tutorial about how to enable the API in some browsers in <a href="https://github.com/OHNLP/MedTator/wiki/FQA#enable-file-system-access-api">the MedTator Wiki</a>.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

var _SEC_LMT_MSG = 'The <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access APIs</a> are available only in secure contexts (HTTPs) or localhost server for accessing your local files. <br>' +
'Try adding SSL to your web server or hosting MedTator on a web server with SSL certification. <br> '+
'We provide a tutorial about how to solve this issue in <a href="https://github.com/OHNLP/MedTator/wiki/FQA#https">the MedTator Wiki</a>.<br>' +
'<a style="font-size:1.5em;" href="javascript:void(0);" onclick="jarvis.ssclose()">Continue to use <i class="fa fa-arrow-alt-circle-right"></i></a>';

</script>
<!-- metro ui -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/metro/4.3.5/js/metro.min.js"></script>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<!-- jQuery UI -->
<script src="https://code.jquery.com/ui/1.12.0/jquery-ui.min.js"></script>
<!-- Vue.js -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<!-- jszip -->
<script src="https://stuk.github.io/jszip/dist/jszip.js"></script>
<!-- filesaver -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
<!-- dayjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.8.36/dayjs.min.js"></script>
<!-- code mirror -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>
<!-- code mirror addon -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/selection/active-line.min.js"></script>
<!-- code mirror addon for line jump -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.js"></script>
<!-- code mirror addon for dialog display -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/search.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/searchcursor.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/matchesonscrollbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/scroll/annotatescrollbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/jump-to-line.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/dialog/dialog.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/matchesonscrollbar.min.css">
<!-- numjs -->
<!-- <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script> -->
<!-- compromise -->
<script src="https://unpkg.com/compromise"></script>
<!-- chart.js -->
<!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
<!-- PapaParse -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.1/papaparse.min.js"></script>
<!-- Shepherd -->
<script src="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/js/shepherd.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/shepherd.js@8.3.1/dist/css/shepherd.css">
<!-- wink-nlp customized bundle -->
<script src="./static/lib/wink-nlp/bundle-1.8.0.min.js"></script>
<!-- dataset spliter -->
<script src="./static/lib/ds-spliter/ds-spliter-1.0.0.min.js"></script>
<!-- format xml -->
<script src="https://cdn.jsdelivr.net/npm/xml-formatter@2.4.0/dist/browser/xml-formatter.js"></script>
<!-- export xlsx -->
<script src="https://unpkg.com/xlsx@0.17.4/dist/shim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.mini.min.js"></script>
<!-- xlsx style -->
<script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.0.0/dist/xlsx.bundle.js"></script>
<!-- d3 for data visualization -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>

// The file helper 
async function fs_open_files(pickerOpts) {
    const fhs = await window.showOpenFilePicker(pickerOpts);
    return fhs;
}

async function fs_read_file_handle(fh) {
    // get the file obj
    const file = await fh.getFile();
    // get the text content
    const text = await file.text();

    // return the content and fh
    return {
        fh: fh,
        text: text
    };
}

async function fs_read_dir_handle(fh, callback) {
    for await (const entry of fh.values()) {
        // Each entry is an instance of FileSystemFileHandle
        // FileSystemFileHandle{kind: 'file', name: 'doc_04.txt'} 
        console.log(entry);
        if (entry.kind != 'file') {
            console.log('* skip sub folder', entry.name);
            continue;
        }

        // call the app_hotpot to parse and decide this fh
        app_hotpot.parse_file_fh(
            entry, 
            callback
        );
    }
}

///////////////////////////////////////////////////////////
// Customized functions of read/write for annotation
///////////////////////////////////////////////////////////

async function fs_read_ann_dir_handle(fh, dtd) {
    for await (const entry of fh.values()) {
        // Each entry is an instance of FileSystemFileHandle
        // FileSystemFileHandle{kind: 'file', name: 'doc_04.txt'} 
        console.log(entry);
        if (entry.kind != 'file') {
            console.log('* skip sub folder', entry.name);
            continue;
        }

        // call the app_hotpot to parse and decide this fh
        app_hotpot.parse_ann_file_fh(
            entry, 
            dtd
        );
    }
}

async function fs_read_txt_file_handle(fh, dtd) {
    if (typeof(dtd) == 'undefined') {
        dtd = {name: ''};
    }
    // if (typeof(enabled_sentences) == 'undefined') {
    //     enabled_sentences = false;
    // }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.txt2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences variable
    ann._sentences = null;
    ann._sentences_text = null;
    // if (enabled_sentences) {
    //     var result = nlp_toolkit.sent_tokenize(ann.text);
    //     ann._sentences = result.sentences;
    //     ann._sentences_text = result.sentences_text;
    // } else {
    //     ann._sentences = null;
    //     ann._sentences_text = null;
    // }

    return ann;
}

async function fs_read_ann_file_handle(fh, dtd) {
    // if (typeof(enabled_sentences) == 'undefined') {
    //     enabled_sentences = true;
    // }
    const file = await fh.getFile();
    const text = await file.text();

    // create ann
    var ann = ann_parser.xml2ann(text, dtd);

    // bind the fh
    ann._fh = fh;

    // bind the filename seperately
    ann._filename = fh.name;

    // bind a status
    ann._has_saved = true;

    // bind the sentences
    ann._sentences = null;
    ann._sentences_text = null;
    // if (enabled_sentences) {
    //     var result = nlp_toolkit.sent_tokenize(ann.text);
    //     ann._sentences = result.sentences;
    //     ann._sentences_text = result.sentences_text;
    // } else {
    //     ann._sentences = null;
    //     ann._sentences_text = null;
    // }

    return ann;
}

async function fs_read_dtd_file_handle(fh) {
    const file = await fh.getFile();
    const text = await file.text();

    // create dtd
    var dtd = dtd_parser.parse(text);

    return dtd;
}

async function fs_write_ann_file(fh, content) {
    const writable = await fh.createWritable();
    
    // write the contents
    await writable.write(content);

    // close the file
    await writable.close();

    return fh;
}

async function fs_get_new_ann_file_handle(fn) {
    const options = {
    suggestedName: fn,
      types: [
        {
          description: 'Text Files',
          accept: {
            'text/xml': ['.xml'],
          },
        },
      ],
    };
    const handle = await window.showSaveFilePicker(options);
    return handle;
}

async function fs_save_new_ann_file(ann, dtd) {
    // create a new fh by the suggested ann filename
    const fh = await fs_get_new_ann_file_handle(ann._filename);

    // update the filename according to fh
    ann._fh = fh;
    ann._filename = fh.name;

    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_ann_file(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}

async function fs_save_ann_file(ann, dtd) {
    // create the xml content for writing to file
    var xmlDoc = ann_parser.ann2xml(ann, dtd);
    const content = ann_parser.xml2str(xmlDoc, false);

    // write to fh!
    await fs_write_ann_file(ann._fh, content);

    // done!
    ann._has_saved = true

    return ann;
}

// The DTD parser
/**
 * DTD schema file parser
 */
var dtd_parser = {
    regex: {
        entity: /\<\!ENTITY\ name\ "([a-zA-Z\-0-9\_]+)"\>/gmi,
        element: /^\<\!ELEMENT\s+([a-zA-Z\-0-9\_]+)\s.+/gmi,
        attlist: /^\<\!ATTLIST\s+([a-zA-Z\-0-9\_]+)\s+([a-zA-Z0-9\_]+)\s+(\S+)\s/gmi,
        attlist_values: /\(([a-zA-Z0-9\_\ \|\-]+)\)/gmi,
        attlist_require: /#([A-Z]+)+(\b["a-zA-Z0-9\-\_\ ]+|\>)/gm,
        attlist_prefix: /prefix="([a-zA-Z0-9\_]+)"/gm,
        // attlist_cdata_default_value: /(?<=").*?(?=")/gm
        attlist_cdata_default_value: /\s+\"(.*)\"/g
    },

    NON_CONSUMING_SPANS: '-1~-1',

    /**
     * Stringify a dtd object into text
     * @param {Object} dtd DTD schema
     */
    stringify: function(dtd, format) {
        if (typeof(format) == 'undefined') {
            format = 'dtd';
        }

        if (format == 'dtd') {
            return this.stringify_dtd(dtd);
        }

        return this.stringify_dtd(dtd);
    },

    stringify_dtd: function(dtd) {
        // for the given dtd, convert to strings
        var txt = [];

        // output the dtd name
        txt.push(
            '<!ENTITY name "'+dtd.name+'">'
        );

        // just an empty line for break
        txt.push('');

        // check 
        for (let _t = 0; _t < 2; _t++) {
            var tags = {
                0: dtd.etags,
                1: dtd.ltags
            }[_t];

            for (let i = 0; i < tags.length; i++) {
                const tag = tags[i];

                // for counting the number of IDREF attrs
                var n_lk_att = 0;
                
                // a comment for users
                if (_t == 0) {
                    txt.push('<!-- entity concept [' + tag.name + '] -->');
    
                    // the tag name
                    txt.push('<!ELEMENT ' + tag.name + ' ( #PCDATA ) >')
        
                    // the non-comsuming attr
                    if (tag.is_non_consuming) {
                        txt.push('<!ATTLIST ' + tag.name + ' spans #IMPLIED >')
                    }
                } else {
                    txt.push('<!-- relation concept [' + tag.name + '] -->');
    
                    // the tag name
                    txt.push('<!ELEMENT ' + tag.name + ' EMPTY >')
                }
    
                // check each attr
                for (let j = 0; j < tag.attlists.length; j++) {
                    const att = tag.attlists[j];
                    
                    var att_req = '#IMPLIED'
                    if (att.require == 'REQUIRED') {
                        att_req = '#REQUIRED'
                    }

                    if (att.vtype == 'text') {
                        txt.push('<!ATTLIST ' + tag.name + ' ' + att.name + ' ' + att_req + ' "' + att.default_value + '" >');
                    } 
                    else if (att.vtype == 'list') {
                        var att_vals = att.values.join('|');
                        txt.push('<!ATTLIST ' + tag.name + ' ' + att.name + ' ( '+att_vals+' ) ' + att_req + ' "' + att.default_value + '" >');
                    } 
                    else if (att.vtype == 'idref') {
                        var argN = 'arg' + n_lk_att;
                        txt.push('<!ATTLIST ' + tag.name + ' ' + argN + ' IDREF prefix="' + att.name + '" ' + att_req + ' >');

                        // increase the argN number
                        n_lk_att += 1;
                    }
                }
    
                // just an empty line for break
                txt.push('');
            }
        }

        return txt.join('\n');
    },

    extend_base_dtd: function(base_dtd) {
        var dtd = JSON.parse(JSON.stringify(base_dtd));

        // first, update the attlist_dict for each tag
        for (let _t = 0; _t < 2; _t++) {
            var el = {
                0: 'etags',
                1: 'ltags'
            }[_t];

            for (let i = 0; i < dtd[el].length; i++) {
                // init the attlist dict
                dtd[el][i].attlist_dict = {};
                
                // fill the attlist dict
                for (let j = 0; j < dtd[el][i].attlists.length; j++) {
                    var att = dtd[el][i].attlists[j];
                    dtd[el][i].attlist_dict[att.name] = att;
                }
            }
        }

        // then, need to decide the `id_prefixd` and update the tag_dict
        dtd.id_prefixd = {};
        dtd.tag_dict = {};
        for (let _t = 0; _t < 2; _t++) {
            var el = {
                0: 'etags',
                1: 'ltags'
            }[_t];

            for (let i = 0; i < dtd[el].length; i++) {
                // init the id_prefix using the first letter
                dtd[el][i].id_prefix = dtd[el][i].name.substring(0, 1).toLocaleUpperCase();
                
                // search if it is available now
                while (true) {
                    if (dtd.id_prefixd.hasOwnProperty(dtd[el][i].id_prefix)) {
                        dtd[el][i].id_prefix = this.get_next_id_prefix(dtd[el][i]);
                    } else {
                        break;
                    }
                }
                
                // yes found at last
                dtd.id_prefixd[dtd[el][i].id_prefix] = dtd[el][i];

                // and update the tag_dict
                dtd.tag_dict[dtd[el][i].name] = dtd[el][i];
            }
        }

        // last, add the text
        dtd.text = this.stringify(dtd);

        return dtd;
    },

    parse: function(text) {
        var lines = text.split('\n');

        var dtd = {
            // schema name
            name: '',

            // the list of entity tags
            etags: [],

            // the list of relation tags
            ltags: [],

            // a dictionary for quick access tags by id_prefix
            id_prefixd: {},

            // a dictionary for quick access tags by tag name
            tag_dict: {},

            // the raw dtd text
            text: text
        };

        for (let l = 0; l < lines.length; l++) {
            const line = lines[l];
            
            // check this line
            var ret = this.parse_line(line);

            if (ret == null) {
                // nothing happens
                console.log('* null dtd line: ', line);
                continue;

            } else if (ret.type == 'entity') {
                dtd.name = ret.name;

            } else if (ret.type == 'etag') {
                // check the id by a looping
                while (true) {
                    if (dtd.id_prefixd.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefixd[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'ltag') {
                // check the id
                while (true) {
                    if (dtd.id_prefixd.hasOwnProperty(ret.id_prefix)) {
                        ret.id_prefix = this.get_next_id_prefix(ret);
                    } else {
                        break;
                    }
                }
                dtd.id_prefixd[ret.id_prefix] = ret;
                dtd.tag_dict[ret.name] = ret;

            } else if (ret.type == 'attr') {
                // put this attr to an element
                dtd.tag_dict[ret.element].attlists.push(
                    ret
                );

            } else {
                // what???
            }
        }
        
        // post processing for all tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                if (dtd.tag_dict[name].type == 'etag') { 
                    // check the attlist to make sure no missing
                    for (let i = 0; i < dtd.tag_dict[name].attlists.length; i++) {
                        if (dtd.tag_dict[name].attlists[i].vtype == 'dfix') {
                            // which means this is a non-consuming tag
                            dtd.tag_dict[name].is_non_consuming = true;
                        }
                    } 

                }  else {

                    // for link tag, need to check how many attlists are found
                    var cnt_idrefs = 0;
                    for (let i = 0; i < dtd.tag_dict[name].attlists.length; i++) {
                        if (dtd.tag_dict[name].attlists[i].vtype == 'idref') {
                            cnt_idrefs += 1;
                        }
                    }

                    // if there is not idref, just create two:
                    if (cnt_idrefs == 0) {
                        // create from and to
                        var attlist_from = this.mk_attlist(name, 'from', 'idref');
                        var attlist_to = this.mk_attlist(name, 'to', 'idref');
                        dtd.tag_dict[name].attlists = [attlist_from, attlist_to].concat(
                            dtd.tag_dict[name].attlists
                        );
                        console.log('* added from+to to the attlist of ' + name);
                    }
                }
                
            }
        }

        // split the tags
        for (const name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, name)) {
                // now, create a attlist_dict for each tag
                dtd.tag_dict[name].attlist_dict = this.make_attlist_dict(
                    dtd.tag_dict[name]
                );

                // last, put this tag to list
                var element = dtd.tag_dict[name];
                if (element.type == 'etag') {
                    dtd.etags.push(element);
                } else {
                    dtd.ltags.push(element);
                }
            }
        }

        return dtd;
    },

    parse_line: function(line) {
        var obj = null;
        var ret = null;

        // try entity
        ret = this.get_entity(line);
        if (ret != null) { return ret; }

        // try element
        ret = this.get_element(line);
        if (ret != null) { return ret; }

        // try attlist
        ret = this.get_attlist(line);

        return ret;
    },

    get_entity: function(text) {
        let m;
        var ret = null;
        let regex = this.regex.entity;

        while ((m = regex.exec(text)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found entity match, group ${groupIndex}: ${match}`);
                ret = {
                    name: match,
                    type: 'entity'
                };
            });
        }

        return ret;
    },

    get_element: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.element;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var element = {
                name: '',
                type: 'etag',
                id_prefix: '',
                is_non_consuming: false,
                attlists: []
            };

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found element match, group ${groupIndex}: ${match}`);
                // group 0 is the leading line
                if (groupIndex == 1) {
                    element.name = match;
                    element.id_prefix = match.substring(0, 1);
                } 
            });
        
            // check the element type
            if (line.lastIndexOf('EMPTY')>=0) {
                element.type = 'ltag';
            }

            ret = element;
        }

        return ret;

    },

    get_attlist: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var attlist = this.mk_attlist();
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    attlist.element = match;

                } else if (groupIndex == 2) {
                    // which means it is the attr of this element
                    attlist.name = match;

                    // special rule for some attrs
                    if (match == 'spans') {
                        // for attr `spans`, need to update the elememt
                        attlist.vtype = 'dfix';
                        attlist.default_value = this.NON_CONSUMING_SPANS;
                    }

                } else if (groupIndex == 3) {
                    if (match == 'CDATA') {
                        // ok, it's just a text content
                        attlist.vtype = 'text';
                        
                        // then get the default value
                        attlist.default_value = this.get_attlist_cdata_default_value(line);

                    } else if (match == '(') {
                        // this is a list
                        attlist.vtype = 'list';

                        // get the values
                        attlist.values = this.get_attlist_values(line);

                    } else if (match == 'IDREF') {
                        // it's an attr for link tag
                        attlist.vtype = 'idref';

                        if (this.is_argN(attlist.name)) {
                            // ok
                        } else {
                            // IDREF's default name must argX
                            // but ... why?
                            console.error('* error name for this "', line, '", attlist name should be argX format');
                        }

                        // then, check if there is prefix
                        var prefix = this.get_attlist_prefix(line);
                        if (prefix == null) {
                            // which means this attlist doesn't have a prefix
                            // for renaming the extraction
                        } else {
                            // use the prefix to replace this name
                            attlist.name = prefix;
                        }
                    }
                } else {
                    // what?
                }
            });

            // before end, check the require info
            var require = this.get_attlist_require(line);
                        
            if (require.length == 0) {
                // which means this attlist has nothing

            } else if (require.length == 1) {
                // which means just has the require name it self
                attlist.require = require[0];

            } else if (require.length == 2) {
                // which means it has the default value!
                attlist.require = require[0];
                attlist.default_value = require[1];
            }

            ret = attlist;
        }

        return ret;
    },

    get_attlist_values: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attlist_values;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            var values = [];
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist values match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the element name
                    var ps = match.split('|');
                    for (let i = 0; i < ps.length; i++) {
                        const p = ps[i];
                        var _p = p.trim();
                        values.push(_p);
                    }
                } 
            });

            ret = values;
        }

        return ret;
    },

    get_attlist_require: function(line) {
        let m;
        var ret = [];
        let regex = this.regex.attlist_require;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var values = [];

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist require match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the require name
                    // IMPLIED or REQUIRED
                    values.push(match)
                } else if (groupIndex == 2) {
                    // get default value 
                    var t = match.replaceAll('"', '');
                    t = t.replaceAll('>', '');
                    t = t.trim();

                    // not matter what is left, save it
                    values.push(t);
                }
            });

            ret = values;
        }

        
        return ret;
    },

    get_attlist_prefix: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist_prefix;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    get_attlist_cdata_default_value: function(line) {
        let m;
        var ret = null;
        let regex = this.regex.attlist_cdata_default_value;

        while ((m = regex.exec(line)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var p = null;

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                if (groupIndex == 1) {
                    // which is the prefix text
                    p = match;
                }
            });

            ret = p;
        }
        
        return ret;
    },    

    make_attlist_dict: function(tag) {
        let attlist_dict = {};

        for (let i = 0; i < tag.attlists.length; i++) {
            attlist_dict[tag.attlists[i].name] = tag.attlists[i];
        }

        return attlist_dict;
    },

    get_next_id_prefix: function(element) {
        var ret = element.name.substring(
            0,
            element.id_prefix.length + 1
        );

        return ret;
    },

    ///////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////
    get_id_prefix: function(tag_name, dtd) {
        if (dtd.tag_dict.hasOwnProperty(tag_name)) {
            return dtd.tag_dict[tag_name].id_prefix;
        }
        return '';
    },

    is_argN: function(name) {
        if (name.startsWith('arg')) {
            if (/^\d+$/.test(name.substring(3))) {
                return true;
            }
        }
        return false;
    },

    mk_attlist: function(element='', name='', vtype='') {
        return {
            element: element,
            name: name,
            type: 'attr',
            vtype: vtype,
            require: '',
            values: [],
            default_value: '',
        };
    },

    mk_base_tag: function(tag_name, tag_type) {
        return {
            // basic information for a tag
            name: tag_name,
            type: tag_type,
            is_non_consuming: false,
            attlists: [],

            // the followings are decided when extending
            attlist_dict: null,
            id_prefixd: null,

            // the followings are decided when importing
            shortcut: null,
            style: {
                color: '#333333'
            }
        };
    },

    mk_base_dtd: function(dtd_name) {
        return {
            name: dtd_name,
            etags: [],
            ltags: [],

            // the followings are left null for extending later
            id_prefixd: null,
            tag_dict: null,
            text: null
        }
    }
};

// The Ann parser
/**
 * Annotation file parser
 * 
 * The ann used in this tool is an object following this format:
 * {
 *  _fh: FileSystemHandle,
 *  _has_saved: true/false,
 *  text: '',
 *  dtd_name: '',
 *  tags: [{
 *    id: '',
 *    tag: '',
 *    spans: '', // this may not be available
 *    text: '',  // this may not be available
 * 
 *  }]
 * }
 * 
 * the `_fh` is added outside of parser.
 * the `_has_saved` is added outside
 */
var ann_parser = {
    NON_CONSUMING_SPANS: '-1~-1',


    ///////////////////////////////////////////////////////
    // Annotation serialization/deserialization functions
    ///////////////////////////////////////////////////////
    txt2ann: function(txt, dtd) {
        var ann = {
            text: txt,
            dtd_name: dtd.name,
            tags: [],
            meta: {},  // the meta data of this annotation
        };

        return ann;
    },

    xml2ann: function(text, dtd) {
        // create a new DOM parser
        var parser = new DOMParser();

        // parse the given text
        var xmlDoc = parser.parseFromString(text, "text/xml");

        // create an empty ann
        var ann = {
            text: '',
            dtd_name: '',
            tags: [],
            meta: {},  // the meta data of this annotation
        };

        // first, get the dtd name
        var dtd_name = xmlDoc.children[0].tagName;
        ann.dtd_name = dtd_name;

        if (dtd.name != ann.dtd_name) {
            throw {
                name: 'Not match given DTD',
                message: 'The task name in XML (' + ann.dtd_name + ') does NOT match the given DTD (' + dtd.name + ')'
            };
        }

        // then get the text content
        var textContent = xmlDoc.getElementsByTagName('TEXT')[0].textContent;
        ann.text = textContent;

        // then check all of the tags
        if (xmlDoc.getElementsByTagName('TAGS').length == 0) {
            // it's possible that there is no tags at all
            // then we could skip
        } else {
            var elems = xmlDoc.getElementsByTagName('TAGS')[0].children;

            for (let i = 0; i < elems.length; i++) {
                var elem = elems[i];

                // get the attributes
                var tag_name = elem.tagName;

                // first, need to if this tag_name is supported in current dtd
                if (dtd.tag_dict.hasOwnProperty(tag_name)) {
                    // OK, there it is
                } else {
                    // no such tag??
                    console.log("* not found", tag_name, 'in current dtd');
                    continue;
                }

                // create a new empty tag
                var tag = {
                    tag: tag_name
                };

                // get all attr names
                var attrs = elem.getAttributeNames();

                // get all attr values
                for (let j = 0; j < attrs.length; j++) {
                    var attr = attrs[j];
                    var value = elem.getAttribute(attr);

                    // there are exceptions
                    if (attr.toLocaleLowerCase() == 'text') {
                        // special rule for the text attr
                        // due to the bad convertion
                        tag['text'] = value;

                    } else if (attr.toLocaleLowerCase() == 'spans') {
                        // special rule for the text attr
                        // due to the bad convertion
                        // tag['spans'] = value;

                        // fix the wrong values
                        var locs = this.spans2locs(value);
                        var spans = this.locs2spans(locs);

                        if (value != spans) {
                            console.log('* fixed wrong format spans ' + value + ' -> ' + spans);
                        }
                        tag['spans'] = spans;

                    } else if (attr.endsWith('ID')) {
                        // omg, this may be a link tag
                        // let's check if there is a xxxText attr
                        var attr_prefix_name = attr.substring(0, attr.length-2);
                        var attrText_name = attr_prefix_name + 'Text';
                        if (attrs.indexOf(attrText_name)>=0) {
                            // ok, I'm sure this is a idref att
                            // the value is the etag id
                            // let's save it and goto next
                            tag[attr_prefix_name] = value;
                            continue;

                        } else {
                            // what??? ok, this is just a normal but weird attr
                            // just save it later

                        }
                    } else if (attr.endsWith('Text')) {
                        // I guess we could skip this one
                        continue;

                    } else if (attr.startsWith('_')) {
                        // which means this a special attribute
                        // for example, _annotator
                        var attr_lower = attr.toLocaleLowerCase();
                        tag[attr] = value;

                    } else {
                        // other special rule? maybe
                        // put this value into tag
                        tag[attr] = value;
                    }
                }

                // one more step, need to check whether this tag belongs to dtd
                // if not, skip the next step
                if (dtd.tag_dict.hasOwnProperty(tag_name)) {
                    // one more step, sometimes the attr in XML doesn't contain
                    // what defined in the dtd, so we need to give a value
                    for (let k = 0; k < dtd.tag_dict[tag_name].attlists.length; k++) {
                        const att = dtd.tag_dict[tag_name].attlists[k];
                        if (tag.hasOwnProperty(att.name)) {
                            // ok, that's what it should be
                        } else {
                            // also ok, that's what it actually is sometimes
                            tag[att.name] = att.default_value;                            
                            console.log('* fixed missing '+tag.id+' attr['+att.name+']');
                        }
                    }

                    // check the text attr for entity tags
                    if (dtd.tag_dict[tag_name].type == 'etag') {
                        if (tag.hasOwnProperty('text')) {

                        } else {
                            if (tag.spans == '-1~-1') {
                                tag.text = '';
                            } else {
                                tag.text = this.get_text_by_spans(tag.spans, ann.text);
                            }
                        }
                    }
                } else {
                    console.log('* undefined [' + tag_name + '] in dtd');
                }
                // console.log('* add tag', tag);

                // then, put this new tag to the ann tags list
                ann.tags.push(tag);
            }
        }

        // then check all of the meta data
        if (xmlDoc.getElementsByTagName('META').length == 0) {
            // it's very very possible that no meta data
            // then just skip
        } else {
            // Wow! that's great!
            // We found some meta data for this annotation!
            // just save everything to `ann.meta`?

            // check all
            var elems = xmlDoc.getElementsByTagName('META')[0].children;
            for (let i = 0; i < elems.length; i++) {
                var elem = elems[i];

                // get the attributes
                var tag_name = elem.tagName;

                // decide the format
                if (ann.meta.hasOwnProperty(tag_name)) {
                    // nothing to do
                } else {
                    // we assume each tag may have multiple tags
                    ann.meta[tag_name] = [];
                }

                // get all attr names
                var attrs = elem.getAttributeNames();

                // create a temp obj
                var obj = {};

                // put all attrs 
                for (let j = 0; j < attrs.length; j++) {
                    var attr = attrs[j];
                    var value = elem.getAttribute(attr);

                    // put value
                    obj[attr] = value;
                }

                // save this obj
                ann.meta[tag_name].push(obj);
            }
        }

        return ann;
    },

    ann2xml: function(ann, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, ann.dtd_name
        );
        var root = xmlDoc.getElementsByTagName(ann.dtd_name)[0];
        // var root = xmlDoc.getRootNode();

        // create the CDATA section for TEXT
        var node_TEXT = xmlDoc.createElement('TEXT');
        node_TEXT.appendChild(
            xmlDoc.createCDATASection(ann.text)
        );
        root.appendChild(node_TEXT);

        // create the tags
        var node_TAGS = xmlDoc.createElement('TAGS');
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];

            // create a node for this tag
            var node_tag = xmlDoc.createElement(tag.tag);

            // create all attributes
            for (const attr in tag) {
                // skip special tags
                if (attr.startsWith('_')) {
                    // internal attributes
                    // _annotator
                    // _
                    // continue;
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;
                }

                if (attr == 'tag') {
                    // skip the tag name itself
                    continue;
                }

                if (tag[attr] == null) {
                    // skip those null values in xml
                    continue;
                }

                if (attr == 'id') {
                    // quick save this attr
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;
                }

                if (dtd.tag_dict[tag.tag].type == 'etag') {
                    node_tag.setAttribute(attr, tag[attr]);
                    continue;

                } else if (dtd.tag_dict[tag.tag].type == 'ltag') {
                    // for link tag, spans and text are not required
                    if (attr == 'spans') { continue; }
                    if (attr == 'text') { continue; }

                    // due to schema version issue, 
                    // the attribute may not exist in current schema
                    if (!dtd.tag_dict[tag.tag].attlist_dict.hasOwnProperty(attr)) {
                        continue;
                    }
                
                    // for those link tag, need to check 
                    if (dtd.tag_dict[tag.tag].attlist_dict[attr].vtype == 'idref') {
                        // so, this attr is a id ref,
                        // the value is a tag_id of an etag
                        // to be compatible with MAE format,
                        // we need to set 2 attributes if the value is not null
                        if (tag[attr] == null || tag[attr] == '') {
                            // if the value is empty, just skip this
                            continue;
                        }
                        // first, the xxxID
                        // second, the xxxText
                        // so, let's get the text first
                        var etag = this.get_tag_by_tag_id(tag[attr], ann);
                        if (etag == null) {
                            // ??? how could it be?
                            // well...skip this one
                            console.log('* not found etag [', attr, '] in ', tag);
                            continue;
                        }

                        // great! the etag is not null
                        node_tag.setAttribute(attr + 'ID', tag[attr]);
                        node_tag.setAttribute(attr + 'Text', etag.text);

                    } else {
                        // bind this node_attr to the node_tag
                        node_tag.setAttribute(attr, tag[attr]);
                    }
                }
            }

            // append this node to TAGS
            node_TAGS.appendChild(node_tag);
        }
        root.appendChild(node_TAGS);

        if (!ann.hasOwnProperty('meta')) {
            // this is old format, there is no meta
            return xmlDoc;
        }

        // create the meta
        var node_META = xmlDoc.createElement('META');
        for (const key in ann.meta) {
            if (Object.hasOwnProperty.call(ann.meta, key)) {
                const objs = ann.meta[key];
                
                // objs is a list of items of this key

                for (let i = 0; i < objs.length; i++) {
                    const obj = objs[i];

                    // create a node for this tag
                    var node_tag = xmlDoc.createElement(key);
                    
                    // save this obj
                    for (const attr in obj) {
                        node_tag.setAttribute(attr, obj[attr]);
                    }

                    // save this node
                    node_META.appendChild(node_tag);
                }
            }
        }
        root.appendChild(node_META);
        
        return xmlDoc;
    },

    xml2str_v1: function(xmlDoc, pretty) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n' + xmlStr;
        }

        if (typeof(pretty)=='undefined') {
            pretty = true;
        }

        if (pretty) {
            // var pretty_xmlStr = vkbeautify.xml(xmlStr, 0);
            // return pretty_xmlStr;
            var format = require('xml-formatter');
            formattedXml = format(xmlStr, {
                indentation: ''
            });
        }

        return xmlStr;
    },

    xml2str: function(xml_doc) {
        const serializer = new XMLSerializer();
        var xml_str_TEXT = serializer.serializeToString(xml_doc.getElementsByTagName('TEXT')[0]);
        var xml_str_TAGS = serializer.serializeToString(xml_doc.getElementsByTagName('TAGS')[0]);
        var xml_str_META = serializer.serializeToString(xml_doc.getElementsByTagName('META')[0]);

        // format the XML to make it looks better for human
        var format = require('xml-formatter');
        var xml_str_TAGS_formatted = format(xml_str_TAGS, {
            indentation: ''
        });
        var xml_str_META_formatted = format(xml_str_META, {
            indentation: ''
        });

        var root_name = xml_doc.children[0].nodeName;

        var xml_str = [
            '<?xml version="1.0" encoding="UTF-8" ?>',
            '<' + root_name + '>',
            xml_str_TEXT,
            xml_str_TAGS_formatted,
            xml_str_META_formatted,
            '</' + root_name + '>'
        ].join('\n');

        return xml_str;
    },

    pretty_xml_str: function(xml_str) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function(index, node) {
            var indent = 0;
            if (node.match( /.+<\/\w[^>]*>$/ )) {
                indent = 0;
            } else if (node.match( /^<\/\w/ )) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    },


    ///////////////////////////////////////////////////////
    // Hint Dictionary related functions
    ///////////////////////////////////////////////////////

    /**
     * Convert a list of anns to hints as tag name dict
     * @param {object} dtd annotation dtd object
     * @param {list} anns a list of annotation objects
     */
    anns2hint_dict: function(dtd, anns) {
        var hint_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                this.add_tag_to_hint_dict(ann, tag, hint_dict);
            }
        }

        return hint_dict;
    },

    add_tag_to_hint_dict: function(ann, tag, hint_dict) {
        if (!hint_dict.hasOwnProperty(tag.tag)) {
            hint_dict[tag.tag] = {
                // text only
                text_dict: {}, 

                // non-consuming dict
                nc_dict: {
                    count: 0,
                    ann_fn_dict: {},
                    _is_shown: false,
                }, 

                // just a list of texts
                texts: []
            }
        }
        // empty text should be removed
        if (!tag.hasOwnProperty('text')) {
            // which means it's a link tag
            // we can do nothing to a link tag now
            return;
        }

        // now get the text and trim it
        var text = tag.text;
        text = text.trim();
        if (text == '') {
            // need to check if is a NC etag
            if (tag.spans == this.NON_CONSUMING_SPANS) {
                // add this nc etag
                if (hint_dict[tag.tag].nc_dict.ann_fn_dict.hasOwnProperty(ann._filename)) {
                    // oh, this is NOT a new file
                    // just increase the count for this concept and file
                    hint_dict[tag.tag].nc_dict.count += 1;
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] += 1
        
                } else {
                    // ok, this is a new file
                    // count +1
                    hint_dict[tag.tag].nc_dict.count += 1;
        
                    // save this ann file name
                    hint_dict[tag.tag].nc_dict.ann_fn_dict[ann._filename] = 1;
                }

                // ok, we have add this file information to the hint dict
                return hint_dict;

            } else {
                // ok, it's just a wrong hint I guess
                return hint_dict;
            }
        }

        // add this text
        if (hint_dict[tag.tag].text_dict.hasOwnProperty(text)) {
            // oh, this is NOT a new text
            // just increase the count
            hint_dict[tag.tag].text_dict[text].count += 1;
            if (hint_dict[tag.tag].text_dict[text].ann_fn_dict.hasOwnProperty(ann._filename)) {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] += 1;
            } else {
                hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
            }

        } else {
            // ok, this is a new text
            // count +1
            hint_dict[tag.tag].text_dict[text] = {
                count: 1,
                ann_fn_dict: {},
                _is_shown: false
            };

            // save this tag
            hint_dict[tag.tag].texts.push(text);

            // save this ann file name
            hint_dict[tag.tag].text_dict[text].ann_fn_dict[ann._filename] = 1;
        }

        return hint_dict;
    },

    /**
     * Search feasible hints to ranges for highlighting in codemirror
     * Those conflict / overlaped hints would be skiped
     * 
     * @param {object} hints The hints object contains all hint texts
     * @param {object} ann The annotation object which contains text and tags
     * @param {list} focus_tags The focused tags for searching
     */
    search_hints_in_ann: function(hint_dict, ann, focus_tags) {
        if (typeof(focus_tags) == 'undefined') {
            focus_tags = null;
        }
        var is_overlapped = function(a, b) {
            if (a[0] >= b[0] && a[0] < b[1]) {
                return true;
            }
            if (a[1] > b[0] && a[1] <= b[1]) {
                return true;
            }
            // the missing for contains
            if (a[0] <= b[0] && a[1] >= b[1]) {
                return true;
            }
            return false;
        }

        var is_overlapped_in_list = function(loc_x, loc_list) {
            for (let i = 0; i < loc_list.length; i++) {
                const loc = loc_list[i];
                if (is_overlapped(loc_x, loc)) {
                    return true;
                }
            }
            return false;
        }

        // for saving the locations of all marks 
        var loc_list = [];

        // for saving those hints need to be marked
        var hint_list = [];

        // for saving existing hint strs and mapping to tags
        var str_dict = {};

        // first, put existed ann tags in to mark dict
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (!tag.hasOwnProperty('spans')) {
                // which means it's a link tag
                continue;
            }
            // var spans = tag.spans.split(',');
            // for (let j = 0; j < spans.length; j++) {
            //     const span = spans[j];
            //     var loc = this.span2loc(span);
            //     loc_list.push(loc);
            // }
            var _locs = this.spans2locs(tag.spans);
            loc_list = loc_list.concat(_locs);
        }
        console.log('* created loc_list', loc_list);
        
        // check each tag in the hint
        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                // focus on specifed tag hint
                if (focus_tags == null) {
                    // ok, search all
                } else if (focus_tags.indexOf(tag_name)>=0) {
                    // ok, this tag need to search
                } else {
                    // wow, no need to search this tag
                    continue;
                }

                // check each str in this hint tag
                for (let i = 0; i < hint_dict[tag_name].texts.length; i++) {
                    const str = hint_dict[tag_name].texts[i];
                    // if this str exists, just skip
                    if (str_dict.hasOwnProperty(str)) { 
                        if (str_dict[str].tags.hasOwnProperty(tag_name)) {

                        } else {
                            str_dict[str].tags[tag_name] = 1;
                        }
                        continue; 
                    }

                    // put this str to global dict first
                    str_dict[str] = {
                        tags: {}
                    };
                    str_dict[str].tags[tag_name] = 1;

                    // then find the locs of this str in
                    var locs = this.get_locs(str, ann.text);

                    for (let j = 0; j < locs.length; j++) {
                        const loc = locs[j];
                        
                        // we need to check whether this loc exsits
                        if (is_overlapped_in_list(loc, loc_list)) {
                            // ok, skip this
                        } else {
                            // append this loc to the list
                            loc_list.push(loc);

                            // and add this loc as a new mark
                            hint_list.push({
                                id: 'hint-' + tag_name + '-' + i + '-' + j,
                                tag: tag_name,
                                text: str,
                                spans: this.loc2span(loc)
                            })
                        }
                    }
                }
            }
        }

        return hint_list;
    },

    get_stat_tokens_by_hint_dict: function(hint_dict) {
        var stat = {
            rs: []
        };

        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                const hint_info = hint_dict[tag_name];
                
                for (const text in hint_info.text_dict) {
                    if (Object.hasOwnProperty.call(hint_info.text_dict, text)) {
                        const text_info = hint_info.text_dict[text];

                        // how many anns/docs contain this text for this tag_name
                        var n_anns = Object.keys(text_info.ann_fn_dict).length;

                        // total count of this text for this tag_name in all anns/docs
                        var n_count = text_info.count;

                        // save this information
                        stat.rs.push({
                            text: text,
                            tag_name: tag_name,
                            n_count: n_count,
                            n_anns: n_anns
                        });
                    }
                }
            }
        }

        return stat;
    },

    ///////////////////////////////////////////////////////
    // Utils
    ///////////////////////////////////////////////////////
    get_locs: function(str, text) {
        // convert str to lower for ignore case?
        try {
            var regex = new RegExp('\\b' + str + '\\b', 'gmi');
        

            var m;
            var locs = [];
            while ((m = regex.exec(text)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
                
                // The result can be accessed through the `m`-variable.
                m.forEach((match, groupIndex) => {
                    locs.push([ m.index, regex.lastIndex]);
                });
            }

            return locs;
        } catch (error) {
            console.log("* couldn't create regex by", str);
            return [];
        }
    },

    get_text_by_spans: function(spans, full_text) {
        var locs = this.spans2locs(spans);
        var text = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            const _t = full_text.substring(
                loc[0],
                loc[1]
            );
            text.push(_t);
        }

        return text.join('...');
    },

    spans2locs: function(raw_spans) {
        // fix for the special convert
        raw_spans = raw_spans.replaceAll(';', ',');

        // split by comma
        var span_arr = raw_spans.split(',');
        var locs = [];
        for (let i = 0; i < span_arr.length; i++) {
            const span = span_arr[i];
            var loc = this.span2loc(span);

            if (loc == null) {

            } else {
                locs.push(loc);
            }
        }

        return locs;
    },

    span2loc: function(span) {
        var ps = span.split('~');
        var span_pos_0 = parseInt(ps[0]);
        var span_pos_1 = parseInt(ps[1]);

        if (isNaN(span_pos_0)) {
            return null;
        }
        if (isNaN(span_pos_1)) {
            return null;
        }
        return [
            span_pos_0,
            span_pos_1
        ];
    },

    loc2span: function(loc) {
        return loc[0] + '~' + loc[1];
    },

    locs2spans: function(locs) {
        var spans = [];
        for (let i = 0; i < locs.length; i++) {
            const loc = locs[i];
            var span = this.loc2span(loc);
            spans.push(span);
        }
        spans = spans.join(',');
        return spans;
    },

    hash: function(str, seed) {
        if (typeof(seed) == 'undefined') {
            seed = 0;
        }
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    get_next_tag_id: function(ann, tag_def) {
        var n = 0;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].tag == tag_def.name) {
                // get the id number of this tag
                var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
                if (_id >= n) {
                    n = _id + 1;
                }
            }
        }
        return tag_def.id_prefix + n;
    },

    get_tag_by_tag_id: function(tag_id, ann) {
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                return ann.tags[i];
            }                
        }
        return null;
    },

    get_linked_ltags: function(tag_id, ann) {
        var tags = [];
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            
            // check if this is itself
            if (tag.id == tag_id) {
                // skip this tag_id itself
                continue;
            }

            for (const attr in tag) {
                if (Object.hasOwnProperty.call(tag, attr)) {
                    if (attr == 'id'   || 
                        attr == 'tag'  ||
                        attr == 'text' ||
                        attr == 'spans'
                    ) {
                        // skip those special attrs
                        continue;
                    }
                    const val = tag[attr];
                    if (val == tag_id) {
                        // ok, this a link ... I guess 
                        tags.push(tag);

                        // then, we don't need to check other attr
                        // just go to next tag
                        break;
                    }
                }
            }
        }
        return tags;
    },


};

// The statistics helper
/**
 * A helper object for the statistics related functions
 */
var stat_helper = {
    /**
     * Get statistics of given anns on dtd
     * 
     * The return item should contain 3 sub-items:
     * [
     *     label
     *     value,
     *     extend_data
     * ]
     * 
     * The extend_data is an object
     * @param {list} anns anns
     * @param {Object} dtd dtd
     * @returns a list of stat results
     */
    get_stat_items: function(anns, dtd) {
        var items = [
            // the basic statistics
            ['# of documents', anns.length, null],
            ['# of tags in schema', dtd.etags.length, null],
            ['# of annotations', this.count_all_tags(anns), null],

            // the frequents
            [
                '# of annotations per tag', 
                this.calc_avg_tags_per_def(anns, dtd),
                null
            ],
            [
                '# of annotations per doc', 
                this.calc_avg_tags_per_doc(anns),
                null
            ],
            [
                '# of sentences',
                this.count_all_sentences(anns),
                null
            ],
            [
                '# of sentences per doc',
                this.calc_avg_sentences_per_doc(anns),
                null
            ],
            
        ];

        // the number by tags
        var cnt = this.count_tags_by_concepts(anns, dtd);
        for (const tag_name in cnt) {
            if (Object.hasOwnProperty.call(cnt, tag_name)) {
                const val = cnt[tag_name];

                // create a html 
                items.push([
                    '# of ' + tag_name,
                    val,
                    {
                        stat_type: 'tag_count',
                        tag: tag_name
                    }
                ]);
            }
        }

        return items;
    },

    /**
     * Get the statistics summary in JSON format
     * @param {list} raw_summary the raw summary list
     */
    get_stat_summary_json: function(raw_summary) {
        var json = [];

        for (let i = 0; i < raw_summary.length; i++) {
            const s = raw_summary[i];
            json.push({
                'measure': s[0],
                'result': s[1]
            });
        }

        return json;
    },

    /**
     * Get the worksheet of the summary
     * @param {list} raw_summary the raw summary list
     * @returns a XLSX worksheet object 
     */
    get_stat_summary_excelws: function(raw_summary) {
        var js = this.get_stat_summary_json(raw_summary);

        var ws = XLSX.utils.json_to_sheet(js);

        return ws;
    },

    get_stat_docs_by_tags_json: function(anns, dtd) {
        var js = {
            stat: {
                max_by_ann_tag: 0,
                max_by_ann: 0,
                max_by_tag: 0
            },
            rs: [{
                'file_name': 'Summary',
                '_total_tags': 0
            }]
        };

        for (let i = 0; i < anns.length; i++) {
            // each ann is a document
            const ann = anns[i];

            // create a new json object
            var j = {
                'file_name': ann._filename,
                '_total_tags': 0
            };
            
            // to make sure the order of tags, use two loops
            // first, init all the etags
            for (let k = 0; k < dtd.etags.length; k++) {
                const tag = dtd.etags[k];
                // init this tag count
                j[tag.name] = 0;

                // init the first row if not 
                if (!js.rs[0].hasOwnProperty(tag.name)) {
                    js.rs[0][tag.name] = 0;
                }
            }

            // then, init all ltags
            for (let k = 0; k < dtd.ltags.length; k++) {
                const tag = dtd.ltags[k];
                // init this tag count
                j[tag.name] = 0;

                // init the first row if not 
                if (!js.rs[0].hasOwnProperty(tag.name)) {
                    js.rs[0][tag.name] = 0;
                }
            }

            // now, we can count how many tags in this doc
            for (let k = 0; k < ann.tags.length; k++) {
                const tag = ann.tags[k];
                // update the count for this tag
                j[tag.tag] += 1;

                // add a count for max result
                if (j[tag.tag] > js.stat.max_by_ann_tag) {
                    js.stat.max_by_ann_tag = j[tag.tag]
                }

                // update the total of this file
                j['_total_tags'] += 1;

                // update the summary of this concept
                js.rs[0][tag.tag] += 1;

                // add a count for max result
                if (js.rs[0][tag.tag] > js.stat.max_by_tag) {
                    js.stat.max_by_tag = js.rs[0][tag.tag]
                }

                // update the summary of all
                js.rs[0]['_total_tags'] += 1;
            }

            // update the max_by_ann
            if (ann.tags.length > js.stat.max_by_ann) {
                js.stat.max_by_ann = ann.tags.length;
            }

            // ok, done! let's put this j to js list
            js.rs.push(j);
        }

        return js;
    },

    get_stat_docs_by_tags_excelws: function(ann, dtd) {
        var stat = this.get_stat_docs_by_tags_json(ann, dtd);
        var js = stat.rs;

        var ws = XLSX.utils.json_to_sheet(js);

        // now add color to the number cells
        // first, get the max number
        // because the number is counted
        var n_max = this.__get_max_val(js);
        // set a min threshold for this max value
        if (n_max < 10) {
            n_max = 10;
        }
        var func_val2color = function(val) {
            return d3.rgb(
                d3.interpolateReds(val / n_max)
            ).formatHex();
        }
        var func_val2fontc = function(val) {
            if (val / n_max > 0.7) {
                return '#ffffff';
            } else {
                return '#000000';
            }
        }

        // now, check each cell
        for (const coord in ws) {
            if (Object.hasOwnProperty.call(ws, coord)) {
                const obj = ws[coord];
                // skip the system attr
                if (obj.hasOwnProperty('v')) {
                    if (typeof(obj.v) == 'number') {
                        // skip the sum
                        if (coord.startsWith('B')) {
                            continue;
                        }

                        // which means this is a count number
                        // create a color
                        var fg_color = func_val2color(obj.v);
                        var font_color = '#000000';
                        if (obj.v == 0) {
                            fg_color = '#ffffff';
                            font_color = '#cccccc';
                        } else {
                            font_color = func_val2fontc(obj.v);
                        }

                        // set this color
                        ws[coord].s = {
                            fill: {
                                fgColor: {
                                    rgb: fg_color.substring(1)
                                }
                            },
                            font: {
                                color: {
                                    rgb: font_color.substring(1)
                                }
                            }
                        }
                    } else if (typeof(obj.v) == 'string') {
                        // we want to set color for the header
                        if (dtd.tag_dict.hasOwnProperty(obj.v)) {
                            // ok, this is a tag name
                            ws[coord].s = {
                                fill: {
                                    fgColor: {
                                        rgb: dtd.tag_dict[obj.v].style.color.substring(1)
                                    }
                                },
                                font: {
                                    sz: 14
                                }
                            }
                        }
                    } else {
                        // ok, other cell?
                    }
                }
            }
        }

        return ws;
    },


    /**
     * Count the total number of all annotated tags
     * @param {list} anns the anns from vpp
     * @returns the total number annotated tags
     */
    count_all_tags: function(anns) {
        var n = 0;
        for (let i = 0; i < anns.length; i++) {
            for (let j = 0; j < anns[i].tags.length; j++) {
                n += 1;
            }
        }
        return n;
    },

    /**
     * Count the total number of split sentences
     * @param {list} anns the anns from vpp
     * @returns the total number of sentences
     */
    count_all_sentences: function(anns) {
        var n = 0;
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            if (ann.hasOwnProperty('_sentences')) {
                n += ann._sentences.length;
            }
        }
        return n;
    },

    count_tags_by_concepts: function(anns, dtd) {
        var cnt = {};

        for (const tag_name in dtd.tag_dict) {
            if (Object.hasOwnProperty.call(dtd.tag_dict, tag_name)) {
                const tag_def = dtd.tag_dict[tag_name];
                cnt[tag_def.name] = 0;
            }
        }
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                cnt[tag.tag] += 1;
            }
        }

        return cnt;
    },

    calc_avg_sentences_per_doc: function(anns) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        var t = this.count_all_sentences(anns);
        return (t/anns.length).toFixed(2);
    },

    calc_avg_tags_per_doc: function(anns) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        var t = this.count_all_tags(anns);
        return (t/anns.length).toFixed(2);
    },

    calc_avg_tags_per_def: function(anns, dtd) {
        if (anns == null || anns.length == 0) {
            return '-';
        }
        if (dtd == null || dtd.etags.length == 0) {
            return '-';
        }
        return (anns.length / dtd.etags.length).toFixed(2);
    },

    /**
     * stat_helper internal use only
     * @param {list} json the json for the stat report
     * @returns the max value
     */
    __get_max_val: function(json) {
        var max_val = 0;
        // skip the summary, so skip the first row in json
        for (let i = 1; i < json.length; i++) {
            const obj = json[i];
            for (const key in obj) {
                if (key == '_total_tags') {
                    // skip the total column
                    continue;
                }
                if (Object.hasOwnProperty.call(obj, key)) {
                    const val = obj[key];
                    if (val > max_val) {
                        max_val = val;
                    }
                }
            }
        }

        return max_val;
    }
};

// The BioC parser
/**
 * BioC format annotation file parser
 */
var bioc_parser = {

    NON_CONSUMING_SPANS: '-1~-1',

    anns2xml: function(anns, dtd) {
        // create the root document
        var xmlDoc = document.implementation.createDocument(
            null, 'collection'
        );
        var root = xmlDoc.getElementsByTagName('collection')[0];

        // create an empty source tag
        var elem_source = xmlDoc.createElement('source');
        root.appendChild(elem_source);

        // create a date tag
        var elem_date = xmlDoc.createElement('date');
        elem_date.innerHTML = "" + new Date();
        root.appendChild(elem_date);

        // create an empty key tag
        var elem_key = xmlDoc.createElement('key');
        root.appendChild(elem_key);

        // create document for each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // create a document tag for this ann
            var elem_doc = xmlDoc.createElement('document');

            // add filename as id to this document
            var elem_id = xmlDoc.createElement('id');
            elem_id.innerHTML = ann._filename;
            elem_doc.appendChild(elem_id);

            // there is only one passage for this doc
            var elem_passage = xmlDoc.createElement('passage');

            // add the offset 0 to this passage
            var elem_poffset = xmlDoc.createElement('offset');
            elem_poffset.innerHTML = '0';
            elem_passage.appendChild(elem_poffset);

            // add the text to this passage
            var elem_ptext = xmlDoc.createElement('text');
            elem_ptext.appendChild(
                xmlDoc.createTextNode(ann.text)
            );
            elem_passage.appendChild(elem_ptext);

            // add all entity tags to this passage
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                
                // get the tag def from dtd
                var tag_def = dtd.tag_dict[tag.tag];

                if (tag_def.type == 'etag') {
                    // ok, it is a entity tag
                    // due to the fact of non-continous annoation,
                    // we need to check the spans first
                    var locs = ann_parser.spans2locs(tag.spans);

                    // for most of time, there is only one loc
                    // but sometimes, there are more
                    for (let k = 0; k < locs.length; k++) {
                        const loc = locs[k];

                        // get the attribute for the location element
                        var att_len = loc[1] - loc[0];
                        var att_ofs = loc[0];

                        // each entity tag is an annotation element 
                        var elem_ann = xmlDoc.createElement('annotation');
                        // set the ann elem id 
                        if (locs.length == 1) {
                            // if this is only one loc, just use the id
                            elem_ann.setAttribute('id', tag.id);
                        } else {
                            // otherwise, add suffix
                            elem_ann.setAttribute('id', tag.id + '_' + k);
                        }

                        // create location elements for this ann
                        var elem_location = xmlDoc.createElement('location');
                        elem_location.setAttribute('length', att_len);
                        elem_location.setAttribute('offset', att_ofs);
                        elem_ann.appendChild(elem_location);

                        // set the text content for this annotation
                        var elem_atext = xmlDoc.createElement('text');
                        var atext = ann.text.substring(loc[0], loc[1]);
                        elem_atext.appendChild(
                            xmlDoc.createTextNode(atext)
                        );
                        elem_ann.appendChild(elem_atext);

                        // ok, let's put other elements in this annotation
                        for (const key in tag) {
                            if (Object.hasOwnProperty.call(tag, key)) {
                                const val = tag[key];
                                if (['id','spans','text','tag'].contains(key)) {
                                    // these keys can be skipped
                                    continue;
                                }
                                
                                // for other key, need to create a infon element
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                elem_infon.innerHTML = val;

                                // ok, add this infon to this annotation
                                elem_ann.appendChild(elem_infon);
                            }
                        }
                        // finally, add this ann to the passage
                        elem_passage.appendChild(elem_ann);
                    }

                } else if (tag_def.type == 'ltag') {
                    // ok, it is a link tag

                    // each link tag is an relation element 
                    var elem_rel = xmlDoc.createElement('relation');
                    // set the id
                    elem_rel.setAttribute('id', tag.id);

                    // let's check each value
                    // ok, let's put other elements in this relation
                    for (const key in tag) {
                        if (Object.hasOwnProperty.call(tag, key)) {
                            const val = tag[key];
                            if (['id','spans','text','tag'].contains(key)) {
                                // these keys can be skipped
                                continue;
                            }
                            
                            // for other key, need to check attr type first
                            var att_def = tag_def.attlist_dict[key];

                            if (att_def.vtype == 'idref') {
                                // for idref type, need to create node
                                var elem_node = xmlDoc.createElement('node');
                                // set the refid
                                elem_node.setAttribute('refid', val);
                                // set the role as the attr name
                                elem_node.setAttribute('role', att_def.name);

                                // add this node
                                elem_rel.appendChild(elem_node);

                            } else {
                                // for other types, just create a infon
                                var elem_infon = xmlDoc.createElement('infon');
                                elem_infon.setAttribute('key', key);
                                elem_infon.innerHTML = val;

                                // ok, add this infon to this annotation
                                elem_rel.appendChild(elem_infon);
                            }
                        }
                    }

                    // ok, save this relation
                    // finally, add this relation to the passage
                    elem_passage.appendChild(elem_rel);

                } else {
                    // what???

                }
            }

            // add this passage to the doc
            elem_doc.appendChild(elem_passage);

            // add this doc to the collection
            root.appendChild(elem_doc);
        }

        return xmlDoc;
    },

    xml2str: function(xmlDoc) {
        const serializer = new XMLSerializer();
        var xmlStr = serializer.serializeToString(xmlDoc);

        // fix missing 
        if (xmlStr.startsWith('<?xml')) {
            // nothing, it' OK
        } else {
            xmlStr = '<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE collection SYSTEM "BioC.dtd">\n' + xmlStr;
        }
        return xmlStr;
    },

    /**
     * Download the BioC format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     * @param {string} fn the download file name
     */
     download_dataset_bioc: function(anns, dtd, fn) {
        // get the xml doc
        var xmlDoc = this.anns2xml(anns, dtd);

        // get the string for xml
        var xmlStr = this.xml2str(xmlDoc);

        // download
        var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
        saveAs(blob, fn);

        return xmlStr;
     }
};

// The Rulepack toolkit
/**
 * Easy Rule Pack Toolkit
 */
var erp_toolkit = {
    rp: {
        prefix: {
            rsregexp: 'resources_regexp_re'
        }
    },

    ///////////////////////////////////////////////////////
    // Rule Pack Functions
    ///////////////////////////////////////////////////////
    create_new_rulepack: function () {
        return {
            name: '',
            matchrules: [ ],
            rsregexps: [ ],
            contexts: [ ],
            fns: {
                used_resources: 'used_resources.txt',
                resources_rules_matchrules: 'resources_rules_matchrules.txt'
            }
        };
    },

    create_new_matchrule: function () {
        return {
            rule_name: 'cm_fever',
            regexp: '\\b(?i)(?:%reFEVER)\\b',
            location: 'NA',
            enabled: true,
            ignore_case: true,
            norm: 'FEVER'
        };
    },

    create_new_rsregexp: function () {
        return {
            name: 'FEVER',
            text: 'fever\nfebris\nfebrile'
        };
    },

    create_new_context: function() {
        var num = 0;
        if (this.vpp != null) {
            if (this.vpp.rulepack != null) {
                if (typeof(this.vpp.rulepack) != 'undefined') {
                    if (typeof(this.vpp.rulepack.contexts) != 'undefined') {
                        num = this.vpp.rulepack.contexts.length;
                    }
                }
            }
        }
        return {
            name: 'contextRule' + num,
            text: erp_toolkit.MEDTAGGER_CONTEXT_RULE
            // text: 'regex:(^|\s)\?(?=\s?\w+)~|~pre~|~poss~|~1\ndoes not demonstrate~|~pre~|~neg~|~1\ndid not demonstrate~|~pre~|~neg~|~1\ndo not demonstrate~|~pre~|~neg~|~1'
        };
    },

    rulepack2zip: function(rulepack) {
        var zip = new JSZip();

        // create the file list of regexp
        var txt_fns = '';
        for (var i = 0; i < rulepack.rsregexps.length; i++) {
            var rsregexp = rulepack.rsregexps[i];
            var ffn = 'regexp/' + this.rp.prefix.rsregexp + rsregexp.name + '.txt';
            var txt = rsregexp.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }
        
        // create the context rules
        for (var i = 0; i < rulepack.contexts.length; i++) {
            var context = rulepack.contexts[i];
            var ffn = 'context/' + context.name + '.txt';
            var txt = context.text;
            txt_fns += './' + ffn + '\n';
            // add to zip
            zip.file(ffn, txt);
            console.log('* add ' + ffn);
        }

        // create the rule file
        var rules = '// ' + rulepack.name + '\n';
        for (let i = 0; i < rulepack.matchrules.length; i++) {
            const matchrule = rulepack.matchrules[i];
            rules += 'RULENAME="' + matchrule.rule_name + '",';
            rules += 'REGEXP="' + matchrule.regexp + '",';
            rules += 'LOCATION="' + matchrule.location + '",';
            rules += 'NORM="' + matchrule.norm + '"\n';
        }
        var rule_fn = 'rules/' + rulepack.fns.resources_rules_matchrules;
        txt_fns += './' + rule_fn + '\n';

        zip.file(rule_fn, rules);
        console.log('* add ' + rule_fn);

        // create the used_resources.txt
        txt_fns += './' + rulepack.fns.used_resources + '\n';
        zip.file(rulepack.fns.used_resources, txt_fns);

        return zip;
    },
    
    ///////////////////////////////////////////////////////
    // Easy Pack Functions
    ///////////////////////////////////////////////////////
    create_new_easypack: function(rule_pack_name) {
        if (typeof(rule_pack_name)=='undefined') {
            rule_pack_name = 'rule_pack_name';
        }
        return {
            name: rule_pack_name,
            contexts: [ this.create_new_context() ],
            ergroups: [ ]
        }
    },

    create_new_ergroup: function(norm, text) {
        // set the default norm
        if (typeof(norm) == 'undefined') {
            norm = 'NAME_' + this.mkid(6);
        } else {
            norm = norm.toLocaleUpperCase();
        }

        // set the default text
        if (typeof(text) == 'undefined') {
            text = '';
        }

        return {
            _is_shown: false,
            norm: norm,
            rule_type: 'cm',
            location: 'NA',
            text: text
        };
    },

    anns2text_dict: function(anns) {
        var text_dict = {};

        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                // create the tag_def if not exists
                if (!text_dict.hasOwnProperty(tag.tag)) {
                    // the text_dict is for searching
                    // the texts is for storing
                    text_dict[tag.tag] = {
                        textd: {},
                        texts: []
                    };
                }

                // empty text should be removed

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }

                var text = tag.text;
                text = text.trim();
                if (text == '') {
                    continue;
                }

                if (text_dict[tag.tag].textd.hasOwnProperty(text)) {
                    // oh, this is NOT a new text
                    // just increase the count
                    text_dict[tag.tag].textd[text] += 1;

                } else {
                    // ok, this is a new text
                    // count +1
                    text_dict[tag.tag].textd[text] = 1;

                    // save this tag
                    text_dict[tag.tag].texts.push(text);
                }
            }
        }

        return text_dict;
    },

    anns2easypack: function(anns, dtd) {
        // first, create an empty easypack
        var easypack = this.create_new_easypack(dtd.name);

        // then create ergroup_dict
        var ergroup_dict = {};

        // using the dtd to init the ergroup_dict
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag = dtd.etags[i];
            
            // create a new ergroup from this tag
            var ergroup = this.create_new_ergroup(tag.name, '');

            // put this ergroup to the dict for furture use
            ergroup_dict[tag.name] = ergroup;
        }

        // then, using the anns to fill the text of each ergroup
        var text_dict = this.anns2text_dict(anns);

        // using this text_dict to fill the ergroup_dict
        for (const tag_name in text_dict) {
            if (Object.hasOwnProperty.call(text_dict, tag_name)) {
                // check each text in each tag_name
                for (let k = 0; k < text_dict[tag_name].texts.length; k++) {
                    const text = text_dict[tag_name].texts[k];

                    // just append this text as a new line
                    ergroup_dict[tag_name].text += text + '\n';
                }
            }
        }

        // last, put the ergroup_dict to easypack.ergroups
        for (const tag_name in ergroup_dict) {
            if (Object.hasOwnProperty.call(ergroup_dict, tag_name)) {
                easypack.ergroups.push(ergroup_dict[tag_name]);
            }
        }

        return easypack;
    },

    easypack2rulepack: function(easypack) {
        // create an empty rule pack for converting
        var rulepack = this.create_new_rulepack();
    
        // now update the simple parts according to the easypack
        rulepack.name = easypack.name;
        rulepack.contexts = easypack.contexts;

        // now update the complex parts according to the easypack
        for (let i = 0; i < easypack.ergroups.length; i++) {
            const ergroup = easypack.ergroups[i];
            var regexp_name = this.norm2regexp_name(ergroup.norm);
            var cm_name = regexp_name.toLowerCase();
            
            // create a matchrule
            var matchrule = this.create_new_matchrule();

            // update the matchrule
            // norm is just the norm
            matchrule.norm = ergroup.norm;
            // location is just the location
            matchrule.location = ergroup.location;
            // rule_name is the comb of rule_type and cm_name
            matchrule.rule_name = ergroup.rule_type + '_' + cm_name;
            // regexp is the comb of regexp_name according to the rule_type
            if (ergroup.rule_type == 'cm') {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';

            } else if (ergroup.rule_type == 'rem') {
                matchrule.regexp = '\\b(?i)%re'+regexp_name+'\\b';

            } else {
                matchrule.regexp = '\\b(?i)(?:%re'+regexp_name+')\\b';
            }

            // create a rsregexp(?i)
            var rsregexp = this.create_new_rsregexp();

            // update the rsregexp
            rsregexp.name = regexp_name;
            rsregexp.text = ergroup.text;

            // save the new matchrule and rsregexp
            rulepack.matchrules.push(matchrule);
            rulepack.rsregexps.push(rsregexp);
        }

        return rulepack;
    },
    
    ///////////////////////////////////////////////////////
    // Other Functions
    ///////////////////////////////////////////////////////
    mkid: function(length) {
        var result           = '';
        var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var charactersLength = characters.length;
        for ( var i = 0; i < length; i++ ) {
            result += characters.charAt(
                Math.floor(Math.random() * charactersLength)
            );
        }
       return result;
    },

    /**
     * Convert the norm to a valid regexp name
     * 
     * @param {string} norm 
     */
    norm2regexp_name: function(norm) {
        return norm.replace(/_/g, "");
    },

    download_zip: function(zip, fn) {
        zip.generateAsync({ type: "blob" }).then((function(fn){
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));
    },

    download_anns_as_zip: function(anns, dtd, fn) {
        // first, convert anns to easypack
        var easypack = this.anns2easypack(anns, dtd);

        // second, convert easypack to rulepack
        var rulepack = this.easypack2rulepack(easypack);

        // then convert this easypack to zip
        var zip = this.rulepack2zip(rulepack)

        // last, save this zip
        this.download_zip(zip, fn);

        return rulepack;
    },

    MEDTAGGER_CONTEXT_RULE: `// Format regex:?match_string~|~trigger_type~|~context_type~|~rule_priority(~|~window_size_override)?
// JW added start
regex:\?( ?\w+)?~|~pre~|~poss~|~1
does not demonstrate~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
do not demonstrate~|~pre~|~neg~|~1
regex:\bdo not see (\S+\s+){1,3}that suggests?\b~|~pre~|~neg~|~2
complications include~|~pre~|~hypo~|~1
complications include,~|~pre~|~hypo~|~1
given some brief thought to~|~pre~|~poss~|~1
never been high enough to cause~|~pre~|~poss~|~1
regex:\bno (\S+\s+){1,3} (to|that) suggests?\b~|~pre~|~neg~|~2
// AW added start
which demonstrates~|~termin~|~poss~|~1
interested in~|~pre~|~poss~|~1
etiology indeterminate~|~pseudo~|~poss~|~1
patient and family~|~pseudo~|~exp~|~1
patient and his husband~|~pseudo~|~exp~|~1
patient and her husband~|~pseudo~|~exp~|~1
patient and his wife~|~pseudo~|~exp~|~1
patient and her wife~|~pseudo~|~exp~|~1
patient and his family~|~pseudo~|~exp~|~1
patient and her family~|~pseudo~|~exp~|~1
patient and husband~|~pseudo~|~exp~|~1
patient and wife~|~pseudo~|~exp~|~1
family in the room~|~pseudo~|~exp~|~1
regex:(query|alternative)(?=\s(\S+\s+){1,3}(versus|vs))~|~pre~|~poss~|~1
does not suggest~|~pre~|~neg~|~2
do not suggest~|~pre~|~neg~|~2
did not suggest~|~pre~|~neg~|~2
not suggest~|~pseudo~|~poss~|~1
investigated for~|~pre~|~poss~|~1
investigating for~|~pre~|~poss~|~1
investigate for~|~pre~|~poss~|~1
regex:\bnot? (\S+\s+){1,5}due\b~|~pseudo~|~neg~|~1
no overt~|~pre~|~poss~|~2
likely due to~|~post~|~poss~|~1
resolution of~|~pre~|~neg~|~1
no progression of the~|~pseudo~|~neg~|~1
because~|~termin~|~neg~|~1
consideration given history~|~post~|~hypo~|~1
considered given history~|~post~|~hypo~|~1
consideration given history~|~pre~|~hist~|~1
considered given history~|~pre~|~hist~|~1
patient had~|~termin~|~neg~|~1
patient had~|~pre~|~hist~|~1
was diagnosed~|~termin~|~neg~|~1
was diagnosed~|~pre~|~hist~|~1
regex:;\b~|~termin~|~neg~|~1
from~|~termin~|~poss~|~1
from~|~termin~|~neg~|~1
maybe~|~pre~|~poss~|~1
no date~|~pseudo~|~neg~|~1
no date:~|~pseudo~|~neg~|~1
not limited~|~pseudo~|~neg~|~1
regex:\bfamily history\s*$~|~post~|~exp~|~2
regex:\bfamily history\s*$~|~post~|~hist~|~2
didn't have~|~pre~|~neg~|~1
don't have~|~pre~|~neg~|~1
never used~|~pre~|~neg~|~1
no question~|~pseudo~|~neg~|~1
her2 negative~|~pseudo~|~neg~|~1
who also had~|~pseudo~|~hypoexp~|~1
symptomatology~|~post~|~poss~|~1
pmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~hist~|~1
fmhx~|~pre~|~exp~|~1
family history~|~pre~|~exp~|~1
family history~|~pre~|~hist~|~1
family member~|~pre~|~exp~|~1
likely to pursue~|~pseudo~|~poss~|~1
likely success~|~pseudo~|~poss~|~1
likely failure~|~pseudo~|~poss~|~1
cousin~|~pre~|~exp~|~1
cousins~|~pre~|~exp~|~1
regex:\basymptomatic\s*$~|~post~|~poss~|~2
// AW added end
//KER added start
trace~|~pre~|~poss~|~1
prn~|~pre~|~hypo~|~1
possible~|~pre~|~hypo~|~1
potential~|~pre~|~poss~|~1
mild~|~pre~|~poss~|~1
will be considered~|~post~|~hypo~|~1
would be considered~|~post~|~hypo~|~1
should be considered~|~post~|~hypo~|~1
considered~|~pre~|~hypo~|~1
consider~|~pre~|~hypo~|~1
consideration~|~pre~|~hypo~|~1
should consider~|~pre~|~hypo~|~1
should have~|~pre~|~hypo~|~1
should be offered~|~pre~|~hypo~|~1
scheduled~|~pre~|~hypo~|~1
planned~|~pre~|~hypo~|~1
plans for~|~pre~|~hypo~|~1
plan for~|~pre~|~hypo~|~1
plans are~|~pre~|~hypo~|~1
candidate for~|~pre~|~hypo~|~1
not a candidate for~|~pre~|~neg~|~1
not be a candidate for~|~pre~|~neg~|~1
put off~|~pre~|~hypo~|~1
    vs ~|~pre~|~hypo~|~1
discuss~|~pre~|~hypo~|~1
discussed~|~pre~|~hypo~|~1
discussion~|~pre~|~hypo~|~1
versus~|~pre~|~hypo~|~1
referred~|~pre~|~hypo~|~1
advised~|~pre~|~hypo~|~1
chance~|~pre~|~hypo~|~1
risky~|~post~|~poss~|~1
recommended~|~post~|~poss~|~1
if experiences worsening~|~pre~|~hypo~|~1
does not have~|~pre~|~neg~|~1
doesn't have~|~pre~|~neg~|~1
doesn't appear to have~|~pre~|~neg~|~1
does not appear to have~|~pre~|~neg~|~1
excluding~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
differential diagnosis~|~pre~|~poss~|~1
would not want to have~|~pre~|~neg~|~1
decline~|~pre~|~neg~|~1
declined~|~pre~|~neg~|~1
//KER added end
//Sunghwan added start
appear~|~pre~|~poss~|~1
appears~|~pre~|~poss~|~1
suspect~|~pre~|~poss~|~1
suspects~|~pre~|~poss~|~1
//appears? to have~|~pre~|~poss //not working why??
to evaluate~|~pre~|~poss~|~1
indeterminate~|~post~|~poss~|~1
indeterminable~|~pre~|~poss~|~1
to prevent~|~pre~|~hypo~|~1
has been instructed~|~pre~|~hypo~|~1
has been instructed in the sign~|~pre~|~hypo~|~1
has been instructed in the signs~|~pre~|~hypo~|~1
should the patient develop~|~pre~|~hypo~|~1
regex:\bno$~|~post~|~neg~|~1
//Sunghwan added end
//following two not working why??
none current~|~post~|~neg~|~1
no current~|~post~|~neg~|~1
hx~|~pre~|~hist~|~1
previous~|~pre~|~hist~|~1
previously~|~pre~|~hist~|~1
previously undergone~|~pre~|~hist~|~1
after undergoing~|~pre~|~hist~|~1
deny~|~pre~|~neg~|~1
no:~|~pre~|~neg~|~1
no :~|~pre~|~neg~|~1
(no~|~pre~|~neg~|~1
--no~|~pre~|~neg~|~1
don't sound like~|~pre~|~neg~|~1
doesn't sound like~|~pre~|~neg~|~1
regex:-? all of which(\s+\S+){0,3} (denies|denied)\b~|~post~|~neg~|~1
denies any of the following symptoms:~|~pre~|~neg~|~1
denies, however,~|~pre~|~neg~|~1
denies any associated~|~pre~|~neg~|~1
denies any significant~|~pre~|~neg~|~1
precaution for~|~pre~|~poss~|~1
resection of~|~pre~|~hist~|~1
debridement of~|~pre~|~hist~|~1
indication for~|~pre~|~hist~|~1
admitted for~|~pre~|~hist~|~1
likely~|~pre~|~poss~|~1
did deny~|~pre~|~neg~|~1
no source of~|~pre~|~poss~|~1
no source for~|~pre~|~poss~|~1
did not show much of~|~pre~|~poss~|~1
did not show much for~|~pre~|~poss~|~1
no definite finding for~|~pre~|~poss~|~1
no definite finding of~|~pre~|~poss~|~1
no definite findings for~|~pre~|~poss~|~1
no definite findings of~|~pre~|~poss~|~1
concern about~|~pre~|~poss~|~1
concerned about~|~pre~|~poss~|~1
would~|~pre~|~poss~|~1
could have~|~pre~|~poss~|~1
may have~|~pre~|~poss~|~1
raise the question of~|~pre~|~poss~|~1
raise the question for~|~pre~|~poss~|~1
raises the question of~|~pre~|~poss~|~1
raises the question for~|~pre~|~poss~|~1
highly unlikely~|~pre~|~poss~|~1
did not show any~|~pre~|~neg~|~1
do not show any~|~pre~|~neg~|~1
does not show any~|~pre~|~neg~|~1
suspicious for~|~pre~|~poss~|~1
suspicion for~|~pre~|~poss~|~1
suspicious of~|~pre~|~poss~|~1
suspicion of~|~pre~|~poss~|~1
a question of~|~pre~|~poss~|~1
a question for~|~pre~|~poss~|~1
without evidence of~|~pre~|~neg~|~1
without evidence for~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
without sign for~|~pre~|~neg~|~1
without signs of~|~pre~|~neg~|~1
without signs for~|~pre~|~neg~|~1
did not demonstrate~|~pre~|~neg~|~1
suggests~|~pre~|~poss~|~1
suggest~|~pre~|~poss~|~1
neg of~|~pre~|~neg~|~1
neg for~|~pre~|~neg~|~1
whether~|~pre~|~hypo~|~1
sound more like~|~pre~|~poss~|~1
sound like~|~pre~|~poss~|~1
sounds more like~|~pre~|~poss~|~1
sounds like~|~pre~|~poss~|~1
look more like~|~pre~|~poss~|~1
look like~|~pre~|~poss~|~1
looks more like~|~pre~|~poss~|~1
looks like~|~pre~|~poss~|~1
review the use~|~pre~|~poss~|~1
reviewed~|~pre~|~poss~|~1
likely~|~post~|~poss~|~1
will have~|~pre~|~hypo~|~1
may be~|~pre~|~poss~|~1
for excluding~|~pre~|~poss~|~1
potentially represent~|~pre~|~poss~|~1
possibility of~|~pre~|~poss~|~1
possibility for~|~pre~|~poss~|~1
should symptoms suggesting~|~pre~|~poss~|~1
look for~|~pre~|~hypo~|~1
no evidence of~|~pre~|~neg~|~1
no evidences of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
no evidences for~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no sign for~|~pre~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no signs for~|~pre~|~neg~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high-risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high risk that she is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high risk that the patient is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high-risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
high risk that he is at for~|~pre~|~hypo~|~1
risk of~|~pre~|~hypo~|~1
risk for~|~pre~|~hypo~|~1
risks of~|~pre~|~hypo~|~1
risks for~|~pre~|~hypo~|~1
cardiovascular risk~|~pseudo~|~hypo~|~1
cardiovascular risks~|~pseudo~|~hypo~|~1
risk~|~pre~|~hypo~|~1
risks~|~pre~|~hypo~|~1
s/p~|~pre~|~hist~|~1
at high-risk of~|~pre~|~hypo~|~1
at high-risk for~|~pre~|~hypo~|~1
at high risk of~|~pre~|~hypo~|~1
at high risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
at risk of~|~pre~|~hypo~|~1
at-risk for~|~pre~|~hypo~|~1
re-assess~|~pre~|~hypo~|~1
reassess~|~pre~|~hypo~|~1
assess~|~pre~|~hypo~|~1
prior~|~pre~|~hist~|~1
pmh of~|~pre~|~hist~|~1
pmh for~|~pre~|~hist~|~1
concern~|~pre~|~poss~|~1
concerning~|~pre~|~poss~|~1
is concerned~|~post~|~poss~|~1
is concerned of~|~pre~|~poss~|~1
is concerned for~|~pre~|~poss~|~1
a concern of~|~pre~|~poss~|~1
a concern for~|~pre~|~poss~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is potentional~|~post~|~poss~|~1
no overt clinical sign of~|~pre~|~neg~|~1
no overt clinical sign for~|~pre~|~neg~|~1
no overt clinical signs of~|~pre~|~neg~|~1
no overt clinical signs for~|~pre~|~neg~|~1
monitor of~|~pre~|~hypo~|~1
monitor for~|~pre~|~hypo~|~1
no source of~|~pre~|~neg~|~1
no source for~|~pre~|~neg~|~1
was ruled out of~|~pre~|~neg~|~1
is ruled out of~|~pre~|~neg~|~1
was ruled out for~|~pre~|~neg~|~1
is ruled out for~|~pre~|~neg~|~1
no evidence of~|~pre~|~neg~|~1
no evidence for~|~pre~|~neg~|~1
was negative of~|~pre~|~neg~|~1
was negative for~|~pre~|~neg~|~1
is negative of~|~pre~|~neg~|~1
is negative for~|~pre~|~neg~|~1
probable~|~pre~|~poss~|~1
possible~|~pre~|~poss~|~1
potential~|~pre~|~poss~|~1
probable for~|~pre~|~poss~|~1
probable of~|~pre~|~poss~|~1
possible of~|~pre~|~poss~|~1
possible for~|~pre~|~poss~|~1
potential of~|~pre~|~poss~|~1
potential for~|~pre~|~poss~|~1
negative~|~pre~|~neg~|~1
is possible~|~post~|~poss~|~1
is probable~|~post~|~poss~|~1
is negative~|~post~|~neg~|~1
was possible~|~post~|~poss~|~1
was probable~|~post~|~poss~|~1
was negative~|~post~|~neg~|~1
regex::\s*no\s*(?:$|[,.!?])~|~post~|~neg~|~2
regex::\s*none\s*(?:$|[,.!?])~|~post~|~neg~|~2
asymptomatic~|~pre~|~poss~|~1
//Hongfang added end
absence of~|~pre~|~neg~|~1
absence for~|~pre~|~neg~|~1
adequate to rule her out~|~pre~|~neg~|~1
adequate to rule him out~|~pre~|~neg~|~1
adequate to rule out~|~pre~|~neg~|~1
adequate to rule the patient out~|~pre~|~neg~|~1
although~|~termin~|~neg~|~1
any other~|~pre~|~neg~|~1
apart from~|~termin~|~neg~|~1
are ruled out~|~post~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a etiology for~|~termin~|~neg~|~1
as a etiology of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as a cause for~|~termin~|~neg~|~1
as a cause of~|~termin~|~neg~|~1
as an etiology for~|~termin~|~neg~|~1
as an etiology of~|~termin~|~neg~|~1
as an origin for~|~termin~|~neg~|~1
as an origin of~|~termin~|~neg~|~1
as a reason for~|~termin~|~neg~|~1
as a reason of~|~termin~|~neg~|~1
as a secondary cause for~|~termin~|~neg~|~1
as a secondary cause of~|~termin~|~neg~|~1
as a secondary etiology for~|~termin~|~neg~|~1
as a secondary etiology of~|~termin~|~neg~|~1
as a secondary origin for~|~termin~|~neg~|~1
as a secondary origin of~|~termin~|~neg~|~1
as a secondary reason for~|~termin~|~neg~|~1
as a secondary reason of~|~termin~|~neg~|~1
as a secondary source for~|~termin~|~neg~|~1
as a secondary source of~|~termin~|~neg~|~1
as a source for~|~termin~|~neg~|~1
as a source of~|~termin~|~neg~|~1
as has~|~termin~|~neg~|~1
as needed~|~pre~|~hypo~|~1
as the cause for~|~termin~|~neg~|~1
as the cause of~|~termin~|~neg~|~1
as the etiology for~|~termin~|~neg~|~1
as the etiology of~|~termin~|~neg~|~1
as the origin for~|~termin~|~neg~|~1
as the origin of~|~termin~|~neg~|~1
as the reason for~|~termin~|~neg~|~1
as the reason of~|~termin~|~neg~|~1
as the secondary cause for~|~termin~|~neg~|~1
as the secondary cause of~|~termin~|~neg~|~1
as the secondary etiology for~|~termin~|~neg~|~1
as the secondary etiology of~|~termin~|~neg~|~1
as the secondary origin for~|~termin~|~neg~|~1
as the secondary origin of~|~termin~|~neg~|~1
as the secondary reason for~|~termin~|~neg~|~1
as the secondary reason of~|~termin~|~neg~|~1
as the secondary source for~|~termin~|~neg~|~1
as the secondary source of~|~termin~|~neg~|~1
as the source for~|~termin~|~neg~|~1
as the source of~|~termin~|~neg~|~1
as well as any~|~pre~|~neg~|~1
aside from~|~termin~|~neg~|~1
aunt~|~pre~|~exp~|~1
aunt:~|~pre~|~exp~|~1
aunts~|~pre~|~exp~|~1
aunt's~|~pre~|~exp~|~1
be ruled out~|~post~|~poss~|~1
be ruled out for~|~pre~|~poss~|~1
because~|~termin~|~hypo~|~1
being ruled out~|~post~|~poss~|~1
brother~|~pre~|~exp~|~1
brother:~|~pre~|~exp~|~1
brother's~|~pre~|~exp~|~1
brothers~|~pre~|~exp~|~1
but~|~termin~|~neg~|~1
can be ruled out~|~post~|~neg~|~1
can be ruled out for~|~pre~|~neg~|~1
can rule her out~|~pre~|~neg~|~1
can rule her out against~|~pre~|~neg~|~1
can rule her out for~|~pre~|~neg~|~1
can rule him out~|~pre~|~neg~|~1
can rule him out against~|~pre~|~neg~|~1
can rule him out for~|~pre~|~neg~|~1
can rule out~|~pre~|~neg~|~1
can rule out against~|~pre~|~neg~|~1
can rule out for~|~pre~|~neg~|~1
can rule the patient out~|~pre~|~neg~|~1
can rule the patinet out against~|~pre~|~neg~|~1
can rule the patinet out for~|~pre~|~neg~|~1
cannot~|~pre~|~neg~|~1
cannot exclude~|~pre~|~poss~|~2
cause for~|~termin~|~neg~|~1
cause of~|~termin~|~neg~|~1
causes for~|~termin~|~neg~|~1
causes of~|~termin~|~neg~|~1
checked for~|~pre~|~neg~|~1
clear of~|~pre~|~neg~|~1
come back for~|~pre~|~hypo~|~1
come back to~|~pre~|~hypo~|~1
complains~|~termin~|~histexp~|~1
could be ruled out~|~post~|~poss~|~1
//could be~|~both~|~poss~|~1
could be ruled out for~|~pre~|~poss~|~1
currently~|~termin~|~histexp~|~1
dad~|~pre~|~exp~|~1
dad:~|~pre~|~exp~|~1
dad's~|~pre~|~exp~|~1
declined~|~pre~|~neg~|~1
declines~|~pre~|~neg~|~1
denied~|~pre~|~neg~|~1
denies~|~pre~|~neg~|~1
denying~|~pre~|~neg~|~1
did not rule out~|~post~|~poss~|~1
did rule her out~|~pre~|~neg~|~1
did rule her out against~|~pre~|~neg~|~1
did rule her out for~|~pre~|~neg~|~1
did rule him out~|~pre~|~neg~|~1
did rule him out against~|~pre~|~neg~|~1
did rule him out for~|~pre~|~neg~|~1
did rule out~|~pre~|~neg~|~1
did rule out against~|~pre~|~neg~|~1
did rule out for~|~pre~|~neg~|~1
did rule the patient out~|~pre~|~neg~|~1
did rule the patient out against~|~pre~|~neg~|~1
did rule the patient out for~|~pre~|~neg~|~1
doesn't look like~|~pre~|~neg~|~1
ed~|~termin~|~hist~|~1
emergency department~|~termin~|~hist~|~1
etiology for~|~termin~|~neg~|~1
etiology of~|~termin~|~neg~|~1
evaluate for~|~pre~|~neg~|~1
evaluation for~|~pre~|~neg~|~1
except~|~termin~|~neg~|~1
fails to reveal~|~pre~|~neg~|~1
family~|~pre~|~exp~|~1
fam hx~|~pre~|~exp~|~1
fam hx:~|~pre~|~exp~|~1
father~|~pre~|~exp~|~1
father:~|~pre~|~exp~|~1
father's~|~pre~|~exp~|~1
free~|~post~|~neg~|~1
free of~|~pre~|~neg~|~1
gram negative~|~pseudo~|~neg~|~1
grandfather~|~pre~|~exp~|~1
grandfather's~|~pre~|~exp~|~1
grandfather:~|~pre~|~exp~|~1
grandmother~|~pre~|~exp~|~1
grandmother's~|~pre~|~exp~|~1
grandmother:~|~pre~|~exp~|~1
has been negative~|~post~|~neg~|~1
has been ruled out~|~post~|~neg~|~1
have been ruled out~|~post~|~neg~|~1
her~|~termin~|~hypoexp~|~1
his~|~termin~|~hypoexp~|~1
hx of~|~pre~|~hist~|~1
h/o~|~pre~|~hist~|~1
statuspost~|~pre~|~hist~|~1
status/post~|~pre~|~hist~|~1
status-post~|~pre~|~hist~|~1
status post~|~pre~|~hist~|~1
year ago~|~pre~|~hist~|~1
year ago~|~post~|~hist~|~1
years ago~|~pre~|~hist~|~1
years ago~|~post~|~hist~|~1
have had~|~pre~|~hist~|~1
has had~|~pre~|~hist~|~1
had~|~pre~|~hist~|~1
underwent~|~pre~|~hist~|~1
husband~|~pre~|~exp~|~1
ho~|~pre~|~hist~|~1
history~|~pre~|~hist~|~1
history of~|~pre~|~hist~|~1
history and~|~pseudo~|~hist~|~1
history and examination~|~pseudo~|~hist~|~1
history and physical~|~pseudo~|~hist~|~1
history for~|~pseudo~|~hist~|~1
history of chief complaint~|~pseudo~|~hist~|~1
history of present illness~|~pseudo~|~hist~|~1
history taking~|~pseudo~|~hist~|~1
history, physical~|~pseudo~|~hist~|~1
however~|~termin~|~neg~|~1
if~|~pre~|~hypo~|~1
if negative~|~pseudo~|~hypo~|~1
inconsistent with~|~pre~|~neg~|~1
is not~|~pre~|~neg~|~1
is ruled out~|~post~|~neg~|~1
is to be ruled out~|~post~|~poss~|~1
is to be ruled out for~|~pre~|~poss~|~1
isn't~|~pre~|~neg~|~1
lack of~|~pre~|~neg~|~1
lacked~|~pre~|~neg~|~1
may be ruled out~|~post~|~poss~|~1
may be ruled out for~|~pre~|~poss~|~1
discussed~|~pre~|~poss~|~1
might be ruled out~|~post~|~poss~|~1
might be ruled out for~|~pre~|~poss~|~1
mom~|~pre~|~exp~|~1
mom:~|~pre~|~exp~|~1
mom's~|~pre~|~exp~|~1
mother~|~pre~|~exp~|~1
mother:~|~pre~|~exp~|~1
mother's~|~pre~|~exp~|~1
must be ruled out~|~post~|~poss~|~1
must be ruled out for~|~pre~|~poss~|~1
negative for~|~pre~|~neg~|~1
never developed~|~pre~|~neg~|~1
never had~|~pre~|~neg~|~1
nevertheless~|~termin~|~neg~|~1
no~|~pre~|~neg~|~1
no abnormal~|~pre~|~neg~|~1
no cause of~|~pre~|~neg~|~1
no change~|~pseudo~|~neg~|~1
no complaints of~|~pre~|~neg~|~1
no definite change~|~pseudo~|~neg~|~1
no evidence~|~pre~|~neg~|~1
no evidence to suggest~|~pre~|~neg~|~1
no findings of~|~pre~|~neg~|~1
no findings to indicate~|~pre~|~neg~|~1
no history of~|~pre~|~neg~|~1
no increase~|~pseudo~|~neg~|~1
no interval change~|~pseudo~|~neg~|~1
no longer present~|~post~|~neg~|~1
no mammographic evidence of~|~pre~|~neg~|~1
no new~|~pre~|~neg~|~1
no new evidence~|~pre~|~neg~|~1
no other evidence~|~pre~|~neg~|~1
no radiographic evidence of~|~pre~|~neg~|~1
no sign of~|~pre~|~neg~|~1
no significant~|~pre~|~neg~|~1
no significant change~|~pseudo~|~neg~|~1
no significant interval change~|~pseudo~|~neg~|~1
no signs of~|~pre~|~neg~|~1
no suggestion of~|~pre~|~neg~|~1
no suspicious~|~pre~|~neg~|~1
no suspicious change~|~pseudo~|~neg~|~1
non diagnostic~|~post~|~neg~|~1
not~|~pre~|~neg~|~1
not appear~|~pre~|~neg~|~1
not appreciate~|~pre~|~neg~|~1
not associated with~|~pre~|~neg~|~1
not been ruled out~|~post~|~poss~|~1
not cause~|~pseudo~|~neg~|~1
not certain if~|~pseudo~|~neg~|~1
not certain whether~|~pseudo~|~neg~|~1
not complain of~|~pre~|~neg~|~1
not demonstrate~|~pre~|~neg~|~1
not drain~|~pseudo~|~neg~|~1
not exhibit~|~pre~|~neg~|~1
not extend~|~pseudo~|~neg~|~1
not feel~|~pre~|~neg~|~1
not had~|~pre~|~neg~|~1
not have~|~pre~|~neg~|~1
not have evidence of~|~pre~|~neg~|~1
not know of~|~pre~|~neg~|~1
not known to have~|~pre~|~neg~|~1
not necessarily~|~pseudo~|~neg~|~1
not on~|~pseudo~|~neg~|~1
not only~|~pseudo~|~neg~|~1
not recommended~|~post~|~neg~|~1
not recommend~|~pre~|~neg~|~1
not recommending~|~pre~|~neg~|~1
not reveal~|~pre~|~neg~|~1
not ruled out~|~post~|~poss~|~1
not see~|~pre~|~neg~|~1
not to be~|~pre~|~neg~|~1
nothing to suggest~|~pre~|~neg~|~2
noted~|~termin~|~histexp~|~1
now resolved~|~post~|~neg~|~1
origin for~|~termin~|~neg~|~1
origin of~|~termin~|~neg~|~1
origins for~|~termin~|~neg~|~1
origins of~|~termin~|~neg~|~1
other possibilities of~|~termin~|~neg~|~1
ought to be ruled out~|~post~|~poss~|~1
ought to be ruled out for~|~pre~|~poss~|~1
past history~|~pre~|~hist~|~1
past~|~pre~|~hist~|~1
following up~|~pre~|~hist~|~1
following~|~pre~|~hist~|~1
received~|~pre~|~hist~|~1
past medical history~|~pre~|~hist~|~1
patient~|~termin~|~hypoexp~|~1
patient was not~|~pre~|~neg~|~1
patient's~|~termin~|~hypoexp~|~1
poor history~|~pseudo~|~hist~|~1
presenting~|~termin~|~histexp~|~1
presents~|~termin~|~histexp~|~1
prophylaxis~|~post~|~neg~|~1
r/o~|~pre~|~neg~|~1
rather than~|~pre~|~neg~|~1
reason for~|~termin~|~neg~|~1
reason of~|~termin~|~neg~|~1
reasons for~|~termin~|~neg~|~1
reasons of~|~termin~|~neg~|~1
reported~|~termin~|~histexp~|~1
reports~|~termin~|~histexp~|~1
resolved~|~pre~|~neg~|~1
resolved after~|~post~|~neg~|~1
return~|~pre~|~hypo~|~1
ro~|~pre~|~neg~|~1
rule her out~|~pre~|~neg~|~1
rule her out for~|~pre~|~neg~|~1
rule him out~|~pre~|~neg~|~1
rule him out for~|~pre~|~neg~|~1
rule out~|~pre~|~neg~|~1
rule out for~|~pre~|~neg~|~1
rule the patient out~|~pre~|~neg~|~1
rule the patinet out for~|~pre~|~neg~|~1
ruled her out~|~pre~|~neg~|~1
ruled her out against~|~pre~|~neg~|~1
ruled her out for~|~pre~|~neg~|~1
ruled him out~|~pre~|~neg~|~1
ruled him out against~|~pre~|~neg~|~1
ruled him out for~|~pre~|~neg~|~1
ruled out~|~pre~|~neg~|~1
ruled out against~|~pre~|~neg~|~1
ruled out for~|~pre~|~neg~|~1
ruled the patient out~|~pre~|~neg~|~1
ruled the patient out against~|~pre~|~neg~|~1
ruled the patient out for~|~pre~|~neg~|~1
rules her out~|~pre~|~neg~|~1
rules her out for~|~pre~|~neg~|~1
rules him out~|~pre~|~neg~|~1
rules him out for~|~pre~|~neg~|~1
rules out~|~pre~|~neg~|~1
rules out for~|~pre~|~neg~|~1
rules the patient out~|~pre~|~neg~|~1
rules the patient out for~|~pre~|~neg~|~1
secondary~|~termin~|~neg~|~1
secondary to~|~termin~|~neg~|~1
should be ruled out~|~post~|~neg~|~1
should be ruled out for~|~pre~|~neg~|~1
should he~|~pre~|~hypo~|~1
should she~|~pre~|~hypo~|~1
should the patient~|~pre~|~hypo~|~1
should there~|~pre~|~hypo~|~1
since~|~termin~|~hypo~|~1
sister~|~pre~|~exp~|~1
sister's~|~pre~|~exp~|~1
social history~|~pseudo~|~hist~|~1
son~|~pre~|~exp~|~1
source for~|~termin~|~neg~|~1
source of~|~termin~|~neg~|~1
sources for~|~termin~|~neg~|~1
sources of~|~termin~|~neg~|~1
states~|~termin~|~histexp~|~1
still~|~termin~|~neg~|~1
sudden onset of~|~pseudo~|~hist~|~1
sufficient to rule her out~|~pre~|~neg~|~1
sufficient to rule her out against~|~pre~|~neg~|~1
sufficient to rule her out for~|~pre~|~neg~|~1
sufficient to rule him out~|~pre~|~neg~|~1
sufficient to rule him out against~|~pre~|~neg~|~1
sufficient to rule him out for~|~pre~|~neg~|~1
sufficient to rule out~|~pre~|~neg~|~1
sufficient to rule out against~|~pre~|~neg~|~1
sufficient to rule out for~|~pre~|~neg~|~1
sufficient to rule the patient out~|~pre~|~neg~|~1
sufficient to rule the patient out against~|~pre~|~neg~|~1
sufficient to rule the patient out for~|~pre~|~neg~|~1
test for~|~pre~|~neg~|~1
though~|~termin~|~neg~|~1
to exclude~|~pre~|~neg~|~1
today~|~termin~|~histexp~|~1
trigger event for~|~termin~|~neg~|~1
uncle~|~pre~|~exp~|~1
uncle:~|~pre~|~exp~|~1
uncle's~|~pre~|~exp~|~1
unlikely~|~post~|~neg~|~1
unremarkable for~|~pre~|~neg~|~1
was found~|~termin~|~histexp~|~1
was negative~|~post~|~neg~|~1
was not~|~pre~|~neg~|~1
was ruled out~|~post~|~neg~|~1
wasn't~|~pre~|~neg~|~1
what must be ruled out is~|~pre~|~poss~|~1
which~|~termin~|~exp~|~1
wife~|~pre~|~exp~|~1
who~|~termin~|~hypoexp~|~1
will be ruled out~|~post~|~poss~|~1
will be ruled out for~|~pre~|~poss~|~1
with no~|~pre~|~neg~|~1
without~|~pre~|~neg~|~1
without any evidence of~|~pre~|~neg~|~1
without difficulty~|~pseudo~|~neg~|~1
without evidence~|~pre~|~neg~|~1
without indication of~|~pre~|~neg~|~1
without sign of~|~pre~|~neg~|~1
yet~|~termin~|~neg~|~1
    `
};

// The spaCy toolkit
var spacy_toolkit = {

    download_anns_as_jsonl: function(anns, dtd, fn) {
        // create patterns
        var patterns = this.anns2patterns(anns);

        // get the text
        var str = this.patterns2str(patterns);

        // download
        var blob = new Blob([str], {type: "text/txt;charset=utf-8"});
        saveAs(blob, fn);

        return str;
    },

    anns2patterns: function(anns) {
        // use a dictionary for sorting
        var patterns = {};
        
        // check each ann
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];

            // check each tag in this ann
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];
                var tag_name = tag.tag;

                if (patterns.hasOwnProperty(tag_name)) {
                    
                } else {
                    patterns[tag_name] = {
                        text_dict: {},
                        pattern_list: []
                    }
                }
                
                // create a pharse pattern

                // but first check the text itself
                if (!tag.hasOwnProperty('text')) {
                    // what?
                    continue;
                }
                var text = tag.text;

                if (text == null) { 
                    // what?
                    continue;
                }

                // remove blank
                text = text.trim();

                if (text == '') {
                    // what??
                    continue;
                }
                
                // change to lower
                text = text.toLocaleLowerCase();

                if (patterns[tag_name].text_dict.hasOwnProperty(text)) {
                    // skip existed text
                    patterns[tag_name].text_dict[text] += 1;
                    continue;
                }

                // create a new pattern
                var p = {
                    label: tag_name.toLocaleUpperCase(),
                    pattern: text,
                    id: tag_name
                };

                // add this as a new pattern
                patterns[tag_name].pattern_list.push(p);
                patterns[tag_name].text_dict[text] = 1;
            }
        }

        // convert the patterns to a list
        var all_patterns = [];
        for (const tag_name in patterns) {
            if (Object.hasOwnProperty.call(patterns, tag_name)) {
                for (let i = 0; i < patterns[tag_name].pattern_list.length; i++) {
                    const p = patterns[tag_name].pattern_list[i];
                    all_patterns.push(p);
                }
            }
        }

        return all_patterns;
    },

    patterns2str: function(patterns) {
        var strs = [];
        for (let i = 0; i < patterns.length; i++) {
            const p = patterns[i];
            var p_str = JSON.stringify(p);
            strs.push(p_str);
        }

        return strs.join('\n');
    }
};

// The IAA Calculator
var iaa_calculator = {
    colors: {
        decision_agreed: '94d2bd',
        decision_disagreed: 'f4978e',
        annotator_a_tag: 'd9e9f1',
        annotator_b_tag: 'd8f7d6',
    },

    default_overlap_ratio: 0.1,

    make_ann_by_iaa: function(ann_rst, ann_iaa, dtd) {
        // create a blank ann by the ann_rst's ann
        var ann = JSON.parse(JSON.stringify(ann_rst.ann));

        // clear the ann tags
        ann.tags = [];

        // clear the meta
        ann.meta = {};

        // check each cate
        var cms = ['tp', 'fp', 'fn'];

        // check the ann in 
        for (const tag_name in ann_iaa.rst.tag) {
            if (Object.hasOwnProperty.call(ann_iaa.rst.tag, tag_name)) {
                const tag_rst = ann_iaa.rst.tag[tag_name].cm.tags;

                for (let i = 0; i < cms.length; i++) {
                    const cm = cms[i];
                    
                    for (let j = 0; j < tag_rst[cm].length; j++) {
                        if (tag_rst[cm][j] == null) {
                            // for ann_iaa, this is not possible
                            continue;
                        }
                        
                        // there may be two tags
                        for (let k = 0; k < 2; k++) {
                            const _tag = tag_rst[cm][j][k];

                            if (cm == 'tp' && k == 1) {
                                // for true positive, just skip the second one
                                continue;
                            }

                            if (_tag == null) {
                                // yes, it's possible for fn
                                continue;
                            }
                            
                            // ok, now we need to save this tag
                            var tag = Object.assign({}, _tag);
                            var tag_def = dtd.tag_dict[tag.tag];

                            // get a new id for this tag
                            var new_id = ann_parser.get_next_tag_id(ann, tag_def);
    
                            // now, set this tag and put it into list
                            tag.id = new_id;
    
                            // add annotator
                            // locate where this tag comes from
                            if (cm == 'tp') {
                                tag._annotator = 'AB';
                                
                            } else if (cm == 'fn') {
                                tag._annotator = 'B';
    
                            } else {
                                tag._annotator = {
                                    0: 'A',
                                    1: 'B'
                                }[k];
                            }
    
                            ann.tags.push(tag);
                        }
                    }
                }
            }
        }

        return ann;
    },
    
    make_ann_by_rst: function(ann_rst, dtd) {
        var ann = JSON.parse(JSON.stringify(ann_rst.ann));

        // clear the ann tags
        ann.tags = [];

        // clear the meta
        ann.meta = {};

        // check each cate
        var cms = ['tp', 'fp', 'fn'];

        for (const tag_name in ann_rst.rst) {
            if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                const tag_rst = ann_rst.rst[tag_name];

                for (let i = 0; i < cms.length; i++) {
                    const cm = cms[i];
                    
                    for (let j = 0; j < tag_rst[cm].length; j++) {
                        // 2022-04-19: fix download bug due to null tag_rst[cm][j]
                        if (tag_rst[cm][j] == null) {
                            // this situation is possible due to double rejection
                            // so no tag def can be found
                            continue;
                        }
                        var tag = Object.assign({}, tag_rst[cm][j].tag);
                        var tag_def = dtd.tag_dict[tag.tag];

                        // get a new id for this tag
                        var new_id = ann_parser.get_next_tag_id(ann, tag_def);

                        // now, set this tag and put it into list
                        tag.id = new_id;

                        // 2022-05-11: add annotator
                        // locate where this tag comes from
                        if (cm == 'tp') {
                            tag._annotator = 'AB';
                            
                        } else if (cm == 'fp') {
                            tag._annotator = 'A';

                        } else {
                            tag._annotator = 'B';
                        }

                        ann.tags.push(tag);
                    }
                }
            }
        }

        return ann;
    },

    get_default_gs_dict: function(dtd, iaa_dict) {
        // the core of gs is similar to the iaa_dict.ann
        // which is a hashcode based dictionary.
        // and the inner data is similar.
        /*
        {
            hashcode: {
                ann: ann_obj // but the tags are empty,
                rst: {
                    tag_name: {
                        tp: [{tag: tag, from: 'a'}, ...],
                        fp: [],
                        fn: []
                    }
                }
            }
        }

        the length of tp, fp, fn is exactly equal to the iaa_dict
        */
        var gs_dict = {};

        var cnt = 0;
        for (const hashcode in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                // deep copy a new object
                const ann_rst = JSON.parse(JSON.stringify(iaa_dict.ann[hashcode]));
                cnt += 1;

                // rename the 
                gs_dict[hashcode] = {
                    // copy the ann_a as defult
                    ann: ann_rst.anns[0],
                    rst: {}
                }

                // rename the gs
                var fn_gs = "G_" + this.find_lcs(
                    ann_rst.anns[0]._filename,
                    ann_rst.anns[1]._filename
                ) + '_' + cnt + '.xml';
                
                gs_dict[hashcode].ann._filename = fn_gs;

                // remove the _fh
                delete gs_dict[hashcode].ann._fh;

                // empty the existing tags
                gs_dict[hashcode].ann.tags = [];

                // add one more 
                gs_dict[hashcode].ann._has_star = false;

                for (const tag_name in ann_rst.rst.tag) {
                    if (Object.hasOwnProperty.call(ann_rst.rst.tag, tag_name)) {
                        const tag_rst = ann_rst.rst.tag[tag_name];
                        gs_dict[hashcode].rst[tag_name] = {
                            tp: [],
                            fp: [],
                            fn: []
                        }

                        // fill each in tp
                        for (let i = 0; i < tag_rst.cm.tags.tp.length; i++) {
                            const tags = tag_rst.cm.tags.tp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].tp.push({
                                tag: tags[0],
                                from: 'A'
                            });
                        }

                        // fill each in fp
                        for (let i = 0; i < tag_rst.cm.tags.fp.length; i++) {
                            const tags = tag_rst.cm.tags.fp[i];
                            // use ann_a's result
                            gs_dict[hashcode].rst[tag_name].fp.push({
                                tag: tags[0],
                                from: 'A'
                            });
                        }
                        
                        // fill each in fn
                        for (let i = 0; i < tag_rst.cm.tags.fn.length; i++) {
                            const tags = tag_rst.cm.tags.fn[i];
                            // use ann_b's result
                            gs_dict[hashcode].rst[tag_name].fn.push({
                                tag: tags[1],
                                from: 'B'
                            });
                        }
                    }
                }
            }
        }

        return gs_dict;
    },

    get_iaa_report_cohen_kappa_json: function(iaa_dict, dtd) {
        // there are the following columns in the cohen's kappa
        // N + 3
        // where the N is the total number of tags
        // the 3 columns are A, EMPTY for B, and P_b
        var js = [];

        // the first row, just names
        // var j = {
        //     'tag_name': ''
        // };
        // for (let i = 0; i < dtd.etags.length; i++) {
        //     const tag_def_col = dtd.etags[i];
        //     j[tag_def_col.name] = tag_def_col.name;
        // }
        // j['EMPTY_b'] = 'EMPTY_b';
        // j['P_b'] = 'P_b';
        // js.push(j);

        // all tags
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_row = dtd.etags[i];
            
            var j = {
                'annotator': 'A',
                'tag_name': tag_def_row.name
            };
            for (let k = 0; k < dtd.etags.length; k++) {
                const tag_def_col = dtd.etags[k];
                if (tag_def_row.name == tag_def_col.name) {
                    j[tag_def_col.name] = iaa_dict.tag[tag_def_col.name].cm.tp;
                } else {
                    j[tag_def_col.name] = '';
                }
            }
            j['EMPTY_b'] = iaa_dict.tag[tag_def_row.name].cm.fp;
            j['P_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.b[tag_def_row.name]);
            js.push(j);
        }

        // EMPTY for a
        j = {
            'annotator': '',
            'tag_name': 'EMPTY_a'
        }
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_col = dtd.etags[i];
            j[tag_def_col.name] = iaa_dict.tag[tag_def_col.name].cm.fn;
        }
        j['EMPTY_b'] = 0;
        j['P_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.b['_EMPTY_']);
        js.push(j);

        // P for a
        j = {
            'annotator': '',
            'tag_name': 'P_a'
        }
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def_col = dtd.etags[i];
            j[tag_def_col.name] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.a[tag_def_col.name]);
        }
        j['EMPTY_b'] = this.to_fixed(iaa_dict.all.cohen_kappa.Pes.a['_EMPTY_']);
        j['P_b'] = '';
        js.push(j);

        return js;
    },

    extend_iaa_report_cohen_kappa_json: function(iaa_dict, dtd, js) {
        // blank lines
        js.push({});
        js.push({});
        js.push({});

        // overall 
        js.push({
            'annotator': "Overall Cohen's Kappa",
            "tag_name": this.to_fixed(iaa_dict.all.cohen_kappa.kappa)
        });

        // percentage agreement
        js.push({
            'annotator': 'Percentage Agreement',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Po)
        });

        // TP
        js.push({
            'annotator': "TP", 
            'tag_name': iaa_dict.all.cm.tp
        });

        // FP
        js.push({
            'annotator': 'FP',
            'tag_name': iaa_dict.all.cm.fp
        });

        // FN
        js.push({
            'annotator': 'FN',
            'tag_name': iaa_dict.all.cm.fn
        });

        // N
        js.push({
            'annotator': 'N',
            'tag_name': iaa_dict.all.cohen_kappa.N 
        });

        // Po
        js.push({
            'annotator': 'Po',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Po)
        });

        // Pe
        js.push({
            'annotator': 'Pe',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.Pe)
        });

        // SE_k
        js.push({
            'annotator': 'SE_k',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.SE_k)
        });

        // 95% CI lower
        js.push({
            'annotator': '95% CI Lower',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.lower)
        });

        // 95% CI upper
        js.push({
            'annotator': '95% CI Upper',
            'tag_name': this.to_fixed(iaa_dict.all.cohen_kappa.upper)
        });
        return js;
    },

    get_iaa_report_cohen_kappa_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_cohen_kappa_json(
            iaa_dict, 
            dtd
        );

        js = this.extend_iaa_report_cohen_kappa_json(
            iaa_dict,
            dtd,
            js
        );

        var ws_cohen = XLSX.utils.json_to_sheet(js);

        return ws_cohen;
    },

    get_iaa_report_summary_json: function(iaa_dict, dtd) {
        // there are the following columns in the summary
        // Tag Name, F1, precision, recall, TP, FP, FN
        var js = [];

        // add the overall
        js.push({
            'tag_name': 'Overall',
            'F1': this.to_fixed(iaa_dict.all.f1),
            'precision': this.to_fixed(iaa_dict.all.precision),
            'recall': this.to_fixed(iaa_dict.all.recall),
            'TP': iaa_dict.all.cm.tp,
            'FP': iaa_dict.all.cm.fp,
            'FN': iaa_dict.all.cm.fn,
        });

        // now, check each etag
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag_name = dtd.etags[i].name;
            
            // add this tag to the summary
            js.push({
                'tag_name': etag_name,
                'F1': this.to_fixed(iaa_dict.tag[etag_name].f1),
                'precision': this.to_fixed(iaa_dict.tag[etag_name].precision),
                'recall': this.to_fixed(iaa_dict.tag[etag_name].recall),
                'TP': iaa_dict.tag[etag_name].cm.tp,
                'FP': iaa_dict.tag[etag_name].cm.fp,
                'FN': iaa_dict.tag[etag_name].cm.fn,
            });
        }

        return js;
    },

    get_iaa_report_summary_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_summary_json(
            iaa_dict,
            dtd
        );
        var ws_summary = XLSX.utils.json_to_sheet(js);
        // change the style for the header line
        var cols = 'ABCDEFG'.split('');
        for (let i = 0; i < cols.length; i++) {
            var col = cols[i];
            var row = '1';
            ws_summary[col + row].s = {
                font: {
                    sz: 14,
                    bold: true
                },
            }
        }

        // change the style for the overall F1
        var col_tag = 'A';
        var col_f1 = 'B';
        var overall_f1_value = js[0].F1;
        var overall_f1_color4ws = d3.rgb(
            d3.interpolateBlues(overall_f1_value * 0.9)
        ).formatHex();
        ws_summary[col_f1 + '2'].s = {
            fill: {
                fgColor: {
                    rgb: overall_f1_color4ws.substring(1)
                }
            },
        }

        // change the style for the tag column
        for (let i = 0; i < dtd.etags.length; i++) {
            const etag = dtd.etags[i];
            var row = '' + (i+3);
            // change the tag bg
            ws_summary[col_tag + row].s = {
                fill: {
                    fgColor: {
                        rgb: etag.style.color.substring(1).toLocaleUpperCase()
                    }
                },
            }
            // change the f1 bg
            var f1_value = parseFloat(ws_summary[col_f1 + row].v)
            var color4ws = d3.rgb(
                d3.interpolateBlues(f1_value * 0.9)
            ).formatHex();
            ws_summary[col_f1 + row].s = {
                fill: {
                    fgColor: {
                        rgb: color4ws.substring(1)
                    }
                },
            }
        }

        return ws_summary;
    },

    get_iaa_report_files_json: function(iaa_dict, dtd) {
        // there are following columns in the files json
        // file name
        var js = [];

        for (const fnhash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, fnhash)) {
                const ann_rst = iaa_dict.ann[fnhash];
                
                // create a j obj for this file
                var j = {
                    'file_name_A': ann_rst.anns[0]._filename,
                    'file_name_B': ann_rst.anns[1]._filename,
                    'F1': this.to_fixed(ann_rst.rst.all.f1),
                    'precision': this.to_fixed(ann_rst.rst.all.precision),
                    'recall': this.to_fixed(ann_rst.rst.all.recall),
                    'TP': ann_rst.rst.all.cm.tp,
                    'FP': ann_rst.rst.all.cm.fp,
                    'FN': ann_rst.rst.all.cm.fn,
                };

                // add the f1 of each tag
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    j[etag.name + '_F1'] = this.to_fixed(
                        ann_rst.rst.tag[etag.name].f1
                    )
                }

                // add the result
                js.push(j);
            }
        }

        return js;
    },

    get_iaa_report_files_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_files_json(
            iaa_dict,
            dtd
        );

        var ws_files = XLSX.utils.json_to_sheet(js);

        // update the style
        var col_f1 = 'C';
        for (let i = 0; i < js.length; i++) {
            // get the row number
            var row = i + 2;

            // the F1 column is
            const j = js[i];
            
            // get the f1 value
            var f1_value = parseFloat(j.F1);

            // convert the f1 value to RGB color
            var color4ws = d3.rgb(
                d3.interpolateBlues(f1_value)
            ).formatHex();

            // set the style for this cell
            ws_files[col_f1 + row].s = {
                fill: {
                    fgColor: {
                        rgb: color4ws.substring(1)
                    }
                },
            }
        }

        return ws_files;
    },

    /**
     * Get the IAA report, the details of tags.
     *
     * 
     * @param {Object} iaa_dict the dictionary contains IAA result
     * @param {Object} dtd the DTD schema
     * @param {Object} flags flags for controling results
     * @returns JSON format report
     */
    get_iaa_report_tags_json: function(iaa_dict, dtd, flags) {
        if (typeof(flags)=='undefined') {
            flags = {
                skip_agreed_tags: false
            }
        }
        // there are following columns in the files json
        // file name
        var js = [];
        var cms = ['tp', 'fp', 'fn'];
        if (flags.skip_agreed_tags) {
            cms = ['fp', 'fn'];
        }

        for (const fnhash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, fnhash)) {
                const ann_rst = iaa_dict.ann[fnhash];

                // now need to check each tag in this ann_rst
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    
                    // now need to check each cm
                    for (let j = 0; j < cms.length; j++) {
                        const cm = cms[j];
                        // get the index for the cm tags
                        // for tp and fp, use 0
                        // for fn, use 1
                        var idx = {'tp': 0, 'fp': 0, 'fn': 1}[cm];
                        
                        // the IAA 
                        var iaa = {
                            'tp': 'Agreed',
                            'fp': 'Disagreed',
                            'fn': 'Disagreed'
                        }[cm];
                        
                        // now need to check each item in this
                        var cm_tags = ann_rst.rst.tag[etag.name].cm.tags[cm];
                        for (let k = 0; k < cm_tags.length; k++) {
                            // ok, put each tag to the js
                            const cm_tag = cm_tags[k];
                            
                            for (let anter_idx = 0; anter_idx < 2; anter_idx++) {
                                if (cm_tag[anter_idx] == null) {
                                    // no such tag, skip
                                    continue
                                }
                                // where the tags comes from depends on
                                // the index, which is coded in the parsing iaa
                                var src = {0: 'A', 1: 'B'}[anter_idx];

                                // add this tag to final list
                                // create a base json to hold everything
                                var json = {
                                    'file_name': ann_rst.anns[idx]._filename,
                                    'source': src,
                                    'concept': etag.name,
                                    'id': cm_tag[anter_idx].id,
                                    'spans': cm_tag[anter_idx].spans,
                                    'text': cm_tag[anter_idx].text,
                                    'IAA': iaa
                                };

                                // next need to put all attributes to this
                                // this depends on the schema
                                for (let att_idx = 0; att_idx < etag.attlists.length; att_idx++) {
                                    const etag_att = etag.attlists[att_idx];
                                    
                                    // the attribute name should be the same
                                    // since it is used as the column name.
                                    // So we need to create two new columns:
                                    // 1. att_x_key, for the attr key
                                    // 2. att_x_txt, for the attr value
                                    var col_att_key = 'attr_name_' + att_idx;
                                    var col_att_key_value = etag_att.name;

                                    var col_att_txt = 'attr_value_' + att_idx;
                                    var col_att_txt_value = cm_tag[anter_idx][etag_att.name];

                                    // then put this two columns to the json
                                    json[col_att_key] = col_att_key_value;
                                    json[col_att_txt] = col_att_txt_value;
                                }

                                // put to js
                                js.push(json);
                                
                            }
                        }
                    }
                }
            }
        }

        return js;
    },

    get_iaa_report_tags_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_tags_json(
            iaa_dict,
            dtd
        );
        var ws_tags = XLSX.utils.json_to_sheet(js);

        // change the style for the IAA column
        var col_concept = 'C';
        var col_iaa = 'G';
        for (let i = 0; i < js.length; i++) {
            // get the data item
            var json = js[i];

            // get the row number
            // the first row is the header, 
            // so the number starts with 2
            var row = i + 2;

            // set the style for the concept name
            ws_tags[col_concept + row].s = {
                fill: {
                    fgColor: {
                        rgb: dtd.tag_dict[json.concept].style.color.substring(1)
                    }
                },
            }

            // get IAA value in that cell and convert to color
            var iaa_value = ws_tags[col_iaa + row].v;
            var iaa_color = iaa_value == 'Agreed'? 
                this.colors.decision_agreed: 
                this.colors.decision_disagreed;

            // set the style for the 
            ws_tags[col_iaa + row].s = {
                fill: {
                    fgColor: {
                        rgb: iaa_color
                    }
                },
            }
            
        }

        return ws_tags;
    },

    /**
     * Get the IAA report in a format for adjudication.
     *
     * 
     * @param {Object} iaa_dict the dictionary contains IAA result
     * @param {Object} dtd the DTD schema
     * @param {Object} flags flags for controling results
     * @returns JSON format report
     */
    get_iaa_report_adjudication_json: function(iaa_dict, dtd, flags) {
        if (typeof(flags)=='undefined') {
            flags = {
                skip_agreed_tags: false
            }
        }
        // there are following columns in the files json
        // file name
        var js = [];
        var cms = ['tp', 'fp', 'fn'];
        if (flags.skip_agreed_tags) {
            cms = ['fp', 'fn'];
        }

        for (const fnhash in iaa_dict.ann) {
            if (Object.hasOwnProperty.call(iaa_dict.ann, fnhash)) {
                const ann_rst = iaa_dict.ann[fnhash];

                // now need to check each tag in this ann_rst
                for (let i = 0; i < dtd.etags.length; i++) {
                    const etag = dtd.etags[i];
                    // processed tags in list b
                    var p_tags_b = [];
                    
                    // now need to check each cm
                    for (let j = 0; j < cms.length; j++) {
                        const cm = cms[j];
                        // the IAA 
                        var iaa = {
                            'tp': 'Agreed',
                            'fp': 'Disagreed',
                            'fn': 'Disagreed'
                        }[cm];
                        
                        // now need to check each item in this
                        var cm_tags = ann_rst.rst.tag[etag.name].cm.tags[cm];
                        for (let k = 0; k < cm_tags.length; k++) {
                            // no matter what the 
                            // ok, put each tag to the js
                            const cm_tag = cm_tags[k];

                            // need to check if tag_b
                            if (cm_tag[1] == null) {
                                // ok, this only involves annotator a
                            } else {
                                // now check if this tag added?
                                if (p_tags_b.contains(cm_tag[1].id)) {
                                    // oh, this tag b has been added
                                    continue
                                } else {
                                    // oh, this is a new tag b
                                    p_tags_b.push(cm_tag[1].id)
                                }
                            }
                            
                            // create a base json to hold everything
                            var json = {
                                // just use the first file as file name
                                'file_name': ann_rst.anns[0]._filename,
                                'concept': etag.name,
                                'IAA': iaa
                            };
                            
                            // decision
                            
                            // then put the annotation from A and B
                            // anter_idx 0 is A
                            // anter_idx 1 is B
                            for (let anter_idx = 0; anter_idx < 2; anter_idx++) {
                                var anter_label = {0:'A', 1:'B'}[anter_idx];
                                if (cm_tag[anter_idx] == null) {
                                    // which means this location is empty
                                    // just put empty content
                                    // due to the xlsx convert design, 
                                    // must put empty text here
                                    json[anter_label+'.id'] = '';
                                    json[anter_label+'.spans'] = '';
                                    json[anter_label+'.text'] = '';
                                } else {
                                    // ok, this is a tag, put it here
                                    json[anter_label+'.id'] = cm_tag[anter_idx].id;
                                    json[anter_label+'.spans'] = cm_tag[anter_idx].spans;
                                    json[anter_label+'.text'] = cm_tag[anter_idx].text;
                                }                                
                            }
                            
                            // next need to put all attributes to this
                            // this depends on the schema
                            // for (let att_idx = 0; att_idx < etag.attlists.length; att_idx++) {
                            //     const etag_att = etag.attlists[att_idx];
                                
                            //     // the attribute name should be the same
                            //     // since it is used as the column name.
                            //     // So we need to create two new columns:
                            //     // 1. att_x_key, for the attr key
                            //     // 2. att_x_txt, for the attr value
                            //     var col_att_key = 'attr_name_' + att_idx;
                            //     var col_att_key_value = etag_att.name;

                            //     var col_att_txt = 'attr_value_' + att_idx;
                            //     var col_att_txt_value = cm_tag[idx][etag_att.name];

                            //     // then put this two columns to the json
                            //     json[col_att_key] = col_att_key_value;
                            //     json[col_att_txt] = col_att_txt_value;
                            // }

                            // put to js
                            js.push(json);
                        }
                    }
                }
            }
        }

        return js;
    },

    get_iaa_report_adjudication_excelws: function(iaa_dict, dtd) {
        var js = this.get_iaa_report_adjudication_json(
            iaa_dict,
            dtd
        );
        var ws_tags = XLSX.utils.json_to_sheet(js);

        // change the style for the adjudication column
        var col_concept = 'B';
        var col_iaa = 'C';
        var cols_a = ['D', 'E', 'F'];
        var cols_b = ['G', 'H', 'I'];
        for (let i = 0; i < js.length; i++) {
            // get the data item
            var json = js[i];

            // get the row number
            // the first row is the header, 
            // so the number starts with 2
            var row = i + 2;

            // set the style for the concept name
            ws_tags[col_concept + row].s = {
                fill: {
                    fgColor: {
                        rgb: dtd.tag_dict[json.concept].style.color.substring(1)
                    }
                },
            }

            // get IAA value in that cell and convert to color
            var iaa_value = ws_tags[col_iaa + row].v;
            var iaa_color = iaa_value == 'Agreed'? 
                this.colors.decision_agreed: 
                this.colors.decision_disagreed;

            // set the style for the 
            ws_tags[col_iaa + row].s = {
                fill: {
                    fgColor: {
                        rgb: iaa_color
                    }
                },
            }

            // set bg color for annotator A
            for (let j = 0; j < cols_a.length; j++) {
                const col = cols_a[j];
                ws_tags[col + row].s = {
                    fill: {
                        fgColor: {
                            rgb: this.colors.annotator_a_tag
                        }
                    },
                }
            }

            // set bg color for annotator B
            for (let j = 0; j < cols_b.length; j++) {
                const col = cols_b[j];
                ws_tags[col + row].s = {
                    fill: {
                        fgColor: {
                            rgb: this.colors.annotator_b_tag
                        }
                    },
                }
            }
        }

        return ws_tags;
    },

    /**
     * Evaluate the IAA based on given schema and 
     * two list of annotations from two annotators
     * 
     * @param {Object} dtd the annotation schema
     * @param {Object} anns_a the annotations by A
     * @param {Object} anns_b the annotations by B
     * @param {string} match_mode overlap or exact match
     * @param {float} overlap_ratio overlap ratio
     * @returns Object of IAA result
     */
    evaluate_anns_on_dtd: function(
        dtd, 
        anns_a, 
        anns_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode) == 'undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }
        /* we will build a dictionary for this task
        {
            ann: {
                text_hash: {
                    anns: [ann_a, ann_b],
                    rst: {
                        tag_name: result
                    }
                },
                ...
            },
            all: {pre, rec, f1, cm},
            tag: {
                tag_a: {pre, rec, f1, cm},
            }
        },
        */
        var iaa_dict = {
            ann: {}, // for the file
            all: {},
            tag: {},
            stat: {
                duplicates: [],
                unmatched: [],
                matched_hashcodes: []
            },
        };

        // this is just for checking dupliated ann
        var ann_dict = {};
        
        // first, let's check all anns_a
        for (let i = 0; i < anns_a.length; i++) {
            const ann_a = anns_a[i];
            var hashcode = this.hash(ann_a.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                // what??? duplicated text in anns_a?
                console.log('* found duplicated ann a', ann_a);
                iaa_dict.stat.duplicates.push({
                    ann: ann_a,
                    from: 'a'
                });
                continue;
            }

            // ok, let's create a new item here
            ann_dict[hashcode] = [{
                ann: ann_a,
                from: 'a'
            }];
        }

        // second, let's check all anns_b
        for (let i = 0; i < anns_b.length; i++) {
            const ann_b = anns_b[i];
            var hashcode = this.hash(ann_b.text);

            if (ann_dict.hasOwnProperty(hashcode)) {
                // one more case about this ann:
                // how many anns have been found?
                if (ann_dict[hashcode].length > 1) {
                    // this is a dupliated ann
                    iaa_dict.stat.duplicates.push({
                        ann: ann_b,
                        from: 'b'
                    });
                    console.log('* found duplicated ann b', ann_b);

                    continue;
                }
            } else {
                // which means this ann has no ann in a
                ann_dict[hashcode] = [{
                    ann: ann_b,
                    from: 'b'
                }];
                iaa_dict.stat.unmatched.push({
                    ann: ann_b,
                    from: 'b'
                });
                console.log('* found unmatched ann b', ann_b);
                continue;
            }
            
            // OK, this ann_b could be matched with ann_a
            var ann_a = ann_dict[hashcode][0].ann;
            iaa_dict.ann[hashcode] = {
                anns: [
                    ann_a,
                    ann_b
                ],
                rst: {},
            };

            // save the hashcode
            iaa_dict.stat.matched_hashcodes.push(hashcode);
            
            // let's save this ann_b
            ann_dict[hashcode].push({ 
                ann: ann_b,
                from: 'b'
            });

            // now, time to evaluate
            var rst = this.evaluate_ann_on_dtd(
                dtd,
                ann_a,
                ann_b,
                match_mode,
                overlap_ratio,
                tag_attrs,
                remove_tag_b_when_low_overlap
            );

            // save this result
            iaa_dict.ann[hashcode].rst = rst;
        }

        // third, check if there is any unmatched from ann a
        for (const hashcode in ann_dict) {
            if (Object.hasOwnProperty.call(ann_dict, hashcode)) {
                if (ann_dict[hashcode].length == 1 &&
                    ann_dict[hashcode][0].from == 'a') {
                    // which means ... this ann is not used for matching
                    iaa_dict.stat.unmatched.push(ann_dict[hashcode][0]);

                    console.log('* found unmatched ann a', ann_dict[hashcode][0].ann);
                }
            }
        }

        // finally, calculate the result at all and tag levels
        var cm_all = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var cm_tag = { tp: 0, fp: 0, fn: 0 };
            
            for (const hashcode in iaa_dict.ann) {
                if (Object.hasOwnProperty.call(iaa_dict.ann, hashcode)) {
                    const iaa = iaa_dict.ann[hashcode];
                    // add the result of this tag
                    cm_tag.tp += iaa.rst.tag[tag_def.name].cm.tp;
                    cm_tag.fp += iaa.rst.tag[tag_def.name].cm.fp;
                    cm_tag.fn += iaa.rst.tag[tag_def.name].cm.fn;
                }
            }
            // get the tag level result
            var tag_result = this.calc_p_r_f1(cm_tag);
            iaa_dict.tag[tag_def.name] = tag_result;

            // add the tag level to all
            cm_all.tp += cm_tag.tp;
            cm_all.fp += cm_tag.fp;
            cm_all.fn += cm_tag.fn;
        }
        // get the all level result
        var all_result = this.calc_p_r_f1(cm_all);

        iaa_dict.all = all_result;

        // update the cohen kappa of all
        all_result.cohen_kappa = this.get_cohen_kappa_overall(iaa_dict);

        return iaa_dict;
    },

    /**
     * Evaluate the IAA based on given schema and 
     * two annotation from two annotators
     * 
     * @param {Object} dtd the annotation schema
     * @param {Object} ann_a an annotation by A
     * @param {Object} ann_b an annotation by B
     * @param {string} match_mode overlap or exact match
     * @param {float} overlap_ratio overlap ratio
     * @param {Object} tag_attrs which attr to be used in calc 
     * @returns Object of IAA result
     */
    evaluate_ann_on_dtd: function(
        dtd, 
        ann_a, 
        ann_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // check each etag
        var result_ann = {
            all: {},
            tag: {}
        }
        var cm_ann = { tp: 0, fp: 0, fn: 0 };
        for (let i = 0; i < dtd.etags.length; i++) {
            const tag_def = dtd.etags[i];
            var r = this.evaluate_ann_on_tag(
                tag_def, 
                ann_a, 
                ann_b, 
                match_mode, 
                overlap_ratio,
                tag_attrs,
                remove_tag_b_when_low_overlap
            );
            result_ann.tag[tag_def.name] = r;

            // add the result of this tag
            cm_ann.tp += r.cm.tp;
            cm_ann.fp += r.cm.fp;
            cm_ann.fn += r.cm.fn;

        }
        var all_result = this.calc_p_r_f1(cm_ann);

        result_ann.all = all_result;

        // update the cohen kappa of all
        all_result.cohen_kappa = this.get_cohen_kappa_overall(result_ann);

        return result_ann;
    },

    evaluate_ann_on_tag: function(
        tag_def, 
        ann_a, 
        ann_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }

        // check the text first
        if (ann_a.text != ann_b.text) {
            throw { 
                name: 'Different texts', 
                message: 'The texts are different in given annotations.'
            };
        }

        // get all tags of this tag_def
        var tag_list_a = this.get_tag_list_by_tag(tag_def, ann_a);
        var tag_list_b = this.get_tag_list_by_tag(tag_def, ann_b);

        var cm = this.calc_matching(
            tag_list_a, 
            tag_list_b, 
            match_mode, 
            overlap_ratio,
            tag_attrs,
            remove_tag_b_when_low_overlap
        );
        var result = this.calc_p_r_f1(cm);

        return result;
    },

    calc_matching: function(
        tag_list_a, 
        tag_list_b, 
        match_mode, 
        overlap_ratio,
        tag_attrs,
        remove_tag_b_when_low_overlap
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        if (typeof(remove_tag_b_when_low_overlap) == 'undefined') {
            remove_tag_b_when_low_overlap = true;
        }
        var cm = {
            tp: 0,
            fp: 0,
            fn: 0,
            
            // save the details
            tags: {
                tp: [],
                fp: [],
                fn: []
            }
        };

        // this dictionary is for generating the list for FN list
        var tag_dict_b = {};
        for (let i = 0; i < tag_list_b.length; i++) {
            const tag = Object.assign({}, tag_list_b[i]);
            tag_dict_b[tag.spans] = tag;
        }

        // check each element in tag_list_a and find matched in b
        for (let i = 0; i < tag_list_a.length; i++) {
            var tag_a = tag_list_a[i];
            
            // the `tag_list_b` may be not empty
            // if not match, may due to the low overlap
            // the return result also contains the overlap rate
            var is_match = this.is_tag_match_in_list(
                tag_a, 
                tag_list_b, 
                match_mode,
                overlap_ratio,
                tag_attrs
            );

            // console.log('* a', tag_a.spans, is_match.is_in, 'b', is_match.tag_b);

            if (is_match.is_in) {
                // This case is simple, two tags are matched
                cm.tp += 1;
                cm.tags.tp.push([
                    tag_a, 
                    is_match.tag_b
                ]);

                // remove this tag_b from the dict
                delete tag_dict_b[is_match.tag_b.spans];

            } else {
                // This case means that this tag is not found in tag_list_b
                cm.fp += 1;
                cm.tags.fp.push([
                    tag_a, 
                    // usually, the tag_b is null,
                    // but sometimes it is not depends on the rate
                    is_match.tag_b
                ]);

                // in some cases, it does not match due to low overlap ratio
                // we need to remove this tag_b as well.
                // but we may also want to keep both?
                if (is_match.tag_b != null) {
                    if (remove_tag_b_when_low_overlap) {
                        delete tag_dict_b[is_match.tag_b.spans];
                    } else {
                        // well, users specify to keep this, then just keep it
                    }
                }
            }
        }

        cm.fn = Object.values(tag_dict_b).length;
        // cm.fn = tag_list_b.length - cm.tp;
        cm.tags.fn = Object.values(tag_dict_b).map(tag => [null, tag]);

        return cm;
    },

    is_tag_match_in_list: function(
        tag, 
        tag_list, 
        match_mode, 
        overlap_ratio,
        tag_attrs
    ) {
        if (typeof(match_mode)=='undefined') {
            match_mode = 'overlap';
        }
        if (typeof(overlap_ratio) == 'undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = null;
        }
        var spans = tag.spans;
        var loc_a = this.spans2loc(spans);

        // potential b
        var p_tag_b = null;
        // the overlap rate
        var olpr = 0;

        for (let i = 0; i < tag_list.length; i++) {
            const tag_b = tag_list[i];
            var spans_b = tag_b.spans;

            if (match_mode == 'overlap') {
                // for overlap mode, check ranges of two spans
                var loc_b = this.spans2loc(spans_b);

                // the overlap contains two value
                // first the decision based on the ratio
                // seoncd the how much is overlapped
                var is_olpd = this.is_overlapped(
                    loc_a, 
                    loc_b, 
                    overlap_ratio
                );
                if (is_olpd[0]) {
                    // check if using tag_attrs
                    if (tag_attrs == null) {
                        // OK, the overlap is bigger than the ratio
                        // just return this is matched
                        return { 
                            is_in: true,
                            tag_b: tag_b,
                            olpr: is_olpd[1],
                            atum: null
                        };
                    } else {
                        // too bad, need to check the attributes
                        var is_atmd = this.is_attrs_matched(
                            tag,
                            tag_b,
                            tag_attrs
                        );

                        if (is_atmd[0]) {
                            // great! perfect match!
                            return { 
                                is_in: true,
                                tag_b: tag_b,
                                olpr: is_olpd[1],
                                atum: null
                            };
                        } else {
                            // too bad, some attr maybe different
                            return { 
                                is_in: false,
                                tag_b: tag_b,
                                olpr: is_olpd[1],
                                // ATtribute UnMatched
                                atum: is_atmd[1]
                            };
                        }
                    }
                }
                // in some cases, the overlapped ratio is low
                // but still match, we need to check this case
                if (is_olpd[1] > 0) {
                    p_tag_b = tag_b;
                }
                
            } else if (match_mode == 'exact') {

                if (spans == spans_b) {
                    return {
                        is_in: true,
                        tag_b: tag_b,
                        olpr: 1,
                        atum: null
                    };
                }
                
            }
        }

        return {
            is_in: false,
            tag_b: p_tag_b,
            olpr: olpr,
            atum: null
        };
    },

    is_attrs_matched: function(tag_a, tag_b, tag_attrs) {
        if (typeof(tag_attrs) == 'undefined') {
            tag_attrs = {};
        }
        for (const attr in tag_a) {
            if (!tag_attrs.hasOwnProperty(tag_a.tag)) {
                // what??? 
                break;
            }
            if (!tag_attrs[tag_a.tag].hasOwnProperty(attr)) {
                // skip those system attr
                continue;
            }
            if (!tag_attrs[tag_a.tag][attr]) {
                // skip those unselected attr
                continue;
            }
            if (Object.hasOwnProperty.call(tag_a, attr)) {
                const val_a = tag_a[attr];

                if (tag_b.hasOwnProperty(attr)) {
                    // skip those attrs that not available
                    const val_b = tag_b[attr];

                    if (val_a == val_b) {
                        // ok, nothing to do with one as they are the same 
                        continue;

                    } else {
                        // ok, we found different attr val!
                        return [false, attr];
                    }
                } else {
                    // what??? this can't be!
                    // return [false, attr];
                    continue;
                }
            }
        }
        // ok, is matched and no difference
        return [true, null];
    },

    is_overlapped: function(loc_a, loc_b, overlap_ratio) {
        if (typeof(overlap_ratio)=='undefined') {
            overlap_ratio = this.default_overlap_ratio;
        }
        
        var s_a = new Set(new Array(loc_a[1] - loc_a[0] + 1).fill(loc_a[0]).map((e,i)=>e+i));
        var s_b = new Set(new Array(loc_b[1] - loc_b[0] + 1).fill(loc_b[0]).map((e,i)=>e+i));

        var s_inter = this.set_intersection(s_a, s_b);
        var s_union = this.set_union(s_a, s_b);
        var r = s_inter.size / s_union.size;

        // console.log('* is overlapped', loc_a, '', loc_b, 'i:', s_inter.size, 'u:', s_union.size, 'r:', r);

        if (r >= overlap_ratio) {
            return [true, r];
        } else {
            return [false, r]
        }
    },

    spans2loc: function(spans) {
        var vs = spans.split('~');
        return [
            parseInt(vs[0]), 
            parseInt(vs[1])
        ];
    },

    calc_p_r_f1: function(cm) {
        var precision = this.calc_precision(cm.tp, cm.fp);
        var recall = this.calc_recall(cm.tp, cm.fn);
        var f1 = this.calc_f1_by_pr(precision, recall);
        var cohen_kappa = this.get_cohen_kappa(cm.tp, cm.fp, cm.fn);

        return {
            precision: precision,
            recall: recall,
            f1: f1,
            cohen_kappa: cohen_kappa,
            cm: cm
        }
    },

    calc_precision: function(tp, fp) {
        return tp / (tp + fp);
    },

    calc_recall: function(tp, fn) {
        return tp / (tp + fn);
    },

    /**
     * Calculate the total number of records
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns number of total
     */
    calc_N: function(tp, fp, fn) {
        return tp + fp + fn;
    },

    /**
     * Calculate the percentage agreement
     * 
     * As this is no TN, the PerAgr is just the TP
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns Po
     */
    calc_Po: function(tp, fp, fn) {
        return tp / this.calc_N(tp, fp, fn);
    },

    calc_Pe: function(tp, fp, fn) {
        var N = this.calc_N(tp, fp, fn);
        return ((tp + fn) * (tp + fp) + fn * fp) / N**2;
    },

    calc_cohen_kappa: function(Po, Pe) {
        // get the cohen's kappa
        if (Pe == 1) {
            Pe = 1.0001;
        }
        return 1 - (1 - Po) / (1 - Pe);
    },
    
    calc_cohen_kappa_SE_k: function(N, Po, Pe) {
        return (
            Po * (1 - Po) / 
            (N * (1 - Pe) ** 2)
        )**0.5;
    },

    get_cohen_kappa_overall: function(iaa_rst) {
        // the N is just the total number
        var N = this.calc_N(
            iaa_rst.all.cm.tp,
            iaa_rst.all.cm.fp,
            iaa_rst.all.cm.fn
        );
        // the overall Po is as usuall
        var Po = this.calc_Po(
            iaa_rst.all.cm.tp, 
            iaa_rst.all.cm.fp, 
            iaa_rst.all.cm.fn
        );

        // Need to get the sub-Pe
        var sPes = [];
        var Pes = {
            a: {},
            b: {}
        };

        // for the EMPTY tags
        var _eA = 0;
        var _eB = 0;

        for (const tag_name in iaa_rst.tag) {
            if (Object.hasOwnProperty.call(iaa_rst.tag, tag_name)) {
                const rst = iaa_rst.tag[tag_name];
                Pes.a[tag_name] = (rst.cm.tp + rst.cm.fn) / N;
                Pes.b[tag_name] = (rst.cm.tp + rst.cm.fp) / N;
                var sPe = Pes.a[tag_name] * Pes.b[tag_name];
                sPes.push(sPe);

                _eA += rst.cm.fn;
                _eB += rst.cm.fp;
            }
        }

        // calc the _EMPTY_
        Pes.a['_EMPTY_'] = _eA / N;
        Pes.b['_EMPTY_'] = _eB / N;
        sPes.push(Pes.a['_EMPTY_'] * Pes.b['_EMPTY_']);

        // sum all
        var Pe = sPes.reduce((a, b) => a + b, 0);

        // get the cohen's kappa
        var kappa = this.calc_cohen_kappa(Po, Pe);

        // get the SE_k
        var SE_k = this.calc_cohen_kappa_SE_k(N, Po, Pe);

        // get the lower and upper for 95% CI
        var lower = kappa - 1.96 * SE_k;
        var upper = kappa + 1.96 * SE_k;

        return {
            N: N,
            Po: Po,
            Pe: Pe,
            Pes: Pes,
            kappa: kappa,
            SE_k: SE_k,
            lower: lower,
            upper: upper
        };
    },

    /**
     * Get the Cohen's Kappa Score and 95% CI
     * 
     * The definition comes from 
     * https://en.wikipedia.org/wiki/Cohen%27s_kappa
     * 
     * @param {number} tp True positive
     * @param {number} fp False positive
     * @param {number} fn False negative
     * @returns Cohen's Kappa Score and 95% CI
     */
     get_cohen_kappa: function(tp, fp, fn) {
        var N = this.calc_N(tp, fp, fn);
        var Po = this.calc_Po(tp, fp, fn);
        var Pe = this.calc_Pe(tp, fp, fn);

        // get the cohen's kappa
        var kappa = this.calc_cohen_kappa(Po, Pe);

        // get the SE_k
        var SE_k = this.calc_cohen_kappa_SE_k(N, Po, Pe);

        // get the lower and upper for 95% CI
        var lower = kappa - 1.96 * SE_k;
        var upper = kappa + 1.96 * SE_k;

        return {
            N: N,
            Po: Po,
            Pe: Pe,
            kappa: kappa,
            SE_k: SE_k,
            lower: lower,
            upper: upper
        };
    },

    calc_f1: function(tp, fp, fn) {
        var precision = this.calc_precision(tp, fp);
        var recall = this.calc_recall(tp, fn);
        return 2 * precision * recall / (precision + recall);
    },

    calc_f1_by_pr: function(precision, recall) {
        return 2 * precision * recall / (precision + recall);
    },

    get_tag_list_by_tag: function(tag_def, ann) {
        var tag_dict = {};
        for (let i = 0; i < ann.tags.length; i++) {
            const tag = ann.tags[i];
            if (tag.tag == tag_def.name) {
                tag_dict[tag.spans] = tag;
            }
        }

        // conver the dictionary to list
        var tag_list = Object.values(tag_dict);
        return tag_list;
    },

    hash: function(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    },

    to_fixed: function(v) {
        if (typeof(v) == 'undefined' ||
            v == null || 
            isNaN(v)) {
            return 'NA';
        }
        return v.toFixed(4);
    },

    set_union: function(setA, setB) {
        let _union = new Set(setA)
        for (let elem of setB) {
            _union.add(elem)
        }
        return _union
    },
    
    set_intersection: function(setA, setB) {
        let _intersection = new Set()
        for (let elem of setB) {
            if (setA.has(elem)) {
                _intersection.add(elem)
            }
        }
        return _intersection
    },

    /**
     * Find the longest common substring
     * @param {string} str1 a string
     * @param {string} str2 another string
     * @returns longest common substring
     */
    find_lcs: function(str1, str2) {
        let m = new Array(str1.length+1).fill(0).map(function() {
            return new Array(str2.length+1).fill(0);
        });
        let max = 0;
        let index = null;
        for (let i = 0; i < str1.length; i++) {
            
            for (let j = 0; j < str2.length; j++) {
                
                if(str1.charAt(i) === str2.charAt(j)){
                    if(i>0 && j>0 && m[i-1][j-1]>0) {
                        m[i][j] = 1 + m[i-1][j-1];
                    } else{
                        m[i][j] = 1;
                    }
                    
                    if(max < m[i][j]){
                        max = m[i][j];
                        index = i;
                    }
                } else {
                    
                }
            }
        }

        return str1.substr(index-max + 1, max)
    },
    
};

// The NLP toolkit
var nlp_toolkit = {

    sent_tokenize: function(text, backend) {
        if (typeof(backend) == 'undefined') {
            backend = 'simpledot';
        }
        // console.log('* sentencizing text by ' + backend);

        if (backend == 'simpledot') {
            return this.sent_tokenize_by_simpledot(text);
        }

        if (backend == 'compromise') {
            return this.sent_tokenize_by_compromise(text);
        }

        if (backend == 'wink_nlp') {
            return this.sent_tokenize_by_wink_nlp(text);
        }

        throw {
            name: 'Not found backend',
            message: "The backend is not valid."
        }
    },

    tokenize_by_wink_nlp: function(text) {

    },

    /**
     * Convert the spans to the token index
     * 
     * The item in the list of tags need to contain the following:
     * {
     *     name: 'NAME', // the name this tags, e.g., LOC, PER, GEO
     *     span: [1, 2], // the start and end this tag in this sentence
     * }
     * 
     * So, the text of the tag is not required.
     * After processing, this will return a list:
     * [{
     *     token: 'TOKEN TEXT', // the text of this token
     *     span: [1, 2],        // the start and end of this token
     *     label: 'B-LOC'       // the BIO label, e.g., B-X, I-X, O
     * }, ...]
     * 
     * If any pre-processing is needed, please do it before calling.
     * 
     * @param {string} sentence just a sentence text
     * @param {list} tags list of tags
     * 
     * @returns {list} the list of token position and labels
     */
    convert_span_to_bio_by_wink_nlp: function(sentence, tags) {
        // first, convert the sentence to tokens
        var doc = wink_nlp.readDoc(sentence);
        var tokens = doc.tokens().out();
        
        // then search each token and get the position
        var idx = 0; 
        var pos = []; 
        for (let i=0; i<tokens.length; i++) {
            const token = tokens[i];
            var ia = sentence.indexOf(token);
            var tp = 1;
            while(true) {
                if (ia >= idx) {
                    pos.push({
                        token: token,
                        span: [ia, ia + token.length],
                        // the default label is just O
                        label: 'O'
                    })
                    idx = ia + token.length;
                    break;
                } else {
                    ia = sentence.indexOf(token, tp);
                    tp += 1;
                }
            }
        }
        
        // ok, let's check each token pos
        // make a copy of tags
        var tgs = JSON.parse(JSON.stringify(tags));
        for (let i=0; i<pos.length; i++) {
            // the simplest is just check all tags
            for (let j=0; j<tgs.length; j++) {
                if (i==4) {
                    console.log("j=" +j + ': '+ tgs[j].span + ' vs ' + pos[i].span);
                }
                if (this.is_overlapped(tgs[j].span, pos[i].span)) {
                    if (tgs[j].hasOwnProperty('_has_met')) {
                        pos[i].label = 'I-' + tgs[j].name;
                    } else {
                        pos[i].label = 'B-' + tgs[j].name;
                        tgs[j]._has_met = true;
                    }
                    break;
                }
            }
        }
        
        return pos;
    },

    sent_tokenize_by_wink_nlp: function(text) {
        var doc = wink_nlp.readDoc(text);
        var raw_sentences = doc.sentences().out();

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};
        // get all sentences and spans
        var sentences = [];
        // get all sentence trimed text
        var sentences_text = [];

        for (let idx=0; idx<raw_sentences.length; idx++) {
            // get this sentence
            var sentence = raw_sentences[idx];
            var spans_start = text.indexOf(sentence);

            // TODO fix the multiple same sentence bug
            if (sentences_dict.hasOwnProperty(sentence)) {
                // which means this is a duplicated 
                var i = 1;
                var cnt = 0;
                while(true) {
                    spans_start = text.indexOf(sentence, i);

                    if (sentences_dict[sentence] == spans_start) {
                        // which means this sentence appeared
                        i += 1;
                        cnt += 1;

                    } else {
                        // which means this span start is a new one
                        sentences_dict[sentence] = spans_start;
                        break;
                    }
                }

            } else {
                // ok, just add this new sentence
                sentences_dict[sentence] = spans_start;
            }
            var spans_end = spans_start + sentence.length;

            // sometimes the sentence has right blanks
            // we need to remove it to avoid unexpected linebreaks
            sentence = sentence.trimRight();

            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        };

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    /**
     * Sentencize a given text by a simple method
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_simpledot: function(text) {
        // get all sentences and spans
        var sentences = [];

        // get all sentence trimed text
        var sentences_text = [];

        // a temp sentence
        var sentence = [];

        // locate the sentence start
        var spans_start = 0;

        // locate the sentence end
        var spans_end = 0;
        
        // flag for a sentence end
        var flag_sent = false;

        for (let i = 0; i < text.length; i++) {
            // get the current char
            const c = text[i];

            // set the end to current char
            spans_end = i;
            
            // before checking, set the flag to false
            flag_sent = false;

            // detect if this is a sentence break
            if (c == '.') {
                // but there are some corner cases
                if (i+1 < text.length && text[i+1].trim() != '') {
                    // which means next char is not empty
                    // this dot is not for a sentence
                    sentence.push(c);

                } else {
                    // this is an end of sentence
                    flag_sent = true;
                    // collect the char
                    sentence.push(c);
                }
                
            } else if ( c == '?' || c == '!' || c == ';') {
                flag_sent = true;
                // collect the char
                sentence.push(c);
    
            } else if ( c == '\n') {
                flag_sent = true;
                // no need to collect
                // sentence.push(c);

            } else {
                // collect the char
                sentence.push(c);
            }

            if (flag_sent) {
                // ok, this is a sentence.
                var _sentence = sentence.join('');

                // clear the collection
                sentence = [];

                // create a new sentence obj
                sentences.push({
                    text: _sentence, 
                    spans: {
                        start: spans_start, 
                        end: spans_end
                    }
                });

                // put the text
                sentences_text.push(_sentence);

                // move the spans_start to spans_end
                spans_start = spans_end + 1;
            }
        }

        // ok, let's check if the sentence collection is empty
        if (sentence.length > 0) {
            // there is a last sentence
            var _sentence = sentence.join('');

            // create a new sentence obj
            sentences.push({
                text: _sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });

            // put the text
            sentences_text.push(_sentence);
        }

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },


    /**
     * Sentencize a given text by a compromise.cool NLP
     * @param {String} text the content to be sentencized
     * @returns Object of sentences
     */
    sent_tokenize_by_compromise: function(text) {
        // first, convert the raw text to a doc object
        var doc = nlp(text);

        // get all sentences and spans
        var sentences = [];

        // for get the spans correctly
        // and the value is the last appearance
        var sentences_dict = {};

        // get all sentence trimed text
        var sentences_text = [];

        var doc_sentences = doc.sentences().json({
            offset: true
        });

        for (let i = 0; i < doc_sentences.length; i++) {
            const d = doc_sentences[i];
            
            // get this sentence text
            var sentence = d.text;

            // get the offset by compromise.cool NLP
            // thanks to spencer kelly (spencermountain@gmail.com)
            var spans_start = d.offset.start;
            var spans_end = d.offset.start + d.offset.length - 1;

            // to avoid right new line
            sentence = sentence.trimRight();

            // to avoid inline new line
            sentence = sentence.replaceAll('\n', ' ');
            sentence = sentence.replaceAll('\r', ' ');

            // save this sentence
            sentences.push({
                text: sentence, 
                spans: {
                    start: spans_start, 
                    end: spans_end
                }
            });
            sentences_text.push(sentence);
        }

        // doc.sentences().forEach(function(d) {
        //     // get this sentence
        //     var sentence = d.text();
        //     var spans_start = text.indexOf(sentence);

        //     // TODO fix the multiple same sentence bug
        //     if (sentences_dict.hasOwnProperty(sentence)) {
        //         // which means this is a duplicated 
        //         var i = 1;
        //         var cnt = 0;
        //         while(true) {
        //             spans_start = text.indexOf(sentence, i);

        //             if (sentences_dict[sentence] == spans_start) {
        //                 // which means this sentence appeared
        //                 i += 1;
        //                 cnt += 1;

        //             } else {
        //                 // which means this span start is a new one
        //                 sentences_dict[sentence] = spans_start;
        //                 break;
        //             }
        //         }

        //     } else {
        //         // ok, just add this new sentence
        //         sentences_dict[sentence] = spans_start;
        //     }
        //     var spans_end = spans_start + sentence.length;

        //     // sometimes the sentence has right blanks
        //     // we need to remove it to avoid unexpected linebreaks
        //     sentence = sentence.trimRight();

        //     sentences.push({
        //         text: sentence, 
        //         spans: {
        //             start: spans_start, 
        //             end: spans_end
        //         }
        //     });
        //     sentences_text.push(sentence);
        // });

        return { 
            sentences: sentences,
            sentences_text: sentences_text.join('\n')
        };
    },

    find_linech: function(pos, sentences) {
        for (let i = 0; i < sentences.length; i++) {
            const sentence = sentences[i];
            if (pos>=sentence.spans.start &&
                pos<=sentence.spans.end) {
                return {
                    line: i, 
                    ch: pos-sentence.spans.start
                };
            }
        }
        return null;
    },

    is_overlapped: function(a, b) {
        if (a[0] >= b[0] && a[0] < b[1]) {
            return true;
        }
        if (a[1] > b[0] && a[1] <= b[1]) {
            return true;
        }
        if (a[0] <= b[0] && a[1] >= b[1]) {
            return true;
        }
        return false;
    },

    download_text_tsv: function(anns, dtd, hint_dict, fn) {
        // convert the hint dict to a json obj
        var json = [];

        for (const tag_name in hint_dict) {
            if (Object.hasOwnProperty.call(hint_dict, tag_name)) {
                const tag_dict = hint_dict[tag_name];
                
                for (const tag_text in tag_dict.text_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.text_dict, tag_text)) {
                        const tag = tag_dict.text_dict[tag_text];
                        
                        json.push({
                            tag: tag_name,
                            text: tag_text,
                            count: tag.count
                        });
                    }
                }

                // the nc tag
                for (const fn in tag_dict.nc_dict.ann_fn_dict) {
                    if (Object.hasOwnProperty.call(tag_dict.nc_dict.ann_fn_dict, fn)) {
                        const count = tag_dict.nc_dict.ann_fn_dict[fn];
                        
                        json.push({
                            tag: tag_name,
                            text: fn,
                            count: count
                        });
                    }
                }
            }
        }

        // then convert the json to csv
        var tsv = Papa.unparse(json, {
            delimiter: '\t'
        });

        // download this tsv
        var blob = new Blob([tsv], {type: "text/tsv;charset=utf-8"});
        saveAs(blob, fn);

        return tsv;
    },

    /**
     * Download the anns as raw XML format
     * @param {list} anns the list of ann objects
     * @param {object} dtd the dtd schema
     * @param {string} fn the download filename
     */
    download_dataset_raw: function(anns, dtd, fn, skip_dtd) {
        if (typeof(skip_dtd)=='undefined') {
            // by default, we don't need the dtd file to be included
            skip_dtd = true;
        }

        // create an empty zip pack
        var zip = new JSZip();
        var file_list = [];

        // put the dtd
        if (skip_dtd) {

        } else {
            // add the dtd content if exists
            if (dtd.hasOwnProperty('text')) {
                var dtd_fn = dtd.name + '.dtd';
                zip.file(dtd_fn, dtd.text);
                file_list.push(dtd.name + '.dtd');
            }
        }

        // create a folder in this zip file
        // var folder_name = 'annotation-'+ dtd.name + '';
        // use the given filename as the folder name (exclude the .zip)
        var folder_name = fn.substring(0, fn.lastIndexOf('.'));

        // check each ann file
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            
            // convert to xml first
            var xmlDoc = ann_parser.ann2xml(ann, dtd);

            // convert xml to string
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the filename of this annotation
            var ann_fn = ann._filename;

            // get the file
            // add the text dataset to zip
            var full_fn = folder_name + '/' + ann_fn;
            zip.file(full_fn, xmlStr);
            file_list.push(full_fn);
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then((function(fn) {
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));

        return file_list.join('\n');
    },

    /**
     * Download the BIO format dataset
     * 
     * @param {list} anns the list of ann object
     * @param {object} dtd the dtd schema
     */
    download_dataset_bio: function(anns, dtd, fn, ratios, skip_non_tags_sentence) {
        if (typeof(ratios)=='undefined') {
            ratios = [0.8, 0.1, 0.1];
        }
        if (typeof(skip_non_tags_sentence)=='undefined') {
            skip_non_tags_sentence = true;
        }
        // first, create the dataset itself
        var ann_sentence_tags = {};

        // check each tag
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            var sentence_tags = {};
            for (let j = 0; j < ann.tags.length; j++) {
                const tag = ann.tags[j];

                // now mapping the span to token index
                if (!tag.hasOwnProperty('spans')) {
                    // this is not an entity tag
                    continue;
                }
                
                var spans = tag.spans.split(',');
                for (let k = 0; k < spans.length; k++) {
                    const _span = spans[k];

                    const span = this.txt2span(_span);
                    if (span[0] == -1 || spans[1] == -1) {
                        // which means this tag is just a non-consuming tag
                        // at present, we won't use this kind of tag when
                        // exporting the BIO
                        continue;
                    }
                    // find the offset in a sentence
                    var loc0 = this.find_linech(span[0], ann._sentences);
                    if (loc0 == null) {
                        // something wrong?
                        continue;
                    }

                    // find the location for the right part
                    // var loc1 = this.find_linech(span[1], ann._sentences);
                    var loc1 = Object.assign({}, loc0);
                    loc1.ch += (span[1] - span[0]);

                    if (!sentence_tags.hasOwnProperty(loc0.line)) {
                        sentence_tags[loc0.line] = {
                            sentence: ann._sentences[loc0.line],
                            tags: []
                        }
                    }

                    // put this tag for this line
                    sentence_tags[loc0.line].tags.push({
                        name: tag.tag,
                        span: [
                            loc0.ch,
                            loc1.ch
                        ],
                        // if k>0, which means this span is a multi location tag
                        force_label_i: k != 0
                    });
                }
            }
            ann_sentence_tags[i] = sentence_tags;
        }

        // now, we need to convert each sentence to 
        // the BIO format
        var bios_all = [];
        for (const ann_idx in ann_sentence_tags) {
            if (Object.hasOwnProperty.call(ann_sentence_tags, ann_idx)) {
                const sentence_tags = ann_sentence_tags[ann_idx];
                for (const sent_idx in sentence_tags) {
                    if (Object.hasOwnProperty.call(sentence_tags, sent_idx)) {
                        if (sentence_tags[sent_idx].tags.length == 0) {
                            if (skip_non_tags_sentence) {
                                continue;
                            }
                        };
                        
                        var labeled_tokens = this.convert_span_to_bio_by_wink_nlp(
                            sentence_tags[sent_idx].sentence.text,
                            sentence_tags[sent_idx].tags
                        );
        
                        bios_all.push(labeled_tokens);
                    }
                }
            }
        }
        // split into train, dev, test
        var [bios_train, bios_dt] = ds_spliter(bios_all, ratios[0]);
        var [bios_dev, bios_test] = ds_spliter(bios_dt, ratios[1] / (ratios[1] + ratios[2]));

        // create a help function for converting
        function bios2text(bios) {
            var txt_ds = [];
            var txt_lb = {};

            for (let i = 0; i < bios.length; i++) {
                const labeled_tokens = bios[i];
                for (let j = 0; j < labeled_tokens.length; j++) {
                    const item = labeled_tokens[j];
                    txt_ds.push(
                        item.token + '\t' + item.label
                    );
                    txt_lb[item.label] = 1;
                }
                // add a blank line after each sentence
                txt_ds.push('');
            }
            return [txt_ds, txt_lb];
        }

        // merge into text
        var [txt_dataset, txt_labels] = bios2text(bios_all);
        var [txt_train, _] = bios2text(bios_train);
        var [txt_dev, _] = bios2text(bios_dev);
        var [txt_test, _] = bios2text(bios_test);
        
        // convert text arr to pure string
        txt_dataset = txt_dataset.join('\n');
        txt_train = txt_train.join('\n');
        txt_dev = txt_dev.join('\n');
        txt_test = txt_test.join('\n');
        txt_labels = Object.keys(txt_labels).sort().join('\n');

        // last, create a zip file, which contains
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = 'dataset-'+ dtd.name + '-BIO';

        // add the text dataset to zip
        zip.file(folder_name + '/dataset.tsv', txt_dataset);
        // add the label to zip
        zip.file(folder_name + '/labels.tsv', txt_labels);
        // add the splited to zip
        zip.file(folder_name + '/train.tsv', txt_train);
        zip.file(folder_name + '/dev.tsv', txt_dev);
        zip.file(folder_name + '/test.tsv', txt_test);

        // create zip file
        zip.generateAsync({ type: "blob" }).then((function(fn) {
            return function (content) {
                saveAs(content, fn);
            }
        })(fn));

        return txt_dataset;
    },

    txt2span: function(txt) {
        var ps = txt.split('~');
        return [
            parseInt(ps[0]),
            parseInt(ps[1])
        ]
    }

};

// The MedTagger toolkit
/**
 * MedTagger format annotation file parser
 * 
 */
 var medtagger_toolkit = {
     regex: {
        // the pattern of key value for each result
        key_and_value: /(\S+)="([^"]+)"/gm,
    },

    convert_medtagger_files_to_anns: function(txts, anns, dtd) {
        // first of all, make a dict for ann file names
        var ann_dict = {};
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            ann_dict[ann.fh.name] = ann;
        }

        // then, work on each txt
        var ret = [];

        for (let i = 0; i < txts.length; i++) {
            const txt = txts[i];
            
            // the ann name should be exactly the txt + '.ann'
            var ann_fn = txt.fh.name + '.ann';

            if (!ann_dict.hasOwnProperty(ann_fn)) {
                // what???
                console.log('* not found ann file for', txt.fh.name);
                continue;
            }
            var ann = ann_dict[ann_fn];

            // ok, we found the matched ann!
            var ann_rs = this.parse_ann_content(
                ann
            );

            // to xml ann
            var mt_ann = this.to_medtator_ann(
                txt,
                ann_rs,
                dtd
            );

            var r = {
                txt: txt,
                ann: ann,
                ann_rs: ann_rs,
                medtator_ann: mt_ann
            }

            ret.push(r);
        }

        return ret;
    },

    to_medtator_ann: function(txt, ann_rs, dtd) {
        // this is an empty medtator ann
        var ann = {
            text: txt.text,
            dtd_name: dtd.name,
            tags: [],
            meta: {},

            // other info
            _fh: null,
            _filename: txt.fh.name + '.xml',
            _has_saved: true,
            _sentences: null,
            _sentences_text: null
        };

        for (let i = 0; i < ann_rs.length; i++) {
            const r = ann_rs[i];
        
            var tag = {};
            // each r contains many k-v pairs
            // we need to copy some values
            if (r.hasOwnProperty('text')) {
                tag['text'] = r.text;
            }
            if (r.hasOwnProperty('norm')) {
                tag['tag'] = r.norm;
            }
            if (r.hasOwnProperty('start') &&
                r.hasOwnProperty('end')) {
                tag['spans'] = r.start + '~' + r.end;
            }

            // then we need to check the tag quality
            if (tag.hasOwnProperty('tag') &&
                tag.hasOwnProperty('text')&&
                tag.hasOwnProperty('spans')) {
                // get the tag_def for this tag
                if (!dtd.tag_dict.hasOwnProperty(tag.tag)) {
                    // this is possible that the normed term may not be available
                    console.log('* skip unknown norm @' + i + ':', tag.tag);
                    continue;
                }

                // it should be matched with the dtd
                var tag_def = dtd.tag_dict[tag.tag];

                // now need to add an ID for this tag
                tag.id = ann_parser.get_next_tag_id(
                    ann,
                    tag_def
                )

                // one more step, the MedTagger output won't contain attrs
                // which are defined in the dtd, so we need to set them
                for (let k = 0; k < tag_def.attlists.length; k++) {
                    const att = tag_def.attlists[k];
                    if (tag.hasOwnProperty(att.name)) {
                        // ok, that's what it should be
                    } else {
                        // also ok, that's what it actually is 
                        tag[att.name] = att.default_value;                            
                        console.log('* patched missing '+tag.tag+'.'+att.name+'] to ' + tag.id);
                    }
                }
                ann.tags.push(tag);
            } else {
                console.log('* skip incomplete tag', tag);
            }
            
        }

        return ann;
    },

    /**
     * Parse the ann file
     * 
     * @param {Object} ann the ann 
     */
    parse_ann_content: function(ann) {

        // first, make a ret
        var rs = [];

        // second, split the ann lines
        for (let i = 0; i < ann.lines.length; i++) {
            const ann_line = ann.lines[i];
            var kvs = this.parse_ann_line(ann_line);

            if (kvs == null) {
                // so this line may be empty or no values?
                continue;
            }

            // I guess it works
            rs.push(kvs);
        }

        // no matter what we have at last, just return it
        return rs;
    },

    parse_ann_line: function(ann_line) {
        if (ann_line == '') {
            return null;
        }

        // the parts are seperated by \t sym
        var parts = ann_line.split('\t');

        // r is record or result
        var r = {};

        for (let i = 0; i < parts.length; i++) {
            const p = parts[i];
            var ret = this.get_key_and_value(p);

            if (ret.length < 2) {
                // must be something wrong??
                continue;
            }
            
            // the first value is the key
            // and the second is the value
            r[ret[0]] = ret[1];
        }

        return r;
    },

    get_key_and_value: function(s) {
        let m;
        var ret = [];
        let regex = this.regex.key_and_value;

        while ((m = regex.exec(s)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }

            // the final values?
            var values = [];

            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                // console.log(`Found attlist require match, group ${groupIndex}: ${match}`);
                // group 0 is the leading text
                if (groupIndex == 1) {
                    // which is the key
                    values.push(match)

                } else if (groupIndex == 2) {
                    // get value 
                    // not matter what is left, save it
                    values.push(match);
                }
            });

            ret = values;
        }

        
        return ret;
    },

 };

// The Vue App
var app_hotpot = {
    // metro app toast
    metro_toast: Metro.toast.create,

    // for tour
    tour: {
        annotation: null,
    },

    // vue app
    vpp: null,
    vpp_id: '#app_hotpot',

    vpp_data: {
        // for the section control
        section: 'annotation',

        // for the dtd
        dtd: null,

        // for schema editor dtd
        se_dtd: null,

        // for making schema from templates
        se_dtd_tpl_id: null,

        // decide which ann file is working on.
        // null indicates that currently it is not editing
        ann_idx: null,

        // for the ann files in the file list
        anns: [],

        // sort anns
        // - default: how the anns are imported into tool
        // - alphabet: A-Z
        // - alphabet_r: Z-A
        // - tags: 0-N
        // - tags_r: N-0
        // - label: color
        sort_anns_by: 'default',

        // for annotation tab working mode
        // there will be the following mode:
        // 1. annotation, which is the usually mode, and it is default
        // 2. adjudication, which is for adjudication from adj.tab
        // the UI logic will be different in each mode
        annotation_tab_working_mode: 'annotation',

        // for showing the tag by tag_name,
        display_tag_name: '__all__',

        // statistics
        display_stat_doc_sum_selected: null,
        stat_filter_min_tokens: 0,
        stat_filter_token_text: true,

        // for the hints of current ann
        hints: [],

        // for all hints of all anns
        hint_dict: {},

        // for popmenu
        clicked_tag_id: null,

        // hover
        hovered_tag: null,

        // a flag for showing which mode we are working
        is_linking: false,
        linking_tag_def: null,
        linking_tag: null,
        linking_atts: [],
        
        // linking
        pan_working_tag: {
            pos: {
                clientX: undefined,
                clientY: undefined,
                movementX: 0,
                movementY: 0
            }
        },

        // for converting the txt to xmls
        txt_anns: [],
        txt_xmls: [],
        txt_xml_prefix: '',
        txt_xml_suffix: '',

        // for file name filter
        fn_pattern: '',

        // for updating the sub module
        force_module_update: Math.random(), 

        // for IAA
        // see app_hotpot_ext_iaa.js

        // cm settings
        cm: {
            // document / sentences
            display_mode: 'document',

            // node / span
            mark_mode: 'node',

            // simple / smart
            hint_mode: 'simple',

            // update the hint when delete
            // but I found this is not doable.
            // the deleted tag may be used in different place,
            // so simplely deleting the token from hint dict 
            // may cause issue.
            enabled_auto_hint_update: true,

            // display the hints or not
            enabled_hints: true,

            // display the links
            enabled_links: true,

            // display the link name
            enabled_link_name: true,

            // display complex link
            enabled_link_complex: true,

            // for updating the codemirror instance
            is_expire: false
        },

        // general cfg
        cfg: {
            // display the setting panel or not
            is_show_settings: false,

            // active tab
            active_setting_tab: 'import',

            // which algorithm to use as default
            sentence_splitting_algorithm: 'simpledot',

            // render all marks or only the selected marks
            linking_marks_selection: 'all_concepts'
        },

        // for statistics

        // for export
        export_text: null,

        // for texts
        // this variable would be replaced by the 
        // app_hotpot_ext_texts.js module
        texts: {}
    },

    vpp_methods: {
        /////////////////////////////////////////////////////////////////
        // Settings related functions
        /////////////////////////////////////////////////////////////////
        switch_setting_tab: function(tab) {
            this.cfg.active_setting_tab = tab;
        },

        is_adjudication_working_mode: function() {
            return this.annotation_tab_working_mode == 'adjudication';
        },

        get_metator_mem: function() {
            // return Math.floor(window.performance.memory.totalJSHeapSize / 1024 / 1024);
            if (window.hasOwnProperty('performance')) {
                if (window.performance.hasOwnProperty('memory')) {
                    return Math.floor(window.performance.memory.usedJSHeapSize / 1024 / 1024);
                }
            } else {
                return 'NA';
            }
            return 'NA';
        },

        /////////////////////////////////////////////////////////////////
        // Annotation section related functions
        /////////////////////////////////////////////////////////////////
        save_xml_by_ann: function(ann) {
            var idx = this.find_included(
                ann._filename,
                this.anns
            );
            if (idx < 0) {
                // what????
                return
            } else {
                // ok, we find it
            }

            this.save_xml_by_idx(idx);
        },

        save_xml_by_idx: function(idx) {
            // switch to this ann first
            if (this.ann_idx != idx) {
                this.ann_idx = idx;
            }
            // $this.$forceUpdate();
            this.save_xml();
        },

        save_xml: function() {
            // before checking, need to ensure the FSA API
            if (this.has_FSA_API()) {
                // OK, go go go
            } else {
                // well ... it's ok ...
                app_hotpot.msg('The browser you are using does not support File System Access API. You can use "Download XML" function instead.', 'warning');
                return;
            }
            // before saving, need to check the _fh
            var p_ann = null;
            if (!this.anns[this.ann_idx].hasOwnProperty('_fh') || 
                this.anns[this.ann_idx]._fh === null ||
                typeof(this.anns[this.ann_idx]._fh.createWritable)==='undefined') {
                // which means this ann's original file is not available
                // or it is a txt-converted ann
                // let's go to save as directly
                p_ann = fs_save_new_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
                
            } else {
                // normal save
                var p_ann = fs_save_ann_file(
                    this.anns[this.ann_idx],
                    this.dtd
                );
            }
            p_ann.then(function(ann) {
                // usually it should be OK ...
                // but it may change ...
                // using the given ann to replace the current ann
                app_hotpot.vpp.set_current_ann(ann);
                app_hotpot.toast('Successfully saved ' + ann._filename);
            })
            .catch(function(error) {
                console.log(error);
                if (error.name == 'AbortError') {
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                if (error.name == 'NotAllowedError') {
                    // which means user or system cancelled this saving
                    app_hotpot.toast('Cancelled file saving.');
                    return;
                }
                app_hotpot.msg(
                    'Saving xml failed. Try to use "Save As" instead.', 
                    'bg-lightCrimson fg-white'
                );
                console.log('* error when save xml', error);
            });;
        },
        
        /////////////////////////////////////////////////////////////////
        // "Label" related functions
        /////////////////////////////////////////////////////////////////
        has_any_label: function(ann) {
            if (ann.hasOwnProperty('meta') &&
                ann.meta.hasOwnProperty('label') &&
                ann.meta.label.length > 0) {
                return true;
            }

            return false;
        },

        set_label: function(color, ann) {
            if (typeof(color)=='undefined') {
                color = 'green';
            }

            if (typeof(ann)=='undefined') {
                // just a reference
                ann = this.anns[this.ann_idx];
            }

            // if this is not label, the `label` may be available
            if (!this.has_any_label(ann)) {
                ann.meta['label'] = [];
            }

            // just set the label
            ann.meta['label'] = [{
                'color': color
            }];

            // mark this file is changed and needs to be saved
            ann._has_saved = false;

            // update the UI
            this.$forceUpdate();
        },

        remove_labels: function(ann) {
            if (typeof(ann)=='undefined') {
                // just a reference
                ann = this.anns[this.ann_idx];
            }

            ann.meta['label'] = [];

            // mark this file is changed and needs to be saved
            ann._has_saved = false;

            // update the UI
            this.$forceUpdate();
        },
        
        /////////////////////////////////////////////////////////////////
        // "Save as" related functions
        /////////////////////////////////////////////////////////////////
        
        save_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // create a new name for suggestion
            var new_fn = 'copy_of_' + fn;

            // ask for new fh for this file
            var p_fh = fs_get_new_ann_file_handle(new_fn);

            // when new fh is ready, save it
            p_fh.then((function(xmlStr){
                return function(fh) {
                    // first, update the fh
                    
                    // save this xmlStr with the given fh
                    let p_done = fs_write_ann_file(
                        fh,
                        xmlStr
                    );

                    // show something when saved
                    p_done.then(function(fh) {
                        app_hotpot.toast('Successfully saved as ' + fh.name);
                    });
                }
            })(xmlStr))
            .catch(function(error) {
                console.log('* error when save as xml', error);
            });
        },

        download_schema_as_dtd: function() {
            if (this.dtd.hasOwnProperty('text')) {
                // get the current file name
                var fn = this.dtd.name + '.dtd';

                // download this dtd text
                var blob = new Blob([this.dtd.text], {type: "text/txt;charset=utf-8"});
                saveAs(blob, fn);
            } else {
                // what???
                return;
            }
        },
        
        download_copy_as_xml: function() {
            // convert to xml
            var xmlDoc = ann_parser.ann2xml(
                this.anns[this.ann_idx],
                this.dtd
            );

            // convert to text
            var xmlStr = ann_parser.xml2str(xmlDoc, false);

            // get the current file name
            var fn = this.anns[this.ann_idx]._filename;

            // download this csv
            var blob = new Blob([xmlStr], {type: "text/xml;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_copy_as_bioc: function() {
            // create a new file name for this format
            var fn = 'BioC-' + this.anns[this.ann_idx]._filename;
            bioc_parser.download_dataset_bioc(
                [this.anns[this.ann_idx]],
                this.dtd,
                fn
            );
        },

        download_all_as_zip: function(skip_dtd) {
            if (typeof(skip_dtd) == 'undefined') {
                skip_dtd = true;
            }
            var fn = 'annotation-' + 
                this.dtd.name + 
                '-' +
                this.get_datetime_now() +
                '.zip';
            console.log('* download all as zip ' + fn);

            var file_list = nlp_toolkit.download_dataset_raw(
                this.anns,
                this.dtd,
                fn,
                skip_dtd
            );
            
            console.log('* downloaded zip file:', file_list);
            // update the UI?
        },

        /////////////////////////////////////////////////////////////////
        // Schema editor related functions
        /////////////////////////////////////////////////////////////////

        set_se_dtd: function(se_dtd) {
            this.se_dtd = se_dtd;
        },

        create_new_se_dtd: function() {
            var new_se_dtd = dtd_parser.mk_base_dtd('NEW_SCHEMA');

            this.set_se_dtd(new_se_dtd);
        },

        show_schema_editor: function(mode) {
            if (typeof(mode) == 'undefined') {
                mode = 0;
            }

            if (mode == 0) {
                // just open as it is

            } else if (mode == 1) {
                // create a new
                this.create_new_se_dtd();

            } else if (mode == 2) {
                // copy current dtd
                this.se_dtd = JSON.parse(JSON.stringify(this.dtd));

            } else {
                // ?
            }

            // open the dialog
            // Metro.dialog.open('#schema_editor');
            $('.schema-editor').show();
        },

        open_se_dtd: function() {
            if (isFSA_API_OK) {
                // the settings for dtd file
                var pickerOpts = {
                    types: [
                        {
                            description: 'DTD File',
                            accept: {
                                'text/dtd': ['.dtd']
                            }
                        },
                    ],
                    excludeAcceptAllOption: true,
                    multiple: false
                };

                // get the file handles
                var promise_fileHandles = fs_open_files(pickerOpts);

                promise_fileHandles.then(function(fileHandles) {
                    // read the fh and set dtd
                    // in fact, there is only one file for this dtd
                    for (let i = 0; i < fileHandles.length; i++) {
                        const fh = fileHandles[i];
                        if (!app_hotpot.is_file_ext(fh.name, 'dtd')) {
                            app_hotpot.msg('Please select a .dtd file', 'warning');
                            return;
                        }

                        // read the file
                        var p_dtd = fs_read_dtd_file_handle(fh);

                        p_dtd.then((function(){
                            return function(dtd) {
                                // just set the dtd
                                app_hotpot.vpp.set_se_dtd(dtd);
                            }
                        })());
                        
                        // just one file
                        break;
                    }
                });

            } else {
                console.log('* Not support FileSystemAccess API');
            }
        },

        load_se_dtd_sample: function() {
            if (this.se_dtd_tpl_id == null) {
                // ok, skip this
                app_hotpot.toast('Please select a sample schema');
                return;
            }

            // just alias name
            var sample_name = this.se_dtd_tpl_id;

            // ok, we have some selection here ...
            // for local version, load text through binding
            if (jarvis.hasOwnProperty('sample_dtd')) {
                // get the text from jarvis sample
                var sample_dtd_txt = jarvis.sample_dtd[sample_name];

                // parse the dtd from data
                var dtd = dtd_parser.parse(sample_dtd_txt);

                // set the se dtd
                app_hotpot.vpp.set_se_dtd(dtd);

                return;
            }

            // for web version, just load data through AJAX
            $.ajax({
                url: './static/data/' + sample_name + '.dtd',
                dataType: "text",
                success: function(data, status, xhr) {
                    // parse the dtd from data
                    var dtd = dtd_parser.parse(data);

                    // set the se dtd
                    app_hotpot.vpp.set_se_dtd(dtd);

                    // toast?
                    app_hotpot.toast(
                        'Loaded DTD content',
                        'info'
                    );
                },
                error: function (xhr, status, error) {
                    console.error(error);

                    app_hotpot.toast(
                        'Something wrong when loading DTD, try later?',
                        'warning'
                    );
                }
            });
        },

        use_se_dtd_for_annotation: function(se_dtd) {
            // check some conditions
            if (this.dtd == null) {
                // 
            } else {
                if (this.anns.length == 0) {

                } else {
                    var ret = window.confirm(
                        'Using this new schema need to clear all annotation files in the list to avoid schema conflicts.\nAre you sure to continue?'
                    );

                    if (ret) {

                    } else {
                        return;
                    }

                    this.remove_all_ann_files(true);

                }
            }

            // clear other iaa to avoid issues
            this.clear_iaa_all();

            // convert to full dtd first
            var dtd = dtd_parser.extend_base_dtd(se_dtd);
            
            // set dtd
            app_hotpot.set_dtd(dtd);

            // close
            this.close_schema_editor();
        },

        download_se_dtd: function(base_dtd) {
            // first, convert the base_dtd to text
            var text = dtd_parser.stringify(base_dtd);

            // then save it
            // get the current file name
            var fn = base_dtd.name + '.dtd';

            // download this dtd text
            var blob = new Blob([text], {type: "text/txt;charset=utf-8"});
            saveAs(blob, fn);
        },

        close_schema_editor: function() {
            $('.schema-editor').hide();
        },

        show_att_list_editor: function(att) {
            // get the current value
            var val = att.values.join('|');

            // show the promp
            var ret = window.prompt(
                'Set the items for attribute [' + att.name + ']. Seperate them by "|". \nFor example, apple|banana',
                val
            );

            // update the att values
            if (ret) {
                att.values = ret.split('|');
            } else {
                // nothing to do when no update
            }
        },

        add_se_dtd_tag: function(dtd, etag_or_ltag) {
            if (typeof(etag_or_ltag) == 'undefined') {
                // 0: etag
                // 1: ltag
                etag_or_ltag = 0;
            }

            var tag_type = '';
            if (etag_or_ltag == 0) {
                tag_type = 'etag';
                tag_name = 'NEW_ETAG_' + (dtd.etags.length+1);
            } else {
                tag_type = 'ltag';
                tag_name = 'NEW_LTAG_' + (dtd.ltags.length+1);
            }

            var  base_tag = dtd_parser.mk_base_tag(
                tag_name, 
                tag_type
            );

            // add to dtd directly?
            if (etag_or_ltag == 0) {
                dtd.etags.push(base_tag);

            } else {
                dtd.ltags.push(base_tag);
            }
        },

        add_se_dtd_tag_attr: function(dtd, tag_def) {
            var att = dtd_parser.mk_attlist(
                dtd.name,
                'new_attr_' + (tag_def.attlists.length+1),
                'text'
            )
            
            // add to the given tag??
            tag_def.attlists.push(att);
        },

        remove_se_dtd_tag: function(dtd, tag_def, etag_or_ltag, tag_idx) {
            var ret = window.confirm('Are you sure to remove the tag [' + tag_def.name + ']?');

            if (ret) {
                // ok, go ahead
            } else {
                return;
            }

            if (etag_or_ltag == 0) {
                // etag
                dtd.etags.splice(tag_idx, 1);

            } else {
                dtd.ltags.splice(tag_idx, 1);
            }
        },

        remove_se_dtd_tag_attr: function(dtd, tag_def, att, etag_or_ltag, tag_idx, att_idx) {
            if (att.vtype == 'list') {
                var ret = window.confirm('This attribute contains a list of values ['+att.values.join('|')+']. Are you sure to remove the attribute [' + tag_def.name + '.' + att.name + ']?');

                if (ret) {
                    // ok, go ahead
                } else {
                    return;
                }
            }
            if (etag_or_ltag == 0) {
                // etag
                dtd.etags[tag_idx].attlists.splice(att_idx, 1);

            } else {
                dtd.ltags[tag_idx].attlists.splice(att_idx, 1);
            }
        },

        is_valid_letter_for_dtd: function(char) {
            if (/^[A-Za-z0-9_]+$/.test(char)) {
                return true;
            } else {
                // Hmm, not match
                return false;
            }
        },

        on_keypress_se_dtd_input: function(event) {
            // get the character
            var char = String.fromCharCode(event.keyCode); 

            if (this.is_valid_letter_for_dtd(char)) {
                return true;
            } else {
                event.preventDefault(); 
            }
        },

        show_se_help: function() {
            // app_hotpot.start_tour_annotation();
            window.open(
                'https://github.com/OHNLP/MedTator/wiki/Annotation-Schema#schema-editor',
                '_blank'
            );
        },
        
        /////////////////////////////////////////////////////////////////
        // Show URL related functions
        /////////////////////////////////////////////////////////////////

        show_search_bar: function() {
            app_hotpot.codemirror.execCommand('find');
        },

        clear_search_result: function() {
            app_hotpot.codemirror.execCommand('clearSearch');
        },

        clear_filter_box: function() {
            this.fn_pattern = '';
        },

        show_wiki: function() {
            // app_hotpot.start_tour_annotation();
            window.open(
                'https://github.com/OHNLP/MedTator/wiki',
                '_blank'
            );
        },

        show_best_practice: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/wiki/Annotation-Best-Practices',
                '_blank'
            );
        },

        report_an_issue: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/issues',
                '_blank'
            );
        },

        show_changelog: function() {
            var html = [];
            // parse the latest change log
            var lines = jarvis.changelog_latest.split('\n');
            for (let i = 0; i < lines.length; i++) {
                var line = lines[i];
                line = line.trim();
                if (line == '') {
                    // nothing to do with empty line
                    continue;
                }
                if (html.length == 0) {
                    // this is the first line, the title
                    html.push(
                        '<h3 class="changelog-h3">' + 
                        '<b>MedTator</b> v' + 
                        line + 
                        '</h3>'
                    );
                } else {
                    html.push(
                        '<p class="changelog-p">'+line+'</p>'
                    );
                }
            }
            // last line is the link
            html.push(
                '<p>For more details, check <a target="_blank" href="https://github.com/OHNLP/MedTator#change-log">the README on our GitHub repo</a>.</p>'
            );
            html = html.join('');
            Metro.infobox.create(html);
        },

        show_howtouse: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/wiki/Manual#how-to-use-the-exported-data',
                '_blank'
            );
        },

        show_sample_schema_files: function() {
            window.open(
                'https://github.com/OHNLP/MedTator/tree/main/sample',
                '_blank'
            );
        },

        load_sample_ds: function(ds_name) {
            if (typeof(ds_name) == 'undefined') {
                ds_name = 'MINIMAL_TASK';
            }
            // for local version, load JSON data through binding
            if (jarvis.hasOwnProperty('sample_dict')) {
                var sample_data = jarvis.sample_dict[ds_name];

                // copy the sample to overwrite app_hotpot
                Object.assign(app_hotpot.vpp.$data, sample_data);
                app_hotpot.set_dtd(
                    app_hotpot.vpp.$data.dtd
                );
                app_hotpot.vpp.set_ann_idx(0);

                return;
            }

            // for web version, load JSON data through AJAX
            $.get(
                './static/data/vpp_data_'+ds_name+'.json', 
                {
                    rnd: Math.random()
                }, 
                function(data) {
                    Object.assign(app_hotpot.vpp.$data, data);
                    app_hotpot.set_dtd(
                        app_hotpot.vpp.$data.dtd
                    );
                    app_hotpot.vpp.set_ann_idx(0);
                }, 
                'json'
            );
        },

        load_sample_txt: function() {
            if (this.dtd == null) {
                app_hotpot.toast(
                    'Please load annotation schema first',
                    'warning'
                );
                return;
            }
            var ann = this.add_sample_txt_as_ann(
                jarvis.sample_text['covid_vax']
            );

            app_hotpot.toast(
                'Loaded a sample text [' + 
                ann._filename +
                '] for test'
            );
        },

        load_sample_txt_from_input: function() {
            if (this.dtd == null) {
                app_hotpot.toast(
                    'Please load annotation schema first',
                    'warning'
                );
                return;
            }
            var txt = window.prompt(
                'Please input text in the following input box.'
            );
        
            if (txt == null) {
                app_hotpot.toast(
                    'Cancelled creating sample text.'
                );
                return;
            }
            
            // just in case empty
            txt = txt.trim();
            if (txt.length == 0) {
                app_hotpot.toast(
                    'Failed to create a sample text from empty input.'
                );
                return;
            }

            var ann = this.add_sample_txt_as_ann(
                txt
            );

            app_hotpot.toast(
                'Loaded a sample text [' + 
                ann._filename +
                '] for test'
            );
        },

        open_dtd_file: function() {
            if (isFSA_API_OK) {
                // the settings for dtd file
                var pickerOpts = {
                    types: [
                        {
                            description: 'DTD File',
                            accept: {
                                'text/dtd': ['.dtd']
                            }
                        },
                    ],
                    excludeAcceptAllOption: true,
                    multiple: false
                };

                // get the file handles
                var promise_fileHandles = fs_open_files(pickerOpts);

                promise_fileHandles.then(function(fileHandles) {
                    // read the fh and set dtd
                    // in fact, there is only one file for this dtd
                    for (let i = 0; i < fileHandles.length; i++) {
                        const fh = fileHandles[i];
                        if (!app_hotpot.is_file_ext(fh.name, 'dtd')) {
                            app_hotpot.msg('Please select a .dtd file', 'warning');
                            return;
                        }

                        // read the file
                        var p_dtd = fs_read_dtd_file_handle(fh);

                        p_dtd.then((function(){
                            return function(dtd) {
                                // just set the dtd
                                app_hotpot.set_dtd(dtd);
                            }
                        })());
                        
                        // just one file
                        break;
                    }
                });

            } else {
                console.log('* Not support FileSystemAccess API');
            }
            
        },
        
        open_ann_files: function() {
            if (!isFSA_API_OK) {
                console.log('* Not support FileSystemAccess API');
                return;
            }

            // the settings for annotation file
            var pickerOpts = {
                types: [
                    {
                        description: 'Annotation File',
                        accept: {
                            'text/xml': ['.xml', '.txt']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // bind the content
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    if (fh.kind != 'file') {
                        // skip directory or others
                        continue;
                    }

                    // check exists
                    if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
                        // exists? skip this file
                        app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
                        continue;
                    }

                    if (app_hotpot.is_file_ext(fh.name, 'txt')) {
                        // parse this txt file
                        app_hotpot.parse_ann_txt_file_fh(
                            fh,
                            app_hotpot.vpp.$data.dtd
                        );
                        continue;
                    }
                    
                    // parse this ann fh
                    app_hotpot.parse_ann_xml_file_fh(
                        fh,
                        app_hotpot.vpp.$data.dtd
                    );
                }
            });
        },

        update_tag_table: function(tag) {
            // update the display tag
            if (typeof(tag) == 'undefined') {
                // set to all 
                this.display_tag_name = '__all__';

            } else {
                // set to specific tag
                this.display_tag_name = tag.name;
            }

            // need to re-render the code-mirror accordingly
            if (this.is_render_tags_of_all_concepts()) {
                // no need to update marks if render all by default
            } else {
                app_hotpot.cm_update_marks();
            }
        },

        sort_filelist_by: function(sort_by) {
            this.sort_anns_by = sort_by;
        },

        get_sort_by: function() {
            if (this.hasOwnProperty('sort_anns_by')) {
                return this.sort_anns_by;
            } else {
                return 'default';
            }
        },

        get_sort_by_label: function(sort_by) {
            return {
                'default': 'Sort',
                'label': 'Gr-NA',
                'label_r': 'NA-Gr',
                'alphabet': 'A-Z',
                'alphabet_r': 'Z-A',
                'tags': '0-N',
                'tags_r': 'N-0'
            }[sort_by];
        },

        sort_v_anns: function(anns) {
            var sort_by = this.get_sort_by();

            // a virtual list of ann, just contain the file name
            // this is prepared for sorting only
            // because the sort is an in-place sort
            // we can't modify the order in the original anns
            var v_anns = [];
            for (let i = 0; i < anns.length; i++) {
                const ann = anns[i];

                var ann_label = 'zunisha';
                if (this.has_any_label(ann)) {
                    ann_label = ann.meta.label[0].color;
                }
                v_anns.push({
                    // file name
                    _filename: ann._filename,

                    // number of annotated tags
                    n_tags: ann.tags.length,

                    // label color
                    label: ann_label,

                    // the true idx
                    idx: i
                });
            }

            if (sort_by == 'default') {
                return v_anns;

            } else if (sort_by == 'alphabet') {
                v_anns.sort(function(a, b) {
                    return a._filename.localeCompare(
                        b._filename
                    )
                });
                return v_anns;

            } else if (sort_by == 'alphabet_r') {
                v_anns.sort(function(a, b) {
                    return -a._filename.localeCompare(
                        b._filename
                    )
                });
                return v_anns;
                
            } else if (sort_by == 'tags') {
                v_anns.sort(function(a, b) {
                    return a.n_tags - b.n_tags
                });
                return v_anns;

            } else if (sort_by == 'tags_r') {
                v_anns.sort(function(a, b) {
                    return b.n_tags - a.n_tags
                });
                return v_anns;
                
            } else if (sort_by == 'label') {
                // blue
                // green
                // red
                // yellow
                // zunisha
                v_anns.sort(function(a, b) {
                    return a.label.localeCompare(
                        b.label
                    )
                });
                return v_anns;

            } else if (sort_by == 'label_r') {
                v_anns.sort(function(a, b) {
                    return b.label.localeCompare(
                        a.label
                    )
                });
                return v_anns;

            } else {
                return v_anns;
            }
        },

        set_current_ann: function(ann) {
            // replace the ann object
            this.anns[this.ann_idx] = ann;

            // reset the marks and others
            this.set_ann_idx(this.ann_idx);
        },

        set_ann_idx: function(idx) {
            console.log('* set ann_idx', idx);

            // update the ann_idx
            this.ann_idx = idx;

            if (idx == null) {
                // which means remove the content
                app_hotpot.cm_set_ann(null);

                // update the marks
                app_hotpot.cm_update_marks();

            } else {
                // update the text display
                app_hotpot.cm_set_ann(
                    this.anns[this.ann_idx]
                );

                // update the marks
                app_hotpot.cm_update_marks();
            }
        },

        set_ann_idx_by_ann: function(ann) {
            // find the idx
            var idx = this.find_included(
                ann._filename,
                this.anns
            );

            if (idx < 0) {
                // what?? how could it be?
                return;
            } else {
                // ok, we get it
            }

            // finally, just call the set_ann_idx
            this.set_ann_idx(idx);
        },

        show_ann_file: function(fn) {
            // first, find the ann_idx
            var idx = this.fn2idx(fn);

            if (idx < 0) {
                // no such file
                app_hotpot.toast('Not found ' + fn + ' file', 'bg-yellow');
                return;
            }

            // then switch to annotation
            this.switch_mui('annotation');

            // then show the idx
            this.set_ann_idx(idx);

            // trick for cm late update
            this.cm.is_expire = true;
        },

        fn2idx: function(fn) {
            for (let i = 0; i < this.anns.length; i++) {
                if (this.anns[i]._filename == fn) {
                    return i;
                }                
            }
            return -1;
        },

        remove_ann_file_by_ann: function(ann) {
            var idx = this.find_included(
                ann._filename,
                this.anns
            );
            this.remove_ann_file(idx);
        },

        remove_ann_file: function(idx) {
            // delete this first
            this.anns.splice(idx, 1);

            // once the file is removed, update the hint_dict
            // app_hotpot.update_hint_dict_by_anns();

            if (idx == this.ann_idx) {
                this.set_ann_idx(null);
            }

            // need to move the current ann_idx location
            if (idx < this.ann_idx) {
                this.ann_idx -= 1;
            }
        },

        remove_all_ann_files: function(force_remove) {
            if (typeof(force_remove) == 'undefined') {
                force_remove = false;
            }
            if (force_remove) {
                // just remove
                this.set_ann_idx(null);
                this.anns = [];

            } else {
                // ask for user confirm
                var ret = window.confirm('Are you sure to remove all annotation files?');
                if (ret) {
                    this.set_ann_idx(null);
                    this.anns = [];
                }
            }
        },

        on_click_tag_table_row: function(tag) {
            if (!this.is_etag(tag)) {
                // no need to highlight other tag
                return;
            }

            if (this.is_etag_doc_level(tag)) {
                // no need to highlight doc-level tag
                return;
            }

            // in the editor
            // 1. jump to this tag for display
            app_hotpot.cm_jump2tag(
                tag, 
                this.anns[this.ann_idx]
            );
            // 2. highlight the tag
            app_hotpot.highlight_editor_tag(tag.id);

            // in the tag table, highlight
            app_hotpot.highlight_tag_table_row(tag.id);
        },

        on_change_attr_value: function(event) {
            // just mark current ann as unsaved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* changed attr in', event.target);
        },

        on_change_idref_value: function(event) {
            this.anns[this.ann_idx]._has_saved = false;
            // then, need to update this value
            this.on_change_link_settings(event);
        },

        on_input_attr_value: function(event) {
            // just mark current ann as unsaved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* changed input attr to', event.target.value);
        },

        on_change_display_mode: function(event) {
            console.log(event.target.value);
            // need to set ann again,
            // it will display according to the mode
            app_hotpot.cm_set_ann(
                this.anns[this.ann_idx]
            );
            app_hotpot.cm_update_marks();
        },

        on_change_mark_mode: function(event) {
            console.log(event.target.value);
            app_hotpot.cm_update_marks();
        },

        // on_change_hint_mode: function(event) {
        //     console.log(event.target.value);
        //     app_hotpot.cm_update_marks();
        // },
        on_change_hint_mode: function(hint_mode) {
            this.cm.hint_mode = hint_mode;
            app_hotpot.cm_update_marks();
        },

        on_change_link_settings: function(event) {
            console.log(event.target.value);
            // app_hotpot.cm_clear_ltag_marks();

            // have to update all marks ...
            app_hotpot.cm_update_marks();
        },

        accept_all_hints: function() {
            if (this.hints.length == 0) {
                app_hotpot.msg('No hints found');
                return;
            }

            var msg = [
                "There are " + this.hints.length + " hints found and not decided yet in current annotation:\n\n"
            ];
            for (let i = 0; i < this.hints.length; i++) {
                msg.push((i+1) + ' | ' + this.hints[i].tag + ', ' + this.hints[i].spans + ' [' + this.hints[i].text + ']\n');
            }
            msg.push('\nAre you sure to accept all of them?');

            msg = msg.join('');

            var ret = window.confirm(msg);

            if (ret) {
                // check all hints
                for (let i = 0; i < this.hints.length; i++) {
                    const hint_id = this.hints[i].id;
                    this.add_tag_by_hint(hint_id, false);
                }
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();

            } else {
                return;
            }
        },

        get_hint: function(hint_id) {
            for (let i = 0; i < this.hints.length; i++) {
                if (this.hints[i].id == hint_id) {
                    return this.hints[i];
                }
            }
            return null;
        },

        add_tag_by_hint: function(hint_id, update_marks) {
            if (typeof(update_marks)=='undefined') {
                update_marks = true;
            }
            // get the hint from list 
            var hint = this.get_hint(hint_id);
            if (hint == null) { 
                // fix the missing
                app_hotpot.cm_update_marks();
                return; 
            }
            var tag_name = hint.tag;

            // createa new ann tag
            var _tag = {
                'spans': hint.spans,
                'text': hint.text
            }
            var tag_def = this.dtd.tag_dict[tag_name];
            
            // create a new tag
            var tag = app_hotpot.make_etag(
                _tag, 
                tag_def, 
                this.anns[this.ann_idx]
            );

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;
            console.log('* added tag by hint, ' + tag_name + ' on ' + hint.text);

            // update the hint_dict
            app_hotpot.update_hint_dict_by_tag(
                this.anns[this.ann_idx],
                tag
            );

            if (update_marks) {
                // update the cm
                app_hotpot.cm_update_marks();
                // scroll the view
                app_hotpot.scroll_annlist_to_bottom();
            }
        },

        add_nc_etag_by_ctxmenu: function(tag_def) {
            this.add_nc_etag(tag_def);

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_nce.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added nc etag by right click, ' + tag_def.name);
        },

        add_etag_by_ctxmenu: function(tag_def) {
            // get the basic tag
            var _tag = app_hotpot.cm_make_basic_etag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            // for ctxmenu, we need to remove the ctx after click
            app_hotpot.ctxmenu_sel.hide();

            // scroll the view
            app_hotpot.scroll_annlist_to_bottom();

            console.log('* added etag by right click, ' + tag_def.name);
        },

        add_etag_by_shortcut_key: function(key) {
            // first, get selection
            var selection = app_hotpot.cm_get_selection();
            if (selection.sel_txts == '') {
                // nothing selected for tag, skip
                return;
            }

            // then get the tag_def by the given key
            var tag_def = null;
            for (let i = 0; i < this.dtd.etags.length; i++) {
                if (this.dtd.etags[i].shortcut == key) {
                    // found!
                    tag_def = this.dtd.etags[i];
                    break
                }
            }
            if (tag_def == null) {
                // oh, this shortcut is not registered
                return;
            }

            // get a basic tag
            var _tag = app_hotpot.cm_make_basic_etag_from_selection();

            // then call the general add_etag process
            this.add_etag(_tag, tag_def);

            // clear the selection to avoid stick keys
            app_hotpot.cm_clear_selection();

            console.log('* added tag by shortcut, ' + tag_def.name + ' on ' + _tag.text);
        },

        add_etag: function(basic_tag, tag_def) {
            // create a new tag
            var tag = app_hotpot.make_etag(
                basic_tag, 
                tag_def, 
                this.anns[this.ann_idx]
            );

            // add this tag to ann
            this.anns[this.ann_idx].tags.push(tag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // add this new tag to hint_dict
            app_hotpot.update_hint_dict_by_tag(this.anns[this.ann_idx], tag);

            // update the cm
            app_hotpot.cm_update_marks();
        },

        add_nc_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);

            // set to nc 
            etag.spans = dtd_parser.NON_CONSUMING_SPANS;

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        add_empty_etag: function(etag_def) {
            var etag = app_hotpot.make_empty_etag_by_tag_def(etag_def);
            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                etag_def
            );
            etag.id = tag_id;
            
            // add to list
            this.anns[this.ann_idx].tags.push(etag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        add_empty_ltag: function(ltag_def) {
            var ltag = app_hotpot.make_empty_ltag_by_tag_def(ltag_def);

            // create an tag_id
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                ltag_def
            );
            ltag.id = tag_id;

            // add to list
            this.anns[this.ann_idx].tags.push(ltag);

            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // ok, that's all?
        },

        del_tag: function(tag_id) {
            // delete the clicked tag id
            app_hotpot.del_tag(
                tag_id, 
                this.anns[this.ann_idx]
            );
        },

        set_tag_annotator: function(tag_id, annotator, ann) {
            if (typeof(ann) == 'undefined') {
                // just use the current ann
                ann = this.anns[this.ann_idx];
            }
            var tag_idx = -1;
            for (let i = 0; i < ann.tags.length; i++) {
                if (ann.tags[i].id == tag_id) {
                    ann.tags[i]._annotator = annotator;
                    break;
                }            
            }

            // what to do?
            if (tag_idx == -1) {
                // ???
            } else {
                // ???
            }

            // mark this file is changed and needs to be saved
            ann._has_saved = false;

            console.log('* set annotator to tag: ', 
                tag_id + '._annotator = ' + annotator);

            return ann;
        },

        /////////////////////////////////////////////////////////////////
        // Statistics related functions
        /////////////////////////////////////////////////////////////////

        update_hint_dict: function() {
            app_hotpot.update_hint_dict_by_anns();
        },

        download_stat_summary: function() {
            var json = [];

            var stat_items = stat_helper.get_stat_items(
                this.anns,
                this.dtd
            );

            for (let i = 0; i < stat_items.length; i++) {
                const stat_item = stat_items[i];
                json.push({
                    item: stat_item[0],
                    result: stat_item[1]
                });
            }

            // then convert the json to csv
            var csv = Papa.unparse(json, {
            });

            // download this csv
            var blob = new Blob([csv], {type: "text/tsv;charset=utf-8"});
            var fn = this.get_ruleset_base_name() + '-statistics.csv';
            saveAs(blob, fn);
        },

        download_stat_details: function() {
            // create each sheet 
            // sheet 1. the summary
            var ws_summary = stat_helper.get_stat_summary_excelws(
                stat_helper.get_stat_items(
                    this.anns,
                    this.dtd
                )
            );

            // sheet 2. the tags
            var ws_docbtag = stat_helper.get_stat_docs_by_tags_excelws(
                this.anns,
                this.dtd
            );

            // create the wb for download
            var wb = {
                SheetNames: [
                    "Summary",
                    "Documents"
                ],
                Sheets: {
                    Summary: ws_summary,
                    Documents: ws_docbtag
                }
            };
            console.log(wb);

            // decide the file name for this export
            var fn = this.dtd.name + '-annotation-statistics.xlsx';

            // download this wb
            XLSX.writeFile(wb, fn);
        },

        sort_text_dict_in_hint_dict: function(text_dict) {
            var text_info_list = [];
            for (const text in text_dict) {
                if (Object.hasOwnProperty.call(text_dict, text)) {
                    const dict = text_dict[text];
                    text_info_list.push({
                        text: text,
                        // that's what we want to sort
                        count: dict.count
                    });
                }
            }

            // sort desc
            text_info_list.sort(function(a, b) {
                return b.count - a.count;
            });

            return text_info_list;
        },

        reset_stat_filters: function() {
            // reset stat_filter_min_tokens
            this.stat_filter_min_tokens = 0;
        },

        count_texts_by_stat_fileter: function(tag_def) {
            var cnt = 0;
            
            for (const text in this.hint_dict[tag_def.name].text_dict) {
                // count each text
                if (this.stat_filter_min_tokens == 0 || this.hint_dict[tag_def.name].text_dict[text].count <= this.stat_filter_min_tokens) {
                    cnt += 1;
                }
            }
            return cnt;
        },

        on_change_stat_filters: function() {

        },
        
        /////////////////////////////////////////////////////////////////
        // Corpus menu related functions
        /////////////////////////////////////////////////////////////////

        clear_corpus_all: function() {
            this.txt_anns = [];
            this.txt_xmls = [];
        },

        open_txt_files: function() {
            // the settings for raw text file
            var pickerOpts = {
                types: [
                    {
                        description: 'Raw Text File',
                        accept: {
                            'text/txt': ['.txt']
                        }
                    },
                ],
                excludeAcceptAllOption: true,
                multiple: true
            };

            // get the file handles
            var promise_fileHandles = fs_open_files(pickerOpts);

            promise_fileHandles.then(function(fileHandles) {
                // bind the content
                for (let i = 0; i < fileHandles.length; i++) {
                    const fh = fileHandles[i];

                    // check exists
                    if (app_hotpot.vpp.has_included_txt_ann_file(fh.name)) {
                        // exists? skip this file
                        return;
                    }
                    
                    // read the file
                    var p_txt_ann = fs_read_txt_file_handle(
                        fh,
                        app_hotpot.vpp.$data.dtd
                    );
                    p_txt_ann.then(function(txt_ann) {
                        // now check the sentence split
                        // just use the simplest
                        var r = nlp_toolkit.sent_tokenize(
                            txt_ann.text,
                            app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
                        );
                        txt_ann._sentences = r.sentences;
                        txt_ann._sentences_text = r.sentences_text;

                        // add this ann
                        app_hotpot.vpp.add_txt(txt_ann);
                    });
                    
                }
            });
        },

        add_txt: function(txt_ann) {
            // update the dtd name here
            txt_ann.dtd_name = this.dtd.name;
    
            // put this to the list
            this.txt_anns.push(txt_ann);
        },

        add_sample_txt_as_ann: function(text) {

            // first, create an ann
            var ann = ann_parser.txt2ann(text, this.dtd);

            // bind the fh
            ann._fh = null;

            // bind the filename seperately
            ann._filename = 'sample-'+
                (Math.random() + 1).toString(36).substring(7)+
                '.xml';

            // bind a status
            ann._has_saved = true;

            // bind the sentences variable
            ann._sentences = null;
            ann._sentences_text = null;

            // sentencize
            var r = nlp_toolkit.sent_tokenize(
                ann.text,
                app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
            );
            ann._sentences = r.sentences;
            ann._sentences_text = r.sentences_text;

            // add this ann
            app_hotpot.add_ann(ann);
            
            return ann;
        },

        convert_txt_anns_to_xmls: function() {
            // clear the current txt_xmls
            this.txt_xmls = [];

            for (let i = 0; i < this.txt_anns.length; i++) {
                const txt_ann = this.txt_anns[i];
                
                // create new filename
                var fn = txt_ann._filename;

                // get the xml string
                var xml = ann_parser.ann2xml(txt_ann, this.dtd);
                var str = ann_parser.xml2str(xml);

                // create an object for display
                var txt_xml = {
                    fn: fn,
                    text: str
                };

                this.txt_xmls.push(txt_xml);
            }
        },

        get_new_xml_filename: function(fn, ext='.xml') {
            var prefix = this.txt_xml_prefix.trim();
            var suffix = this.txt_xml_suffix.trim();
            var new_fn = fn;

            // add prefix
            if (prefix == '') {
                // nothing to do
            } else {
                new_fn = prefix + '_' + new_fn;
            }

            // add suffix
            if (suffix == '') {
                // nothing to do
                new_fn = new_fn + ext;
            } else {
                new_fn = new_fn + '_' + suffix + ext;
            }

            return new_fn;
        },

        get_new_xmls_zipfile_folder_name: function() {
            var fn = this.dtd.name + '-' + this.txt_anns.length;
            fn = this.get_new_xml_filename(fn, '');
            return fn + '-xmls';
        },

        download_txt_xml: function(txt_ann_idx) {
            var txt_xml = this.txt_xmls[txt_ann_idx];
            var fn = this.get_new_xml_filename(txt_xml.fn);
            var blob = new Blob([txt_xml.text], {type: "text/xml;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_txt_xmls_as_zip: function() {
            // create an empty zip pack
            var zip = new JSZip();
            var folder_name = this.get_new_xmls_zipfile_folder_name();

            // add files to zip pack
            for (let i = 0; i < this.txt_xmls.length; i++) {
                const txt_xml = this.txt_xmls[i];
                var fn = this.get_new_xml_filename(txt_xml.fn);
                var ffn = folder_name + '/' + fn;

                // add to zip
                zip.file(ffn, txt_xml.text);
                
                console.log('* added xml file ' + fn);
            }

            // create zip file
            zip.generateAsync({ type: "blob" }).then(function (content) {
                saveAs(content, app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + '.zip');
            });
        },

        /////////////////////////////////////////////////////////////////
        // IAA Related
        /////////////////////////////////////////////////////////////////
        // see app_hotpot_ext_iaa.js

        /////////////////////////////////////////////////////////////////
        // Ruleset Related
        /////////////////////////////////////////////////////////////////

        get_ruleset_base_name: function() {
            var fn = this.dtd.name + '-' + this.anns.length;
            return fn;
        },

        download_text_tsv: function() {
            var fn = this.get_ruleset_base_name() + '_text.tsv';
            var txt_tsv = nlp_toolkit.download_text_tsv(
                this.anns,
                this.dtd,
                this.hint_dict,
                fn
            );

            // update the text
            this.export_text = txt_tsv;
        },

        download_text_sent_tsv: function() {
            var fn = this.get_ruleset_base_name() + '_text_sentence.tsv';
            
            // convert the hint dict to a json obj
            var json = [];

            for (let i = 0; i < this.anns.length; i++) {
                const ann = this.anns[i];
                for (let j = 0; j < ann.tags.length; j++) {
                    const tag = ann.tags[j];
                    // now mapping the span to token index
                    if (!tag.hasOwnProperty('spans')) {
                        // this is not an entity tag
                        continue;
                    }
                    // there maybe multiple spans
                    // var spans = tag.spans.split(',');
                    var locs = ann_parser.spans2locs(tag.spans);

                    for (let k = 0; k < locs.length; k++) {
                        // const _span = spans[k];
                        // const span = nlp_toolkit.txt2span(_span);
                        const span = locs[k];
                        if (span[0] == -1 || span[1] == -1) {
                            // which means this tag is just a non-consuming tag
                            // at present, we won't use this kind of tag 
                            continue;
                        }

                        // find the offset in a sentence
                        var loc0 = nlp_toolkit.find_linech(
                            span[0], 
                            ann._sentences
                        );
                        if (loc0 == null) {
                            // something wrong?
                            continue;
                        }
                        // find the location for the right part
                        // var loc1 = this.find_linech(span[1], ann._sentences);
                        var loc1 = Object.assign({}, loc0);
                        loc1.ch += (span[1] - span[0]);

                        // create a new row/item in the output data
                        json.push({
                            concept: tag.tag,
                            text: tag.text,
                            doc_span: span,
                            sen_span: [
                                loc0.ch,
                                loc1.ch
                            ],
                            document: ann._filename,
                            sentence: ann._sentences[loc0.line].text
                        });
                    }
                }
            }

            // then convert the json to csv
            var csv = Papa.unparse(json, {
                delimiter: '\t'
            });

            // update the text
            this.export_text = csv;

            // download this csv
            var blob = new Blob([csv], {type: "text/tsv;charset=utf-8"});
            saveAs(blob, fn);
        },

        download_dataset_iob2: function() {
            var txt_dataset = nlp_toolkit.download_dataset_bio(
                this.anns,
                this.dtd,
                'dataset-' + this.get_ruleset_base_name() + '-BIO.zip'
            );

            // update the text
            this.export_text = txt_dataset;
        },

        download_dataset_bioc: function() {
            var txt_dataset = bioc_parser.download_dataset_bioc(
                this.anns,
                this.dtd,
                'dataset-' + this.get_ruleset_base_name() + '-BioC.xml'
            );

            // update the text
            this.export_text = txt_dataset;
        },

        download_ruleset_medtagger_zip: function() {
            var rulepack = erp_toolkit.download_anns_as_zip(
                this.anns,
                this.dtd,
                'ruleset-medtagger-' + this.get_ruleset_base_name() + '.zip'
            );

            // update the text
            this.export_text = "Please unzip the file and check details";
        },

        download_ruleset_spacy_jsonl: function() {
            var text = spacy_toolkit.download_anns_as_jsonl(
                this.anns,
                this.dtd,
                'ruleset-spacy-' + this.get_ruleset_base_name() + '.jsonl'
            );

            // update the text
            this.export_text = text;
        },

        /////////////////////////////////////////////////////////////////
        // Menu Related
        /////////////////////////////////////////////////////////////////
        get_nc_etags: function() {
            var nc_etags = [];
            // no dtd yet?
            if (this.dtd == null) { return []; }
            // no file selected yet?
            if (this.ann_idx == null) { return []; }
            for (let i = 0; i < this.dtd.etags.length; i++) {
                const etag = this.dtd.etags[i];
                if (etag.is_non_consuming) {
                    nc_etags.push(etag);
                }
            }
            return nc_etags;
        },

        switch_mui: function(section) {
            console.log('* switch to section', section);
            this.section = section;

            if (section == 'annotation') {
                // refresh the code mirror
                this.set_ann_idx(this.ann_idx);

                // trick for cm late update
                this.cm.is_expire = true;
            }

            app_hotpot.resize();
        },

        close_ctxmenu: function() {
            app_hotpot.ctxmenu_sel.hide();
            app_hotpot.ctxmenu_nce.hide();
        },

        close_popmenu: function() {
            app_hotpot.popmenu_tag.hide();
        },

        on_click_editor_tag: function(event, tag_id) {
            // console.log('* clicked on editor etag', tag_id);

            // set the clicked tag_id
            this.clicked_tag_id = tag_id;

            // get the position of user pointer
            // var mouseX = event.clientX;
            // var mouseY = event.clientY;

            // get the position of the tag it self
            var elm = $(event.target);
            var x = elm.offset().left;
            var y = elm.offset().top;

            // then show the popmenu
            app_hotpot.show_tag_popmenu_at(x, y);

            // then show the item in the list
            app_hotpot.scroll_tag_table_to(tag_id);

            // then highlight this item in table
            app_hotpot.highlight_tag_table_row(tag_id);

            // then highlight this item in editor
            app_hotpot.highlight_editor_tag(tag_id);
        },

        on_enter_tag: function(event) {
            // console.log('* enter etag', event.target);
            var elm = $(event.target);
            var tag_id = elm.attr('tag_id');
            this.hovered_tag = this.get_tag_by_tag_id(
                tag_id,
                this.anns[this.ann_idx]
            );

            // set location
            $('#hoverbox_etag').css('top', elm.offset().top + 20);
            $('#hoverbox_etag').css('left', elm.offset().left);
        },

        on_leave_tag: function(event) {
            // console.log('* leave etag', event.target);
            this.hovered_tag = null;
        },

        popmenu_del_tag: function() {
            // delete the clicked tag id
            app_hotpot.del_tag(
                this.clicked_tag_id, this.anns[this.ann_idx]
            );

            // hide the menu 
            app_hotpot.popmenu_tag.hide();

            // reset the clicked tag id
            this.clicked_tag_id = null;
        },

        popmenu_start_linking: function(ltag_def) {
            // first, set the working mode
            this.is_linking = true;

            // set the linking tag_def
            this.linking_tag_def = ltag_def;

            // create a ltag
            this.linking_tag = app_hotpot.make_empty_ltag_by_tag_def(ltag_def);

            // then get the linking atts for this ltag
            // this list contains all atts for this ltag
            // and during the linking, we will remove those linked att out
            this.linking_atts = this.get_idref_attlists(ltag_def);

            // let's set the first idref attlist
            // pop the first att from atts
            var att = this.linking_atts[0];
            this.linking_atts.splice(0, 1)
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            // maybe we could show a float panel
            // for showing the current annotation
            console.log('* start linking', ltag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );
        },

        popmenu_set_linking: function(att_idx) {
            // pop the target idx att from atts
            var att = this.linking_atts[att_idx];
            this.linking_atts.splice(att_idx, 1);

            // set current tag to this att
            this.linking_tag[att.name] = this.clicked_tag_id;
            
            console.log('* set linking', this.linking_tag_def.name, 
                'on attr [', att.name,
                '] =', this.clicked_tag_id
            );

            // final check the left?
            if (this.linking_atts.length == 0) {
                // which means we have tagged all idrefs
                // we could append this linking tag to ann
                var tag_id = ann_parser.get_next_tag_id(
                    this.anns[this.ann_idx],
                    this.linking_tag_def
                );
                this.linking_tag.id = tag_id;
                this.anns[this.ann_idx].tags.push(this.linking_tag);
                // mark _has_saved
                this.anns[this.ann_idx]._has_saved = false;

                // then, we could show this new link in cm
                app_hotpot.cm_draw_ltag(
                    this.linking_tag,
                    this.linking_tag_def,
                    this.anns[this.ann_idx]
                );

                // we could reset linking status
                this.cancel_linking();

            } else {
                // not finished yet?
                // keep working on it
            }
        },

        done_linking: function() {
            // no matter what decision, just done this linking,
            // we could append this linking tag to ann
            var tag_id = ann_parser.get_next_tag_id(
                this.anns[this.ann_idx],
                this.linking_tag_def
            );
            this.linking_tag.id = tag_id;
            this.anns[this.ann_idx].tags.push(this.linking_tag);
            // mark _has_saved
            this.anns[this.ann_idx]._has_saved = false;

            // then, we could show this new link in cm
            app_hotpot.cm_draw_ltag(
                this.linking_tag,
                this.linking_tag_def,
                this.anns[this.ann_idx]
            );

            // we could reset linking status
            this.cancel_linking();
        },

        cancel_linking: function() {
            // so, user doesn't want to continue current linking
            this.is_linking = false;
            this.linking_tag_def = null;
            this.linking_tag = null;
            this.linking_atts = [];
        },

        dragMouseDown: function(event) {
            console.log('* drag start', event);
            event.preventDefault()
            // get the mouse cursor position at startup:
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            document.onmousemove = this.elementDrag
            document.onmouseup = this.closeDragElement
        },
        elementDrag: function (event) {
            event.preventDefault()
            this.pan_working_tag.pos.movementX = this.pan_working_tag.pos.clientX - event.clientX
            this.pan_working_tag.pos.movementY = this.pan_working_tag.pos.clientY - event.clientY
            this.pan_working_tag.pos.clientX = event.clientX
            this.pan_working_tag.pos.clientY = event.clientY
            // set the element's new position:
            this.$refs.pan_working_tag_box.style.top = (this.$refs.pan_working_tag_box.offsetTop - this.pan_working_tag.pos.movementY) + 'px'
            this.$refs.pan_working_tag_box.style.left = (this.$refs.pan_working_tag_box.offsetLeft - this.pan_working_tag.pos.movementX) + 'px'
        },
        closeDragElement () {
            document.onmouseup = null
            document.onmousemove = null
        },

        /////////////////////////////////////////////////////////////////
        // Other utils
        /////////////////////////////////////////////////////////////////
        make_html_bold_tag_name: function(tag) {
            var html = '<span class="tag-list-row-name-id-prefix">' + tag.id_prefix + '</span>';
            var name = tag.name;
            name = name.replace(tag.id_prefix, '');
            html = html += name;
            return html;
        },

        count_n_tags: function(tag) {
            if (this.ann_idx == null) {
                return '';
            }
            var cnt = 0;
            if (tag == null) {
                return this.anns[this.ann_idx].tags.length;
            }
            for (let i = 0; i < this.anns[this.ann_idx].tags.length; i++) {
                if (this.anns[this.ann_idx].tags[i].tag == tag.name) {
                    cnt += 1;
                }
            }
            return cnt;
        },

        is_current_ann: function(ann) {
            if (this.ann_idx == null) {
                // which means there is no ann displayed now
                return false;
            }
            if (ann._filename == this.anns[this.ann_idx]._filename) {
                return true;
            } else {
                return false;
            }
        },

        is_match_filename: function(fn) {
            let p = this.fn_pattern.trim();
            if (p == '') {
                return true;
            }
            if (fn.lastIndexOf(p) >= 0) {
                return true;
            } else {
                return false;
            }
        },

        find_included: function(fn, anns) {
            for (let i = 0; i < anns.length; i++) {
                if (anns[i]._filename == fn) {
                    return i;
                }
            }

            return -1;
        },

        has_included: function(fn, anns) {
            for (let i = 0; i < anns.length; i++) {
                if (anns[i]._filename == fn) {
                    return true;
                }
            }

            return false;
        },

        has_included_ann_file: function(fn) {
            return this.has_included(fn, this.anns);
        },

        get_new_ann_fn_by_txt_fn: function(txt_fn) {
            var new_fn = txt_fn + '.xml';
            var i = 1;
            while (true) {
                if (this.has_included_ann_file(new_fn)) {
                    new_fn = txt_fn + '_' + i + '.xml';
                    i += 1;
                } else {
                    break;
                }
            }
            return new_fn;
        },

        has_included_txt_ann_file: function(fn) {
            return this.has_included(fn, this.txt_anns);
        },

        has_unsaved_ann_file: function() {
            for (let i = 0; i < this.anns.length; i++) {
                const ann = this.anns[i];
                if (ann._has_saved) {

                } else {
                    return true;
                }
            }
            return false;
        },

        get_tag_spans_text: function(tag) {
            if (tag.spans == '-1~-1') {
                return 'DOCLEVEL';
            } else {
                return tag.spans;
            }
        },

        get_tags_by_tag_name: function(ann, tag_name) {
            var tags = [];
            for (let i = 0; i < ann.tags.length; i++) {
                const tag = ann.tags[i];
                if (tag.tag == tag_name) {
                    tags.push(tag);
                }
            }
            return tags;
        },

        get_tags_by_type: function(ann, dtd) {
            if (typeof(type) == 'undefined') {
                type = 'etag';
            }
            var tags = [];
            for (let i = 0; i < ann.tags.length; i++) {
                const tag = ann.tags[i];
                if (dtd.tag_dict[tag.tag].type==type) {
                    tags.push(tag);
                }
            }
            return tags;
        },

        get_tag_desc_html: function(tag) {
            var html = [];

            for (const attr in tag) {
                if (Object.hasOwnProperty.call(tag, attr)) {
                    const val = tag[attr];
                    if (['id', 'tag', 'spans', 'text', '_annotator'].indexOf(attr)>=0) {
                        continue;
                    }

                    html.push(
                        "<span class='tag-desc-item'>" +
                        "<span class='tag-desc-attr'>" + attr + ": </span>" +
                        "<span class='tag-desc-value'>" + val + "</span>" +
                        "</span>"
                    );
                }
            }

            html = html.join('<br>');

            return html;
        },

        get_clicked_tag: function() {
            if (this.clicked_tag_id == null) {
                return null;
            }
            if (this.ann_idx == null) {
                return null;
            }
            return this.get_tag_by_tag_id(
                this.clicked_tag_id, 
                this.anns[this.ann_idx]
            )
        },

        get_tag_by_tag_id: function(tag_id, ann) {
            if (ann == null) {
                return null;
            }
            for (let i = 0; i < ann.tags.length; i++) {
                if (ann.tags[i].id == tag_id) {
                    return ann.tags[i];
                }                
            }
            return null;
        },

        get_tag_def: function(tag_name) {
            if (this.dtd.tag_dict.hasOwnProperty(tag_name)) {
                return this.dtd.tag_dict[tag_name];
            } else {
                return null;
            }
        },

        get_idref_attlist_by_seq: function(ltag_def, seq=0) {
            var cnt = -1;
            for (let i = 0; i < ltag_def.attlists.length; i++) {
                if (ltag_def.attlists[i].vtype == 'idref') {
                    cnt += 1;
                    if (cnt == seq) {
                        // great! we get the attlist we want
                        return ltag_def.attlists[i];
                    }
                }
            }
            return null;
        },

        get_idref_attlists: function(ltag_def) {
            var attlists = [];
            for (let i = 0; i < ltag_def.attlists.length; i++) {
                const att = ltag_def.attlists[i];
                if (att.vtype == 'idref') {
                    attlists.push(att);
                }
            }
            return attlists;
        },

        to_fixed: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null || 
                isNaN(v)) {
                return 'NA';
            }
            return v.toFixed(2);
        },

        val2width: function(val, max_val, max_width) {
            if (typeof(val) == 'undefined' ||
                val == null ||
                isNaN(val)) {
                val = 0;
            }
            if (typeof(max_val) == 'undefined' ||
                max_val < 10) {
                max_val = 10;
            }
            if (typeof(max_width) == 'undefined') {
                // which means 100px
                max_width = 100;
            }

            // very simple conversion
            var width = val / max_val * max_width;

            return width;
        },

        per2width: function(v) {
            if (typeof(v) == 'undefined' ||
                v == null ||
                isNaN(v)) {
                return 1;
            }
            return v * 100;
        },

        has_doc_sum_selected_tags: function() {
            if (this.has_included_ann_file(
                this.display_stat_doc_sum_selected.file_name
            )) {
                return true;
            }
            return false;
        },

        on_click_stat_ann_tag: function(file_name, tag_name) {
            this.display_stat_doc_sum_selected = {
                file_name: file_name,
                tag_name: tag_name
            };

            console.log('* display_stat_doc_sum_selected:', this.display_stat_doc_sum_selected);
        },

        has_FSA_API: function() {
            return isFSA_API_OK;
        },

        show_help: function(token) {
            if (typeof(token) == 'undefined') {
                // ?
                return;
            }

            // find this token
            if (this.texts.hasOwnProperty(token)) {
                var html_content = '';

                // add the title
                html_content += 
                    "<h4>" + 
                    this.texts[token].title + 
                    "</h4>";
                
                // add the content
                html_content += this.texts[token].html;

                // show the html content
                Metro.infobox.create(html_content);

            } else {
                // ???
            }
        },

        is_display_tag_name: function(tag_name) {
            if (this.display_tag_name == '__all__') {
                return true;
            }

            if (this.display_tag_name == tag_name) {
                return true;
            }

            return false;
        },

        /**
         * Render all tags of all concepts or not
         * 
         * The UI workflow could be changed by the setting
         * `cfg.linking_marks_selection`.
         * 
         * @returns true/false
         */
        is_render_tags_of_all_concepts: function() {
            return this.cfg.linking_marks_selection == 'all_concepts';
        },

        /**
         * Check if a tag is related to a certain tag type
         * 
         * @param {object} tag a tag object
         * @param {list} tag_name tag names to be checked
         * @param {object} ann annotation
         */
        is_tag_related_to_tag_name: function(tag, tag_names, ann) {
            // find the 
            var related_tags = ann_parser.get_linked_ltags(
                tag.id,
                ann
            );

            // check each related tag, which is usually a link tag
            for (let i = 0; i < related_tags.length; i++) {
                const related_tag = related_tags[i];
                if (tag_names.indexOf(related_tag.tag)>=0) {
                    return true;
                }
            }

            return false;
        },

        is_etag_doc_level: function(tag) {
            if (tag.spans == '-1~-1') {
                return true;
            }
            return false;
        },
        
        is_etag: function(tag) {
            if (tag.hasOwnProperty('spans')) {
                return true;
            }
            return false;
        },

        stat_value2width: function(value, max_value) {
            return this.val2width(value, max_value);
        },

        stat_value2bgcolor: function(value, max_value, zero_color) {
            if (typeof(max_value)=='undefined') {
                max_value = 10;
            }
            if (typeof(zero_color)=='undefined') {
                zero_color = '#ffffff';
            }
            if (value == 0) {
                return zero_color;
            } else {
                return d3.rgb(
                    d3.interpolateReds(value / max_value)
                ).formatHex() + '';
            }
        },

        stat_value2ftcolor: function(value, max_value, zero_color) {
            if (typeof(max_value)=='undefined') {
                max_value = 10;
            }
            if (typeof(zero_color)=='undefined') {
                zero_color = '#eeeeee';
            }
            if (value == 0) {
                return zero_color;
            } else {
                if (value / max_value < 0.6) {
                    return '#000000';
                } else {
                    return '#ffffff';
                }
            }
        },

        get_date_now: function() {
            return dayjs().format('YYYY-MM-DD');
        },

        get_datetime_now: function() {
            return dayjs().format('YYYY-MM-DD_HH.mm.ss');
        }
    },

    // code mirror instance
    codemirror: null,
    // marked texts in code mirror
    marktexts: [],
    // the selected text
    selection: null,

    // the context menu for selection
    ctxmenu_sel: null,

    // the context menu for nc etags
    ctxmenu_nce: null,

    // the popup menu for tag
    popmenu_tag: null,

    init: function() {
        this.vpp = new Vue({
            el: this.vpp_id,
            data: this.vpp_data,
            methods: this.vpp_methods,

            mounted: function() {
                Metro.init();
            },

            computed: {
                stat_docs_by_tags: function() {
                    return stat_helper.get_stat_docs_by_tags_json(
                        this.anns,
                        this.dtd
                    );
                },

                stat_summary: function() {
                    return stat_helper.get_stat_items(
                        this.anns,
                        this.dtd
                    );
                },

                stat_doc_sum_selected_tags: function() {
                    // find this ann
                    var ann_idx = this.find_included(
                        this.display_stat_doc_sum_selected.file_name,
                        this.anns
                    );

                    // find the tags
                    var tags = this.get_tags_by_tag_name(
                        this.anns[ann_idx],
                        this.display_stat_doc_sum_selected.tag_name
                    );

                    // last is just update tags
                    return tags;
                }
            },

            updated: function() {
                this.$nextTick(function () {
                    // Code that will run only after the
                    // entire view has been re-rendered
                    if (this.section == 'annotation') {
                        if (this.cm.is_expire) {
                            this.set_ann_idx(this.ann_idx);
                            this.cm.is_expire = false;
                        }
                    }
                });
            }
        });

        // the code mirror
        this.init_codemirror();

        // the global event
        this.bind_events();

        // set the resize
        this.resize();
    },

    init_codemirror: function() {
        // init the code mirror instance
        this.codemirror = CodeMirror(
            document.getElementById('cm_editor'), {
                lineNumbers: true,
                lineWrapping: true,
                readOnly: true,
                // readOnly: 'nocursor',
                // styleActiveLine: true,
                extraKeys: {"Alt-F": "find"}
            }
        );

        this.codemirror.on('contextmenu', function(inst, evt) {
            evt.preventDefault();

            // update the selection texts
            var selection = app_hotpot.cm_get_selection(inst);
            if (selection.sel_txts == '') {
                // if there is/are non-consuming tags
                // which makes it a document-level annotation
                // show the menu here
                if (app_hotpot.vpp.get_nc_etags().length>0) {
                    // show
                    var mouseX = evt.clientX;
                    var mouseY = evt.clientY;
                    app_hotpot.show_nce_ctxmenu(mouseX, mouseY);
                    return;

                } else {
                    // nothing selected and there is no NC etag
                    return;
                }

            }
            // show the menu
            var mouseX = evt.clientX;
            var mouseY = evt.clientY;
            app_hotpot.show_tag_ctxmenu(mouseX, mouseY);
        });
    },

    /**
     * Set the DTD for this annotation project
     * 
     * @param {Object} dtd An object of dtd
     */
    set_dtd: function(dtd) {
        console.log('* set dtd', dtd);
        this.vpp.$data.dtd = dtd;

        // update the color define
        this.update_tag_styles();

        // update the shortcuts
        this.update_tag_shortcuts();

        // update the context menu
        this.update_tag_ctxmenu();

        // update the context menu
        this.update_nce_ctxmenu();

        // update the pop menu
        this.update_tag_popmenu();

        // force update
        this.vpp.$forceUpdate();
    },

    clear_ann_all: function() {
        this.txt_anns = [];
        this.txt_xmls = [];

        this.anns = [];
        this.ann_idx = null;

        this.hint_dict = {};
    },

    reset_vpp: function() {
        this.dtd = null;
        this.clear_ann_all();
        this.clear_iaa_all();
    },

    add_ann: function(ann, is_switch_to_this_ann) {
        // check the schema first
        if (ann.dtd_name != this.vpp.$data.dtd.name) {
            console.log('* skip unmatched ann', ann);
            app_hotpot.msg('Skipped unmatched file ' + ann._filename, 'warning');
            return;
        }

        this.vpp.$data.anns.push(ann);

        // update hint_dict when add new ann file
        this.update_hint_dict_by_anns();

        if (is_switch_to_this_ann || this.vpp.$data.anns.length == 1) {
            this.vpp.$data.ann_idx = this.vpp.$data.anns.length - 1;

            // update the text display
            this.cm_set_ann(
                this.vpp.$data.anns[this.vpp.$data.ann_idx]
            );
    
            // update the marks
            this.cm_update_marks();
        }
        console.log("* added ann", ann);
    },

    /////////////////////////////////////////////////////////////////
    // Events related
    /////////////////////////////////////////////////////////////////

    bind_events: function() {
        // bind drop zone for dtd
        this.bind_dropzone_dtd();

        // bind drop zone for annotation xml/txt files
        this.bind_dropzone_ann();

        // bind drop zone for batch import text file
        // this.bind_dropzone_txt();

        // bind drop zone for converter
        this.bind_dropzone_converter_medtagger_txt();
        this.bind_dropzone_converter_medtagger_ann();

        // bind drop zone for anns
        this.bind_dropzone_iaa();

        // bind global click event
        this.bind_click_event();

        // bind global key event
        this.bind_keypress_event();

        // bind the closing event
        this.bind_unload_event();
    },

    bind_click_event: function() {
        document.getElementById('app_hotpot').addEventListener(
            "click",
            function(event) {
                // console.log('* clicked on', event.target);

                var dom = event.target;
                var obj = $(dom);

                if (obj.hasClass('mark-tag') ||
                    obj.hasClass('mark-tag-text')) {
                    // which means clicks on a tag.
                    // so don't touch the popmenu
                } else {
                    // 
                    if (app_hotpot.popmenu_tag != null) {
                        app_hotpot.popmenu_tag.hide();
                    }
                }

                // show the menu
                // var mouseX = event.clientX;
                // var mouseY = event.clientY;

                // close the right click menu
                if (app_hotpot.ctxmenu_sel != null) {
                    app_hotpot.ctxmenu_sel.hide();
                }
                if (app_hotpot.ctxmenu_nce != null) {
                    app_hotpot.ctxmenu_nce.hide();
                }

                // if (obj.hasClass('mark-tag-text')) {
                //     // this is a mark in code mirror
                //     var tag_id = dom.getAttribute('tag_id');

                //     // set the clicked tag_id
                //     app_hotpot.vpp.$data.clicked_tag_id = tag_id;

                //     // show the menu
                //     app_hotpot.show_tag_popmenu_at(mouseX, mouseY);
                // } else {
                //     // what to do?
                // }
            }
        );
    },

    bind_keypress_event: function() {
        document.addEventListener(
            "keypress",
            function(event) {
                // console.log('* pressed on', event);

                // first, check if there is any selection
                app_hotpot.vpp.add_etag_by_shortcut_key(
                    event.key.toLocaleLowerCase()
                );
            }
        );
    },

    bind_unload_event: function() {
        window.addEventListener('beforeunload', function (event) {
            if (app_hotpot.vpp.has_unsaved_ann_file()) {
                event.preventDefault();
                var msg = 'There are unsaved annotation files, are you sure to leave them unsaved?';
                event.returnValue = msg;
                return msg;
            }
        });
    },

    bind_dropzone_dtd: function() {
        let dropzone = document.getElementById("dropzone_dtd");

        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener("drop", function(event) {
            // prevent the default download event
            event.preventDefault();
            let items = event.dataTransfer.items;
        
            // user should only upload one folder or a file
            if (items.length>1) {
                console.log('* selected more than 1 item!');
                app_hotpot.msg('Please just drop only one .dtd file', 'warning');
                return;
            }
            // console.log('* found dropped items', items);

            if (isFSA_API_OK) {
                // use FSA API to access
                let item = items[0].getAsFileSystemHandle();
                console.log('* using FSA API to load item as dtd');

                // read this handle
                item.then(function(fh) {
                    if (fh.kind != 'file') { return null; }

                    if (!app_hotpot.is_file_ext(fh.name, 'dtd')) {
                        app_hotpot.msg('Please drop a .dtd file', 'warning');
                        return;
                    }

                    // get the text content
                    var p_dtd = fs_read_dtd_file_handle(fh);

                    // handle the response
                    // we just create a function agent
                    // for support other parameters in future if possible
                    p_dtd.then((function(){
                        return function(dtd) {
                            // just set the dtd
                            app_hotpot.set_dtd(dtd);
                        }
                    })());
                });

            } else {
                // if there is not FSA_API, just use default API
                let item = items[0].webkitGetAsEntry();
                console.log('* using webkit Entry API to load item as dtd', item);
        
                if (item) {
                    // ok, user select a folder ???
                    if (item.isDirectory) {
                        // show something?

                    } else {
                        // should be a dtd file
                        console.log('* dropped a dtd file', item);

                        // so item is a fileEntry
                        app_hotpot.parse_dtd_file_entry(item);
                    }
                } else {
                    console.log('* something wrong with dtd item', item);
                }
            }

            // for (let i=0; i<items.length; i++) {
            //     let item = items[i].webkitGetAsEntry();
        
            //     if (item) {
            //         // ok, user select a folder ???
            //         if (item.isDirectory) {
            //             // show something?

            //         } else {
            //             // should be a dtd file
            //             // so item is a fileEntry
            //             app_hotpot.parse_dtd_file_entry(item);
            //         }
            //     }

            //     // just detect one item, folder or zip
            //     break;
            // }

        }, false);
    },

    bind_dropzone_ann: function() {
        // bind basic dropzone in the top
        let dropzone = document.getElementById("dropzone_ann");
        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener(
            "drop", 
            app_hotpot.on_drop_dropzone_ann, 
            false
        );

        // bind second dropzone
        let filelist_dropzone = document.getElementById('mui_filelist');
        filelist_dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        filelist_dropzone.addEventListener(
            "drop", 
            app_hotpot.on_drop_dropzone_ann, 
            false
        );
    },

    on_drop_dropzone_ann: function(event) {
        // prevent the default download event
        event.preventDefault();
        
        if (event.srcElement.nodeName.toLocaleUpperCase() != 'DIV') {
            return;
        }

        let items = event.dataTransfer.items;
        for (let i=0; i<items.length; i++) {
            if (isFSA_API_OK) {
                // get this item as a FileSystemHandle Object
                // this could be used for saving the content back
                // let item = items[i].webkitGetAsEntry();
                let item = items[i].getAsFileSystemHandle();

                // read this handle
                item.then(function(fh) {
                    if (fh.kind == 'file') {
                        app_hotpot.parse_ann_file_fh(
                            fh, 
                            app_hotpot.vpp.$data.dtd
                        );

                        // // show something if this file exists
                        // // check if this file name exists
                        // if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
                        //     // exists? skip this file
                        //     app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
                        //     return;
                        // }

                        // // if drop a txt!
                        // if (app_hotpot.is_file_ext(fh.name, 'txt')) {
                        //     // parse this txt file
                        //     app_hotpot.parse_ann_txt_file_fh(
                        //         fh,
                        //         app_hotpot.vpp.$data.dtd
                        //     );
                        //     return;
                        // }

                        // // should be a ann txt/xml file
                        // app_hotpot.parse_ann_xml_file_fh(
                        //     fh,
                        //     app_hotpot.vpp.$data.dtd
                        // );

                    } else {
                        // so item is a directory?
                        // console.log(fh);
                        
                        fs_read_ann_dir_handle(
                            fh, 
                            app_hotpot.vpp.$data.dtd
                        );

                        // p_ents.then(function(ents) {
                        //     console.log('* ents:', ents);
                        //     // ents.forEach(function(item, index, array) {
                        //     //     console.log(item, index)
                        //     //   });
                        //     for (let i = 0; i < ents.length; i++) {
                        //         const ent = ents[i];
                        //         console.log(i, ent);
                        //     }
                        // });
                    }
                });
            } else {
                // just load the file 
                let item = items[i].webkitGetAsEntry();
                console.log(item);
                if (item) {
                    // ok, user select a folder ???
                    if (item.isDirectory) {
                        // show something?

                    } else {
                        // so item is a fileEntry
                        app_hotpot.parse_ann_file_entry(item);
                    }
                }
            }
            
            
        }

    },

    bind_dropzone_txt: function() {
        let dropzone = document.getElementById("dropzone_txt");

        dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        dropzone.addEventListener("drop", function(event) {
            let items = event.dataTransfer.items;
            // stop the download event
            event.preventDefault();

            for (let i=0; i<items.length; i++) {
                // let item = items[i].webkitGetAsEntry();
                let item = items[i].getAsFileSystemHandle();
        
                item.then(function(fh) {
                    if (fh.kind == 'file') {
                        // check exists
                        if (app_hotpot.vpp.has_included_txt_ann_file(fh.name)) {
                            // exists? skip this file
                            return;
                        }

                        // read the file
                        var p_txt_ann = fs_read_txt_file_handle(
                            fh,
                            app_hotpot.vpp.$data.dtd
                        );
                        p_txt_ann.then(function(txt_ann) {
                            // split the sentence
                            // just use the simplest
                            var r = nlp_toolkit.sent_tokenize(
                                txt_ann.text,
                                app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
                            );
                            txt_ann._sentences = r.sentences;
                            txt_ann._sentences_text = r.sentences_text;
                            
                            app_hotpot.vpp.add_txt(txt_ann);
                        });
                        
                    } else {
                        // what to do with a directory
                    }
                })
                .catch(function(error) {
                    console.log('* error when drop txt', error);
                });
            }

        }, false);
    },

    resize: function() {
        var h = $(window).height();
        $('.main-ui').css('height', h - 145);

        // due the svg issue, when resizing the window,
        // redraw all ltag marks
        this.cm_clear_ltag_marks();

        // redraw all marks
        this.cm_update_tag_marks();
    },

    parse_dtd_file_entry: function(fileEntry) {
        app_hotpot.read_file_async(fileEntry, function(evt) {
            var text = evt.target.result;
            // console.log('* read dtd', text);

            // try to parse this dtd file
            var dtd = dtd_parser.parse(text);
            
            // ok, set the dtd for annotator
            app_hotpot.set_dtd(dtd);
        });
    },

    parse_ann_file_entry: function(fileEntry) {
        // first, decide type
        if (app_hotpot.is_file_ext(fileEntry.name, 'txt')) {
            // so, just read this file and get the content
            // to create new file name
            var new_fn = app_hotpot.vpp.get_new_ann_fn_by_txt_fn(fileEntry.name);

            app_hotpot.read_file_async(fileEntry, (function(new_fn){
                return function(evt) {
                    var text = evt.target.result;
    
                    // try to parse this txt file
                    var ann = ann_parser.txt2ann(
                        text, 
                        app_hotpot.vpp.$data.dtd
                    );

                    // post processing
                    ann._fh = null;
                    ann._filename = new_fn;
                    ann._has_saved = true;
                    var result = nlp_toolkit.sent_tokenize(ann.text);
                    ann._sentences = result.sentences;
                    ann._sentences_text = result.sentences_text;

                    // show some message
                    app_hotpot.msg("Created a new annotation file " + new_fn);
                    
                    // ok, add this the dtd for annotator
                    app_hotpot.add_ann(ann);
                }
            })(new_fn));

        } else if (app_hotpot.is_file_ext(fileEntry.name, 'xml')) {
            // ok, this is an xml file, usually it's what we want
            // check existance first
            if (app_hotpot.vpp.has_included_ann_file(fileEntry.name)) {
                // exists? skip this file
                app_hotpot.msg('Skipped same name or duplicated ' + fileEntry.name);
                return;
            }

            // then create 
            var new_fn = fileEntry.name;
            app_hotpot.read_file_async(fileEntry, (function(new_fn){
                return function(evt) {
                    var xml = evt.target.result;
    
                    // try to parse this xml file
                    var ann = ann_parser.xml2ann(
                        xml, 
                        app_hotpot.vpp.$data.dtd
                    );

                    // post processing
                    // we don't have fh due to using fileEntry
                    ann._fh = null;
                    ann._filename = new_fn;
                    ann._has_saved = true;
                    var result = nlp_toolkit.sent_tokenize(ann.text);
                    ann._sentences = result.sentences;
                    ann._sentences_text = result.sentences_text;
                    
                    // ok, add this the dtd for annotator
                    app_hotpot.add_ann(ann);
                }
            })(new_fn));
            
        } else {
            // what???
            app_hotpot.msg('Skipped unknown format file ' + fileEntry.name);
            return;
        }
    },

    read_file_async: function(fileEntry, callback) {
        fileEntry.file(function(file) {
            let reader = new FileReader();
            reader.onload = callback;
            reader.readAsText(file)
        });
    },

    parse_ann_file_fh: function(fh, dtd) {
        // show something if this file exists
        // check if this file name exists
        if (app_hotpot.vpp.has_included_ann_file(fh.name)) {
            // exists? skip this file
            app_hotpot.msg('Skipped same name or duplicated ' + fh.name);
            return;
        }

        // if drop a txt!
        if (app_hotpot.is_file_ext(fh.name, 'txt')) {
            // parse this txt file
            app_hotpot.parse_ann_txt_file_fh(
                fh,
                dtd
            );
            return;
        }

        // should be a ann txt/xml file
        if (app_hotpot.is_file_ext(fh.name, 'xml')) {
            app_hotpot.parse_ann_xml_file_fh(
                fh,
                dtd
            );
            return;
        }

        console.log('* skip unknown format file', fh.name);
    },

    parse_ann_txt_file_fh: function(fh, dtd) {
        // create a new file name
        var new_fn = app_hotpot.vpp.get_new_ann_fn_by_txt_fn(fh.name);

        // create a empty ann
        var p_txt_ann = fs_read_txt_file_handle(
            fh, 
            dtd
        );

        // load this ann
        p_txt_ann.then((function(new_fn){
            return function(txt_ann) {
                // now check the sentence detection
                // just use the simplest
                var r = nlp_toolkit.sent_tokenize(
                    txt_ann.text,
                    app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
                );
                txt_ann._sentences = r.sentences;
                txt_ann._sentences_text = r.sentences_text;
                
                // modify the txt_ann _fh
                // we couldn't save to an txt
                txt_ann._fh = null;

                // update the _filename
                txt_ann._filename = new_fn;

                // show some message
                app_hotpot.msg("Created a new annotation file " + new_fn);

                // add this ann
                app_hotpot.add_ann(txt_ann);
            }
        })(new_fn));
    },

    parse_ann_xml_file_fh: function(fh, dtd) {
        // get the ann file
        var p_ann = fs_read_ann_file_handle(
            fh, 
            dtd
        );

        // the callback function
        p_ann.then(function(ann) {
            // add the sentences
            var r = nlp_toolkit.sent_tokenize(
                ann.text,
                app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
            );
            ann._sentences = r.sentences;
            ann._sentences_text = r.sentences_text;

            // add this ann to vpp
            app_hotpot.add_ann(ann);

        }).catch(
            function(fh){return function(error) {
                app_hotpot.msg(
                    "Couldn't read annotation in ["+ fh.name +"]. <br>" + 
                    error.name + 
                    ": " + error.message + "",
                    'warning');
                console.error(error);
            }}(fh)
        );
    },

    parse_file_fh: function(fh, callback) {
        if (fh.name.startsWith('.')) {
            // no need to parse hidden file
            return;
        }

        var p_file = fs_read_file_handle(
            fh
        );

        // the callback function
        p_file.then(callback).catch(
            function(fh){return function(error) {
                app_hotpot.msg(
                    "Couldn't read annotation in ["+ fh.name +"]. <br>" + 
                    error.name + 
                    ": " + error.message + "",
                    'warning');
                console.error(error);
            }}(fh)
        );
    },

    parse_dir_fh: function(fh, callback) {
        fs_read_dir_handle(
            fh,
            callback
        );
    },

    /////////////////////////////////////////////////////////////////
    // DTD update related
    /////////////////////////////////////////////////////////////////
    // the default colors are from
    // https://colorbrewer2.org/#type=qualitative&scheme=Set3&n=12
    app_colors: [
        '#a6cee3',
        // '#1f78b4',
        '#51a1d7',
        '#b2df8a',
        '#33a02c',
        '#fb9a99',
        '#e31a1c',
        '#fdbf6f',
        '#ff7f00',
        '#cab2d6',
        '#9654dc',
        '#d0aa3d',
        '#b15928',
        '#8dd3c7',
        '#9c9c64',
        '#bebada',
        '#fb8072',
        '#80b1d3',
        '#fdb462',
        '#b3de69',
        '#fccde5',
        '#d9d9d9',
        '#bc80bd',
        '#ccebc5',
        '#ffed6f',
    ],

    update_tag_styles: function() {
        var elem_style = document.getElementById ("dtd_style");
        var style = elem_style.sheet ? elem_style.sheet : elem_style.styleSheet;

        // clear all rules first
        while(style.cssRules.length>0) {
            style.deleteRule(0);
        }

        // check each tag
        var i = 0;
        for (const tag_name in this.vpp.$data.dtd.tag_dict) {
            if (Object.hasOwnProperty.call(this.vpp.$data.dtd.tag_dict, tag_name)) {
                var tag = this.vpp.$data.dtd.tag_dict[tag_name];
                
                // add a new style for this tag
                var color = 'white';
                if ( i < this.app_colors.length ) {
                    // use default color
                    color = this.app_colors[i];
                } else {
                    // we don't have enough colors now
                    // just use a random color
                    color = '#' + Math.floor(Math.random()*16777215).toString(16);
                }

                // update the color for this tag
                this.vpp.$data.dtd.tag_dict[tag_name].style = {
                    color: color
                };
                
                // add this tag as the given color
                // set this color for related css rules
                style.insertRule(
                    ".mark-tag-" + tag_name + " { background-color: " + color + "; }",
                    0
                );
                style.insertRule(
                    ".border-tag-" + tag_name + " { border-color: " + color + " !important; }",
                    0
                );
                style.insertRule(
                    ".fg-tag-" + tag_name + " { color: " + color + " !important; }",
                    0
                );

                // add this for svg
                style.insertRule(
                    ".svgmark-tag-" + tag_name + " { fill: " + color + "; }",
                    0
                );

                // add this tag as the hint
                style.insertRule(
                    ".mark-hint-" + tag_name + ":hover { background-color: " + color + "; }",
                    0
                );
                
                i += 1;
            }
        }
    },

    app_shortcuts: [
        '1',
        '2',
        '3',
        '4',
        '5',
        'q',
        'w',
        'e',
        'r',
        't',
        'a',
        's',
        'd',
        'f',
        'g',
        'z',
        'x',
        'c',
        'v',
        'b'
    ],

    update_tag_shortcuts: function() {
        for (let i = 0; i < this.vpp.dtd.etags.length; i++) {
            if (i < this.app_shortcuts.length) {
                // assign a key to this etag
                this.vpp.dtd.etags[i].shortcut = this.app_shortcuts[i];
                
                // now, we need to update the tag_dict
            }
        }
    },

    show_tag_ctxmenu: function(x, y) {
        var w = this.ctxmenu_sel.width();
        var h = this.ctxmenu_sel.height();
        var new_y = this.adjust_ctxmenu_y(y, h);
        console.log("* show tag ctx menu on ", x, y, "("+new_y+")", 'w', w, 'h', h);

        // show the tag ctx menu
        this.ctxmenu_sel.css('left', (x - 10 - w) + 'px')
            .css('top', (new_y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_nce_ctxmenu: function(x, y) {
        var w = this.ctxmenu_nce.width();
        var h = this.ctxmenu_nce.height();
        var new_y = this.adjust_ctxmenu_y(y, h);
        console.log("* show nce ctx menu on ", x, y, "("+new_y+")", 'w', w, 'h', h);
        
        // show the document level menu
        this.ctxmenu_nce.css('left', (x - 10 - w) + 'px')
            .css('top', (new_y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    show_tag_popmenu_at: function(x, y) {
        var w = this.popmenu_tag.width();
        console.log("* show tag pop menu ("+w+") on ", x, y);
        // fix for not rendering
        if (w < 150) { w = 150;}
        this.popmenu_tag.css('left', (x - 10 - w) + 'px')
            .css('top', (y + 10) + 'px')
            .show('drop', {}, 200, null);
    },

    adjust_ctxmenu_y: function(y, h) {
        // get the height of current window
        var win_h = $(window).height();

        // set a new y position
        var new_y = y;

        // check the height to avoid hidden by 
        if (y + h > win_h) {
            new_y = win_h - h - 15;
        }

        return new_y;
    },

    update_tag_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_sel = $('#ctxmenu_sel').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_nce_ctxmenu: function() {
        // update the context menu
        this.ctxmenu_nce = $('#ctxmenu_nce').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    update_tag_popmenu: function() {
        // update the pop menu
        this.popmenu_tag = $('#popmenu_tag').menu({
            items: "> :not(.ui-widget-header)"
        });
    },

    del_tag: function(tag_id, ann, is_check_ltag=true, is_update_marks=true) {
        if (typeof(ann) == 'undefined') {
            ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        }

        if (is_check_ltag) {
            // when deleting etag, need to check if there is linked ltag
            var linked_ltags = ann_parser.get_linked_ltags(tag_id, ann);

            if (linked_ltags.length == 0) {
                // great! no links!
                // just keep going
            } else {
                // ok, are you sure?
                // let's make a long message
                var msg = ['There are ' + linked_ltags.length + ' link tag(s) related to [' + tag_id + ']:\n'];
                for (let i = 0; i < linked_ltags.length; i++) {
                    const ltag = linked_ltags[i];
                    msg.push('- ' + ltag.id + ' (' + ltag.tag + ') ' + '\n');
                }
                msg.push('\nDeleting [' + tag_id + '] will also delete the above link tag(s).\n');
                msg.push('Are you sure to continue?');
                msg = msg.join('');

                var ret = this.confirm(msg);

                if (ret) {
                    // ok, let's delete the links first
                    for (let i = 0; i < linked_ltags.length; i++) {
                        const ltag = linked_ltags[i];
                        // save some time when running this inner deletion
                        this.del_tag(ltag.id, ann, false, false);
                    }
                } else {
                    // nice choice! keep them all!
                    return;
                }
            }
        }

        // just remove this tag now
        this.vpp.$data.anns[this.vpp.$data.ann_idx] = this.remove_tag_from_ann(tag_id, ann);

        // mark _has_saved
        this.vpp.$data.anns[this.vpp.$data.ann_idx]._has_saved = false;
        console.log('* deleted tag ' + tag_id);

        // remove the hover box
        this.vpp.hovered_tag = null;

        // update the marks
        if (is_update_marks) {
            app_hotpot.cm_update_marks();
        }

        // toast
        app_hotpot.toast(
            'Successfully deleted tag ' + tag_id,
            ''
        );
    },

    update_hint_dict_by_anns: function() {
        if (this.vpp.$data.anns.length == 0) {
            this.vpp.hint_dict = {};
            return;
        }
        var hint_dict = ann_parser.anns2hint_dict(
            this.vpp.$data.dtd, 
            this.vpp.$data.anns
        );
        this.vpp.hint_dict = hint_dict;
        console.log('* updated hint_dict by anns', this.vpp.hint_dict);
    },

    update_hint_dict_by_tag: function(ann, tag) {
        this.vpp.hint_dict = ann_parser.add_tag_to_hint_dict(
            ann, tag, this.vpp.hint_dict
        );
        console.log('* updated hint_dict by a tag', this.vpp.hint_dict, tag);
    },

    /////////////////////////////////////////////////////////////////
    // Tag Related
    /////////////////////////////////////////////////////////////////
    make_etag: function(basic_tag, tag_def, ann) {
        // first, add the tag name
        basic_tag['tag'] = tag_def.name;

        // find the id number
        // var n = 0;
        // for (let i = 0; i < ann.tags.length; i++) {
        //     if (ann.tags[i].tag == tag_def.name) {
        //         // get the id number of this tag
        //         var _id = parseInt(ann.tags[i].id.replace(tag_def.id_prefix, ''));
        //         if (_id >= n) {
        //             n = _id + 1;
        //         }
        //     }
        // }
        // basic_tag['id'] = tag_def.id_prefix + n;
        basic_tag['id'] = ann_parser.get_next_tag_id(ann, tag_def);

        // add other attr defined in the tag_dee from schema (.dtd)
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
                // which means it could be a non-consuming tag?
            } else {
                // set the default value
                basic_tag[att.name] = att.default_value;
            }
        }

        return basic_tag;
    },

    make_ltag: function() {

    },

    make_empty_etag_by_tag_def: function(tag_def) {
        var etag = {
            id: '',
            tag: tag_def.name,
            spans: '',
            text: ''
        };

        // then add other attr
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
                etag.spans = dtd_parser.NON_CONSUMING_SPANS;
            } else {
                // set the default value
                etag[att.name] = att.default_value;
            }
        }

        return etag;
    },

    make_empty_ltag_by_tag_def: function(tag_def) {
        var ltag = {
            id: '',
            tag: tag_def.name
        };

        // then add other attr
        for (let i = 0; i < tag_def.attlists.length; i++) {
            const att = tag_def.attlists[i];

            if (att.name == 'spans') {
                // special rule for spans attr
            } else {
                // set the default value
                ltag[att.name] = att.default_value;
            }
        }

        return ltag;
    },
    
    remove_tag_from_ann: function(tag_id, ann) {
        var tag_idx = -1;
        for (let i = 0; i < ann.tags.length; i++) {
            if (ann.tags[i].id == tag_id) {
                tag_idx = i;
                break;
            }            
        }

        // delete the found tag idx
        if (tag_idx == -1) {
            // ???
        } else {
            ann.tags.splice(tag_idx, 1); 
        }

        return ann;
    },

    /////////////////////////////////////////////////////////////////
    // Code Mirror Related
    /////////////////////////////////////////////////////////////////
    cm_set_ann: function(ann) {
        // make sure all clear
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_ltag_marks();

        // first, if ann is null, just remove everything in the editor
        if (ann == null) {
            this.codemirror.setValue('');
            return;
        }

        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            this.codemirror.setValue(
                ann.text
            );

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            this.codemirror.setValue(
                ann._sentences_text
            );
        } else {
            this.codemirror.setValue('');
        }
    },

    cm_get_selection: function(inst) {
        if (typeof(inst) == 'undefined') {
            inst = this.codemirror;
        }
        // update the selection
        var selection = {
            sel_txts: inst.getSelections(),
            sel_locs: inst.listSelections()
        };
        this.selection = selection;
        // console.log("* found selection:", app_hotpot.selection);
        return selection;
    },

    cm_clear_selection: function(to_anchor=true) {
        var new_anchor = null;
        if (to_anchor) {
            new_anchor = this.selection.sel_locs[0].anchor;
        } else {
            new_anchor = this.selection.sel_locs[0].head;
        }
        this.codemirror.setSelection(new_anchor);
    },

    cm_make_basic_etag_from_selection: function() {
        var locs = [];
        var txts = [];

        // usually there is only one tag
        for (let i = 0; i < app_hotpot.selection.sel_locs.length; i++) {
            var sel_loc = app_hotpot.selection.sel_locs[i];
            var sel_txt = app_hotpot.selection.sel_txts[i];
            locs.push(
                app_hotpot.cm_range2spans(
                    sel_loc, 
                    this.vpp.$data.anns[this.vpp.$data.ann_idx]
                )
            );
            txts.push(sel_txt);
        }
        
        // now push new ann tag
        var tag = {
            'spans': locs.join(','),
            'text': txts.join(' ... ')
        };

        return tag;
    },

    cm_update_marks: function() {
        // clear all etag markers
        this.cm_clear_etag_marks();

        // clear all link tags
        this.cm_clear_ltag_marks();

        // update the hint marks
        this.cm_update_hint_marks();

        // update the tag marks
        this.cm_update_tag_marks();

        // force update UI, well ... maybe not work
        this.vpp.$forceUpdate();
    },

    cm_clear_etag_marks: function() {
        var marks = this.codemirror.getAllMarks();
        for (let i = marks.length - 1; i >= 0; i--) {
            marks[i].clear();
        }
    },

    cm_clear_ltag_marks: function() {
        // first, check if there is a layer for the plots
        if ($('#cm_svg_plots').length == 0) {
            $('.CodeMirror-sizer').prepend(`
            <div class="CodeMirror-plots">
            <svg id="cm_svg_plots">
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            </svg>
            </div>
        `);
        } else {
            $('#cm_svg_plots').html(`
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                        markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" />
                    </marker>
                </defs>
            `);
        }
    },

    cm_update_hint_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        if (!this.vpp.$data.cm.enabled_hints ||
            this.vpp.$data.cm.hint_mode == 'off') {
            // nothing to do when turn off hint
            return;
        }

        if (this.vpp.$data.dtd == null) {
            // nothing to do if no dtd given
            return;
        }

        var focus_tags = null;
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {

        } else {
            if (this.vpp.$data.display_tag_name == '__all__') {
                // search all tag
            } else {
                // ok, only search this tag
                focus_tags = [ this.vpp.$data.display_tag_name ];
            }
        }

        // find markable hints for this ann
        var hints = ann_parser.search_hints_in_ann(
            this.vpp.hint_dict,
            this.vpp.$data.anns[this.vpp.$data.ann_idx],
            focus_tags
        );
        console.log('* found hints', hints);

        // bind the hints to vpp
        this.vpp.$data.hints = hints;

        for (let i = 0; i < hints.length; i++) {
            const hint = hints[i];
            // console.log('* rendering hint', hint);
            this.cm_mark_hint_in_text(
                hint,
                this.vpp.$data.anns[this.vpp.$data.ann_idx]
            );
        }
    },

    cm_update_tag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        // to ensure the link tag could be draw correctly,
        // draw the etags first
        this.cm_update_etag_marks();

        // since all etags have been rendered,
        // it's safe to render the link tags
        this.cm_update_ltag_marks();
    },

    cm_update_etag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }

        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'etag') {
                var ret = this.cm_mark_ann_etag_in_text(tag, tag_def, working_ann);
                // console.log('* finished rendering', ret, tag);
            }
        }
    },

    cm_update_ltag_marks: function() {
        if (this.vpp.$data.ann_idx == null) {
            // nothing to do for empty
            return;
        }
        if (this.vpp.$data.cm.enabled_links) {
            // ok! show links
        } else {
            // well, if user doesn't want to show links,
            // it's ok
            return;
        }
        // update the new marks
        var working_ann = this.vpp.$data.anns[this.vpp.$data.ann_idx];
        for (let i = 0; i < working_ann.tags.length; i++) {
            var tag = working_ann.tags[i];
            var tag_def = this.vpp.get_tag_def(tag.tag);
            if (tag_def.type == 'ltag') {
                this.cm_mark_ann_ltag_in_text(tag, tag_def, working_ann);
            }
        }
    },

    /**
     * Mark the hint in the code mirror
     * @param {object} hint it contains the range for rendering
     */
    cm_mark_hint_in_text: function(hint, ann) {
        var range = this.cm_spans2range(hint.spans, ann);
        // console.log("* marking hint", hint, 'on', range);

        // a hover message
        var descr = [
            "" + hint.tag
        ].join('\n');
        
        if (this.vpp.$data.cm.mark_mode == 'node') {
            var hint_tag_id_prefix = dtd_parser.get_id_prefix(
                hint.tag, 
                this.vpp.$data.dtd
            );
            var markHTML = [
                '<span class="mark-hint mark-hint-'+hint.tag+'" id="mark-id-'+hint.id+'" onclick="app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')" title="Click to add this to tags" data-descr="'+descr+'">',
                '<span class="mark-hint-info mark-tag-'+hint.tag+'">',
                    hint_tag_id_prefix,
                '</span>',
                '<span class="mark-hint-text" hint_id="'+hint.id+'">',
                    hint.text,
                '</span>',
                '</span>'
            ].join('');

            // convert this HTML to DOMElement
            var placeholder = document.createElement('div');
            placeholder.innerHTML = markHTML;
            var markNode = placeholder.firstElementChild;

            try {
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-hint mark-hint-' + hint.tag,
                        replacedWith: markNode,
                        attributes: {
                            hint_id: hint.id,
    
                        }
                    }
                );
            } catch (error) {
                // sometimes, replacing DOM node may fail due to
                // Error: Inserting collapsed marker partially overlapping an existing one
                // so, just skip this for now
                console.error("! can't mark conflict hint", hint)
            }
            
        } else if (this.vpp.$data.cm.mark_mode == 'span') {
            
            this.codemirror.markText(
                range.anchor,
                range.head,
                {
                    className: 'mark-hint mark-hint-' + hint.tag,
                    attributes: {
                        hint_id: hint.id,
                        onclick: 'app_hotpot.vpp.add_tag_by_hint(\''+hint.id+'\')',
                        'data-descr': descr
                    }
                }
            );
        }
    },

    cm_mark_ann_tag_in_text: function(tag, tag_def, ann) {
        if (tag_def.type == 'etag') {
            return this.cm_mark_ann_etag_in_text(tag, tag_def, ann);
        } else {
            return this.cm_mark_ann_ltag_in_text(tag, tag_def, ann);
        }
    },

    cm_mark_ann_ltag_in_text: function(tag, tag_def, ann) {
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {
            // ok, let's render all tags here
        } else {
            if (app_hotpot.vpp.is_display_tag_name(tag.tag)) {
                // ok
            } else {
                return [-1];
            }
        }

        this.cm_draw_ltag(tag, tag_def, ann);
    },

    cm_mark_ann_etag_in_text: function(tag, tag_def, ann) {
        var raw_spans = tag['spans'];
        // before rendering this tag
        // we need to check whether it should be rendered

        // 1. something wrong with the spans information?
        if (raw_spans == '' || raw_spans == null) { 
            return [-1]; 
        }

        // 2. document-level tag, nothing to do or render differently
        if (raw_spans == dtd_parser.NON_CONSUMING_SPANS) {
            return [-2];
        }

        // 3. is current setting to render all or only selected?
        if (app_hotpot.vpp.is_render_tags_of_all_concepts()) {
            // ok, nothing to worry, just render this tag
        } else {
            // is display this tag by the tag list filter?
            if (app_hotpot.vpp.is_display_tag_name(tag.tag)) {
                // ok
            } else {
                // the second case is quite complex.
                // to render the link tags,
                // the related entity tags are also needed to render
                // so the question is, is this tag belong to current link tag?
                if (app_hotpot.vpp.get_tag_def(app_hotpot.vpp.$data.display_tag_name).type == 'ltag') {
                    // only check this for only showing link tag.
                    // otherwise it will cost unnecessary computation
                    if (app_hotpot.vpp.is_tag_related_to_tag_name(
                        tag, 
                        [app_hotpot.vpp.$data.display_tag_name],
                        app_hotpot.vpp.$data.anns[app_hotpot.vpp.$data.ann_idx]
                    )) {
                        // ok, I don't which one, but it does belong to which link
                        // just goto render

                    } else {
                        // great, no need to render
                        return [-3];
                    }
                } else {
                    // great, no need to render
                    return [-4];
                }
            }
        }

        // the spans may contains multiple parts
        // split them first
        var spans_arr = raw_spans.split(',');
        var text_arr = tag.text.split('...');

        // hover message
        var descr = [
            "" + tag.tag + ' - ' + tag.id,
            "spans: " + tag.spans
        ];
        descr = descr.join('\n');
        
        // render every part of the spans
        for (let i = 0; i < spans_arr.length; i++) {
            const spans = spans_arr[i];
            const spans_text = text_arr[i];
            var range = this.cm_spans2range(spans, ann);

            if (this.vpp.$data.cm.mark_mode == 'node') {
                // the second step is to enhance the mark tag with more info
                var markHTML = [
                    '<span class="mark-tag mark-tag-'+tag.tag+'" '+
                        'id="mark-etag-id-'+tag.id+'" '+
                        'tag_id="'+tag.id+'" '+
                        'data-descr="'+descr+'" '+
                        'onmouseenter="app_hotpot.vpp.on_enter_tag(event)" '+
                        'onmouseleave="app_hotpot.vpp.on_leave_tag(event)">',
                    '<span onclick="app_hotpot.vpp.on_click_editor_tag(event, \''+tag.id+'\')">',
                    '<span class="mark-tag-info">',
                        '<span class="mark-tag-info-inline fg-tag-'+tag.tag+'">',
                        tag.id,
                        '</span>',
                    '</span>',
                    '<span class="mark-tag-text" tag_id="'+tag.id+'">',
                        spans_text,
                    '</span>',
                    '</span>',
                    '<span class="mark-tag-info-offset" title="Delete tag '+tag.id+'" onclick="app_hotpot.del_tag(\''+tag.id+'\');">',
                        '<i class="fa fa-times-circle"></i>',
                    '</span>',
                    '</span>'
                ].join('');

                // convert this HTML to DOMElement
                var placeholder = document.createElement('div');
                placeholder.innerHTML = markHTML;
                var markNode = placeholder.firstElementChild;

                // add mark to text
                try {
                    this.codemirror.markText(
                        range.anchor,
                        range.head,
                        {
                            className: 'mark-tag mark-tag-' + tag.tag,
                            replacedWith: markNode,
                            attributes: {
                                tag_id: tag.id
                            }
                        }
                    );
                } catch (error) {
                    console.error("! can't mark conflict tag", tag)
                }

            } else if (this.vpp.$data.cm.mark_mode == 'span') {
                this.codemirror.markText(
                    range.anchor,
                    range.head,
                    {
                        className: 'mark-tag mark-tag-' + tag.tag + '',
                        attributes: {
                            id: 'mark-etag-id-' + tag.id,
                            tag_id: tag.id,
                            onclick: 'app_hotpot.vpp.on_click_editor_tag(event, \''+tag.id+'\')',
                            'data-descr': descr,
                            onmouseenter: 'app_hotpot.vpp.on_enter_tag(event)',
                            onmouseleave: 'app_hotpot.vpp.on_leave_tag(event)',
                        }
                    }
                );
                // add a cap of annotator for adjudication
                if (tag.hasOwnProperty('_annotator')) {
                    this.cm_draw_etag_cap(
                        tag, 
                        ann, 
                        tag._annotator.toLocaleUpperCase()
                    );
                }
            }
        }

        return [0];
    },

    cm_jump2tag: function(tag, ann) {
        // first, get the anchor location
        var range = this.cm_spans2range(
            tag.spans, ann
        );

        // set the anchor
        this.codemirror.doc.setCursor(
            range.anchor
        );
    },

    cm_spans2range: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_spans2range(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_spans2range(spans, ann);

        } else {
            return this.cm_doc_spans2range(spans, ann);
        }
    },

    cm_range2spans: function(spans, ann) {
        // if the current mode is 
        if (this.vpp.$data.cm.display_mode == 'document') {
            return this.cm_doc_range2spans(spans, ann);

        } else if (this.vpp.$data.cm.display_mode == 'sentences') {
            return this.cm_sen_range2spans(spans, ann);

        } else {
            return this.cm_doc_range2spans(spans, ann);
        }
    },

    cm_sen_range2spans: function(sel_loc, ann) {
        var span0 = 0;

        // first, get the start span of this line
        var line_span0 = ann._sentences[
            sel_loc.anchor.line
        ].spans.start;
        var line_span1 = ann._sentences[
            sel_loc.head.line
        ].spans.start;

        // then move to the span of this line
        span0 = line_span0 + sel_loc.anchor.ch;
        span1 = line_span1 + sel_loc.head.ch;

        // the selection maybe from different direction
        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_sen_spans2range: function(spans, ann) {
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // find the line number of span0
        var anchor = nlp_toolkit.find_linech(span_pos_0, ann._sentences);
        var head = nlp_toolkit.find_linech(span_pos_1, ann._sentences);

        return {
            anchor: anchor,
            head: head
        }
    },

    cm_doc_range2spans: function(sel_loc, ann) {
        var full_text = ann.text;
        // console.log('* calc doc range2spans: ');
        // console.log(sel_loc);
        var lines = full_text.split('\n');
        var span0 = 0;
        for (let i = 0; i < sel_loc.anchor.line; i++) {
            span0 += lines[i].length + 1;
        }
        span0 += sel_loc.anchor.ch;
        var span1 = 0;
        for (let i = 0; i < sel_loc.head.line; i++) {
            span1 += lines[i].length + 1;
        }
        span1 += sel_loc.head.ch;
        // console.log('* span0: ' + span0 + ', span1: ' + span1);

        if (span0 <= span1) {
            return span0 + '~' + span1;
        } else {
            return span1 + '~' + span0;
        }
    },

    cm_doc_spans2range: function(spans, ann) {
        var full_text = ann.text;

        // console.log('* calc doc spans2range: ');
        var span_pos_0 = parseInt(spans.split('~')[0]);
        var span_pos_1 = parseInt(spans.split('~')[1]);

        // calculate the line number
        var ln0 = full_text.substring(0, span_pos_0).split('\n').length - 1;
        var ln1 = full_text.substring(0, span_pos_1).split('\n').length - 1;

        // calculate the char location
        var ch0 = span_pos_0;
        for (let i = 1; i < span_pos_0; i++) {
            if (full_text[span_pos_0 - i] == '\n') {
                ch0 = i - 1;
                break;
            }
        }

        // TODO fix the potential cross lines bug
        var ch1 = ch0 + (span_pos_1 - span_pos_0);

        // return [ [ln0, ch0], [ln1, ch1] ];
        return {
            anchor: {line: ln0, ch: ch0},
            head:   {line: ln1, ch: ch1}
        }
    },

    cm_spans2coords: function(spans, ann) {
        var range = this.cm_spans2range(spans, ann);

        var coords_l = this.codemirror.charCoords(
            // { line: range[0][0], ch: range[0][1] },
            range.anchor,
            'local'
        );
        var coords_r = this.codemirror.charCoords(
            // { line: range[1][0], ch: range[1][1] },
            range.head,
            'local'
        );

        return { 
            l: coords_l, 
            r: coords_r 
        };
    },

    scroll_annlist_to_bottom: function() {
        var objDiv = document.getElementById("mui_annlist");
        objDiv.scrollTop = objDiv.scrollHeight;
    },

    scroll_tag_table_to: function(tag_id) {
        // get the annlist height
        var h = $('#mui_annlist').height();
        
        // get the offset of this tag
        var tr = $('#tag-table-row-' + tag_id);
        if (tr.length != 1) {
            // which means no such element
            return; 
        }
        var offset_y = tr[0].offsetTop;

        // scroll to the view
        // when scrolling to the offset
        $('#mui_annlist')[0].scrollTo(
            0, // the x-axis should be no scroll
            offset_y - h / 2
        );
    },

    highlight_tag_table_row: function(tag_id) {

        // get the row of this tag
        var tagr = $('#tag-table-row-' + tag_id);
        if (tagr.length != 1) {
            // which means no such element
            return; 
        }
        var flag_actived = tagr.hasClass('tag-table-tr-actived');

        // remove other style
        $('.tag-table-row').removeClass('tag-table-tr-actived');

        // add a class to this dom
        if (flag_actived) {

        } else {
            tagr.addClass('tag-table-tr-actived');
        }
        // show animation
        // tagr.animate({backgroundColor: 'yellow'}, 300)
        // .animate({backgroundColor: 'white'}, 700);
    },

    highlight_editor_tag: function(tag_id) {
        // get this tag in editor
        var elm = $('#mark-etag-id-' + tag_id);
        if (elm.length != 1) {
            // which means no such element
            return; 
        }
        var flag_actived = elm.hasClass('mark-tag-active');

        // remove other class
        $('.mark-tag-active').removeClass('mark-tag-active');

        // add a class to this dom
        if (flag_actived) {

        } else {
            elm.addClass('mark-tag-active');
        }
    },

    cm_draw_ltag: function(ltag, ltag_def, ann) {
        // for showing the ltag, we need:
        // 1. the atts for accessing the ltag
        // 2. the values of att_a and att_b, which are tag_id for etag
        // 3. get the tag, then call cm_draw_polyline

        // so, get all attlists
        var atts = this.vpp.get_idref_attlists(ltag_def);

        // next, get the values fron this ltag
        var etags = [];
        for (let i = 0; i < atts.length; i++) {
            var att = atts[i];
            var etag_id = ltag[att.name];

            if (typeof(etag_id) == 'undefined' || 
                etag_id == null || 
                etag_id == '') {
                // this att is just empty
                continue;
            }

            // check this etag
            var etag = this.vpp.get_tag_by_tag_id(etag_id, ann);
            if (etag == null) { 
                continue; 
            }
            if (etag.spans == dtd_parser.NON_CONSUMING_SPANS) {
                continue;
            }

            // ok, save this etag for later use
            etags.push(etag);
        }
        // then, check if there are more than two etags
        console.log('* found ' + etags.length + ' etags available for this link');

        // first, draw dots
        for (let i = 0; i < etags.length; i++) {
            const etag = etags[i];
            this.cm_draw_ltag_id(ltag, etag, ann);
        }

        if (!this.vpp.$data.cm.enabled_link_complex) {
            return;
        }

        // second, draw polyline
        if (etags.length < 2) {
            // which means not enough etag for drawing line
            return;
        }
        var tag_a = etags[0];
        var tag_b = etags[1];

        console.log(
            '* try to draw line ['+ltag.id+'] between', 
            '['+tag_a.id+']-', 
            '['+tag_a.id+']'
        );

        // last, draw!
        this.cm_draw_polyline(
            ltag, tag_a, tag_b, ann
        );
    },

    // cm_draw_ltag_first_two: function(ltag, ltag_def, ann) {
    //     // for showing the polyline, we need:
    //     // 1. the att_a and att_b for accessing the ltag
    //     // 2. the values of att_a and att_b, which are tag_id for etag
    //     // 3. get the tag, then call cm_draw_polyline

    //     // so, get the att_a and att_b first
    //     var att_a = this.vpp.get_idref_attlist_by_seq(ltag_def, 0);
    //     var att_b = this.vpp.get_idref_attlist_by_seq(ltag_def, 1);

    //     // next, get the values
    //     var etag_a_id = ltag[att_a.name];
    //     var etag_b_id = ltag[att_b.name];
    //     // console.log(
    //     //     '* try to draw line ['+ltag.id+'] between', 
    //     //     att_a.name, '['+etag_a_id+']-', 
    //     //     att_b.name, '['+etag_b_id+']'
    //     // );

    //     // if the value is null or empty, just skip
    //     if (etag_a_id == null || etag_a_id == '') { return; }
    //     if (etag_b_id == null || etag_b_id == '') { return; }

    //     // convert the tag_id to tag
    //     var tag_a = this.vpp.get_tag_by_tag_id(etag_a_id, ann);
    //     var tag_b = this.vpp.get_tag_by_tag_id(etag_b_id, ann);

    //     // if the tag is not available, just skip
    //     if (tag_a == null || tag_b == null) { return; }

    //     // if one of the tags is non-consuming tag, just skip
    //     if (tag_a.spans == dtd_parser.NON_CONSUMING_SPANS ||
    //         tag_b.spans == dtd_parser.NON_CONSUMING_SPANS) {
    //         return;
    //     }

    //     // last, draw!
    //     this.cm_draw_polyline(
    //         ltag, tag_a, tag_b, ann
    //     );
    // },

    cm_draw_etag_cap: function(etag, ann, cap) {
        // then get the coords
        var coords = this.cm_spans2coords(etag.spans, ann);
        // console.log('* found etag coords:', coords);

        // the basic x is just the tag left position
        var x = coords.l.left;
        // the basic y is a little higher
        var y = coords.l.top + 2.5;

        // find existing cap on this tag if there is
        // var tagcaps = $('#cm_svg_plots .tag-cap-' + etag.id);
        // for (let i = 0; i < tagcaps.length; i++) {
        //     const elem = tagcaps[i];
        //     var shape = this.get_elem_shape(elem);
        //     x += shape.width + 1;
        // }
        // find the relative x
        // var el = document.querySelector('#mark-etag-id-' + etag.id);
        // x = el.offsetLeft;

        // make a cap for this etag
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-tag-cap-id-' + etag.id);
        svg_text.setAttribute('text-anchor', 'left');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', x);
        svg_text.setAttribute('y', y);
        svg_text.setAttribute('class', 
            "tag-cap border-tag-" + etag.tag + 
            " tag-cap-id-" + etag.id +
            " tag-cap-" + cap
        );
        // put the text in this cap
        var text_node_content = cap;
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );
    },

    cm_draw_ltag_id: function(ltag, tag, ann) {
        // then get the coords
        var coords = this.cm_spans2coords(tag.spans, ann);
        // console.log('* found etag coords:', coords);

        // the basic x is just the tag left position
        var x = coords.l.left;
        // move to middle
        x += (coords.l.right - coords.l.left) / 2 + 1;

        // the basic y is a little higher
        var y = coords.l.top + 2;

        // find existing linkdot on this tag if there is
        var linkdots = $('#cm_svg_plots .tag-linkdot-' + tag.id);

        // add offset to x
        for (let i = 0; i < linkdots.length; i++) {
            const elem = linkdots[i];
            var shape = this.get_elem_shape(elem);
            x += shape.width + 1;
        }

        // make a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-dot-id-' + ltag.id + '-' + tag.id);
        svg_text.setAttribute('text-anchor', 'left');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', x);
        svg_text.setAttribute('y', y);
        svg_text.setAttribute('class', "tag-linkdot border-tag-" + tag.tag + " tag-linkdot-" + tag.id);

        // put the text
        var text_node_content = " ";
        if (this.vpp.$data.cm.enabled_link_name) {
            text_node_content = " " + ltag.id;
        }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // this.make_svg_text_bg(svg_text, 'svgmark-tag-' + ltag.tag);
    },

    cm_draw_polyline: function(ltag, tag_a, tag_b, ann) {
        // then get the coords of both tags
        var coords_a = this.cm_spans2coords(tag_a.spans, ann);
        var coords_b = this.cm_spans2coords(tag_b.spans, ann);

        // the setting for the polyline
        var delta_height = 2;
        var delta_width = 0;

        // get the upper coords, which is the lower one
        var upper_top = coords_a.l.top < coords_b.l.top ? 
            coords_a.l.top : coords_b.l.top;
        upper_top = upper_top - delta_height;

        // get the sign for relative location
        var sign = coords_b.l.left - coords_a.l.left > 0 ? 1 : -1;

        // then calc the points for the polyline
        var xys = [
            // point, start
            [
                (coords_a.l.left + coords_a.r.left)/2,
                (coords_a.l.top + 4)
            ],
            // point joint 1
            [
                (coords_a.l.left + coords_a.r.left)/2 + sign * delta_width,
                upper_top
            ],
            // point, joint 2
            [
                ((coords_b.l.left + coords_b.r.left)/2 - sign * delta_width),
                upper_top
            ],
            // point, end
            [
                (coords_b.l.left + coords_b.r.left)/2,
                (coords_b.l.top + 3)
            ]
        ];

        // put all points togather
        var points = [];
        for (let i = 0; i < xys.length; i++) {
            const xy = xys[i];
            // convert to int for better display
            var x = Math.floor(xy[0]);
            var y = Math.floor(xy[1]);
            points.push(x + ',' + y);
        }

        // convert to a string
        points = points.join(' ');

        // create a poly line and add to svg
        // Thanks to the post!
        // https://stackoverflow.com/questions/15980648/jquery-added-svg-elements-do-not-show-up
        var svg_polyline = document.createElementNS(
            'http://www.w3.org/2000/svg', 'polyline'
        );
        svg_polyline.setAttribute('id', 'mark-link-line-id-' + ltag.id);
        svg_polyline.setAttribute('points', points);
        svg_polyline.setAttribute('class', "tag-polyline");
        // svg_polyline.setAttribute('marker-end', "url(#arrow)");

        $('#cm_svg_plots').append(
            svg_polyline
        );

        // NEXT, draw a text
        var svg_text = document.createElementNS(
            'http://www.w3.org/2000/svg', 'text'
        );
        svg_text.setAttribute('id', 'mark-link-text-id-' + ltag.id);
        svg_text.setAttribute('text-anchor', 'middle');
        svg_text.setAttribute('alignment-baseline', 'middle');
        svg_text.setAttribute('x', (xys[0][0] + xys[3][0]) / 2);
        svg_text.setAttribute('y', xys[1][1] + delta_height);
        svg_text.setAttribute('class', "tag-linktext");

        // put the text
        var text_node_content = ltag.id;
        // if (this.vpp.$data.cm.enabled_link_name) {
        //     text_node_content = ltag.tag + ': ' + ltag.id;
        // }
        svg_text.append(document.createTextNode(text_node_content));

        $('#cm_svg_plots').append(
            svg_text
        );

        // then create a background color
        this.make_svg_text_bg(svg_text, 'svgmark-tag-' + ltag.tag);
    },

    cm_calc_points: function(coords_a, coords_b) {

    },
    
    /////////////////////////////////////////////////////////////////
    // Utils
    /////////////////////////////////////////////////////////////////
    is_same_dtd: function(dtd_a, dtd_b, level) {
        if (typeof(level) == 'undefined') {
            level = 0;
        }

        if (level>=0) {
            if (dtd_a.name == dtd_b.name) {
                
            } else {
                return false;
            }
        }

        return true;
    },

    is_file_ext: function(filename, ext) {
        var fn_lower = filename.toLocaleLowerCase();

        if (fn_lower.endsWith("." + ext)) {
            return true;
        }

        return false;
    },

    toast: function(msg, cls, timeout) {
        if (typeof(cls) == 'undefined') {
            cls = '';
        }
        if (typeof(timeout) == 'undefined') {
            timeout = 3000;
        }
        var options = {
            showTop: true,
            timeout: timeout,
            clsToast: cls
        };
        Metro.toast.create(msg, null, null, null, options);
    },

    msg: function(msg, cls) {
        if (typeof(cls) == 'undefined') {
            cls = 'info';
        }
        msg = '<i class="fa fa-info-circle"></i> ' + msg; 
        var notify = Metro.notify;
        notify.setup({
            width: 300,
            timeout: 3000,
            animation: 'swing'
        });
        notify.create(msg, null, { 
            cls: cls
        });
    },

    confirm: function(msg) {
        return window.confirm(msg);
        // Metro.dialog.create({
        //     title: "Use Windows location service?",
        //     content: "<div>Bassus abactors ducunt ad triticum...</div>",
        //     actions: [
        //         {
        //             caption: "Agree",
        //             cls: "js-dialog-close alert",
        //             onclick: function(){
        //                 alert("You clicked Agree action");
        //             }
        //         },
        //         {
        //             caption: "Disagree",
        //             cls: "js-dialog-close",
        //             onclick: function(){
        //                 alert("You clicked Disagree action");
        //             }
        //         }
        //     ]
        // });
    },

    get_elem_shape: function(elem) {
        // get the bounding box for this element
        var bounds = elem.getBBox();

        // get the extend style 
        var style = getComputedStyle(elem);
        var padding_top = parseInt(style["padding-top"])
        var padding_left = parseInt(style["padding-left"])
        var padding_right = parseInt(style["padding-right"])
        var padding_bottom = parseInt(style["padding-bottom"])

        // now, we could get the shape of this element
        var shape = {
            x: bounds.x - padding_left,
            y: bounds.y - padding_top,
            width: bounds.width + padding_left + padding_right,
            height: bounds.height + padding_top + padding_bottom
        }

        return shape;
    },

    make_svg_text_bg: function(elem, cls) {
        // get the shape
        var shape = this.get_elem_shape(elem);

        // create a background
        var bg = document.createElementNS(
            "http://www.w3.org/2000/svg", 
            "rect"
        );

        // set the attributes of this bg
        bg.setAttribute("x", shape.x);
        bg.setAttribute("y", shape.y);
        bg.setAttribute("width", shape.width);
        bg.setAttribute("height", shape.height);
        bg.setAttribute("class", 'tag-linktext-bg ' + cls);

        elem.parentNode.insertBefore(bg, elem);
    },

    start_tour_annotation: function() {
        if (this.tour.annotation == null) {
            this.tour.annotation = new Shepherd.Tour({
                defaultStepOptions: {
                    classes: '',
                    scrollTo: true
                }
            });

            // add step for dtd
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'Welcome!     This tool is very easy to use!<br>First, we could drop a schema (.dtd) file here.<br>The schema file defines all of the concepts you want to annotate in the documents.',
                attachTo: {
                  element: '#dropzone_dtd',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'Second, you need to drop some annotation files here.<br>You could drop raw text files (.txt) to start and add more anytime. Our tool will automatically convert the text files to xml format when saving. Then, next time you could drop those saved xml files here directly.',
                attachTo: {
                  element: '#dropzone_ann',
                  on: 'right'
                },
                classes: '',
                buttons: [{
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }, {
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Next <i class="fa fa-arrow-right"></i>',
                    action: this.tour.annotation.next
                }]
            });

            // add step for text
            this.tour.annotation.addStep({
                id: 'example-step',
                text: 'That\'s all to start a new annotation task!<br>If you are not sure what each button does, here is a sample dataset for you to try. You could play with this sample data freely to see how each function works for annotation.<br>Have fun! ',
                attachTo: {
                  element: '#btn_annotation_load_sample',
                  on: 'left'
                },
                classes: '',
                buttons: [{
                    text: '<i class="fa fa-arrow-left"></i> Prev',
                    action: this.tour.annotation.back
                }, {
                    text: 'Close',
                    classes: 'bg-gray', 
                    action: this.tour.annotation.complete
                }]
            });
        }

        this.tour.annotation.start();
    }
};

// extend the App
/**
 * This is an extension for app_hotpot text contents
 */

Object.assign(app_hotpot.vpp_data, {
texts: {
    "sentence_splitting_algorithm": {
        title: 'Sentence Splitting Algorithm',
        html: `MedTator can display text content in different ways, which include a sentence-mode display.
To display the split sentences correctly, the original content must be tokenized in sentence level.
There are several different methods / algorithms for sentence tokenization, and these methods are implemented in different packages / libraries.
MedTator provides some options for selecting different methods.

<ul>
    <li>The default method is a simple splitting algorithm based on symbol detection. This algorithm will check each character in the given text and compare it with pre-defined schema. The result of this algorithm works for most of cases, and has great performance. </li>
    <li>The <b>Compromise NLP</b> method is implemented based on <a target="_blank" href="https://github.com/spencermountain/compromise">Compromise NLP library</a>. It provides APIs for sentence spliting and formating. For more information, its <a target="_blank" href="https://observablehq.com/@spencermountain/compromise-sentences"></a> provides more technical details.</li>
    <li>The <b>Wink NLP</b> method is based on <a target="_blank" href="https://winkjs.org/">WinkJS NLP library</a>.</li>
</ul>
`
    },
    "linking_marks_selection": {
        title: 'Linking marks selection',
        html: `The marks shown in the tag editor can be linked with the selection with the concept list.`
    }
}});

// extend the App with IAA
/**
 * This is an extension for IAA calculator 
 */

/////////////////////////////////////////////////////////////////
// IAA related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    // for iaa
    iaa_ann_list: [
        {anns: [], name: 'A'}, // for annotator A
        {anns: [], name: 'B'}, // for annotator B
    ],
    iaa_dict: null,
    iaa_display_tag_name: '__all__',
    iaa_match_mode: 'overlap', // overlap / exact
    iaa_overlap_ratio: 50,
    iaa_overlap_ratio_default: 50,
    iaa_display_hashcode: null,
    iaa_display_tags_context: true,
    iaa_display_tags_tp: false,
    iaa_display_adj_panel: true,
    iaa_display_adj_detail: false,

    // sort anns
    // - default: how the anns are imported into tool
    // - a.alphabet: A-Z
    // - a.alphabet_r: Z-A
    // - a.tags: 0-N
    // - a.tags_r: N-0
    iaa_sort_anns_by: 'default',

    // for iaa adjudication
    iaa_gs_dict: null,

    // for using attributes in IAA
    iaa_use_attributes: false,

    // remove the tag when low_overlap for calcuting
    // this can remove the duplicated results in FN
    // so the IAA calculation result will be different
    // the 
    iaa_remove_tag_b_when_low_overlap: true,

    // for using attributes in IAA a selection map
    // {
    //    tag_name: {
    //        attr_name: true / false
    //    }
    // }
    iaa_use_tag_attrs: {},

    // for IAA display mode, show F1 or other indicators
    iaa_display_measure: 'f1',
});


/////////////////////////////////////////////////////////////////
// IAA related functions
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot, {
    // events for loading ann files for IAA
    bind_dropzone_iaa: function() {
        let dropzones = document.getElementsByClassName("dropzone-iaa");

        for (let i = 0; i < dropzones.length; i++) {
            var dropzone = dropzones[i];
            var iaa_id = parseInt(dropzone.getAttribute('iaa_id'));

            dropzone.addEventListener("dragover", function(event) {
                event.preventDefault();
            }, false);

            dropzone.addEventListener("drop", (function(iaa_id) {
                return function(event) {
                    // stop the download event
                    event.preventDefault();
                    // first, we need to which dropzone triggers event
    
                    console.log('* drop something on iaa ' + iaa_id);
                    // return;
        
                    let items = event.dataTransfer.items;
        
                    for (let i=0; i<items.length; i++) {
                        // check ext first
                        let fileEntry = items[i].webkitGetAsEntry();
                        if (!app_hotpot.is_file_ext(fileEntry.name, 'xml')) {
                            app_hotpot.msg('Skipped non-XML file ' + fileEntry.name, 'warning');
                            continue;
                        }
                        // we have two ways of loading data
                        // first using the basic entry
                        // second using the fs handle
                        // it depends the browser API
                        if (isFSA_API_OK) {
                            // just load in this way
                            let item = items[i].getAsFileSystemHandle();
                            item.then((function(iaa_id) {
                                return function(fh) {
                                    if (fh.kind == 'file') {
                                        // check exists
                                        if (app_hotpot.vpp.has_included(
                                            fh.name, 
                                            app_hotpot.vpp.$data.iaa_ann_list[iaa_id].anns)) {
                                            // exists? skip this file
                                            return;
                                        }
                
                                        // read the file
                                        var p_ann = fs_read_ann_file_handle(
                                            fh,
                                            app_hotpot.vpp.$data.dtd
                                        );

                                        // the the call back
                                        p_ann.then((function(iaa_id) {
                                            return function(ann) {
                                                // add the sentences
                                                var r = nlp_toolkit.sent_tokenize(
                                                    ann.text,
                                                    app_hotpot.vpp.$data.cfg.sentence_splitting_algorithm
                                                );
                                                ann._sentences = r.sentences;
                                                ann._sentences_text = r.sentences_text;

                                                // add this ann to iaa list
                                                app_hotpot.vpp.add_iaa_ann(ann, iaa_id);
                                            }
                                        })(iaa_id)).catch(function(error) {
                                            app_hotpot.msg("Couldn't read ann, " + error.name);
                                            console.error(error);
                                        });
                                        
                                    } else {
                                        // what to do with a directory
                                    }
                                }
                            })(iaa_id))
                            .catch(function(error) {
                                console.log('* error when drop txt', error);
                            });
                        } else {
                            // just load the file 
                            let item = items[i].webkitGetAsEntry();
                            if (item) {
                                // ok, user select a folder ???
                                if (item.isDirectory) {
                                    // show something?
            
                                } else {
                                    // should be a dtd file
                                    // so item is a fileEntry
                                    var new_fn = item.name;
                                    app_hotpot.read_file_async(item, (function(new_fn, iaa_id){
                                        return function(evt) {
                                            var xml = evt.target.result;
                            
                                            // try to parse this xml file
                                            var ann = ann_parser.xml2ann(
                                                xml, 
                                                app_hotpot.vpp.$data.dtd
                                            );
                        
                                            // post processing
                                            // we don't have fh due to using fileEntry
                                            ann._fh = null;
                                            ann._filename = new_fn;
                                            ann._has_saved = true;
                                            var result = nlp_toolkit.sent_tokenize(ann.text);
                                            ann._sentences = result.sentences;
                                            ann._sentences_text = result.sentences_text;
                                            
                                            // ok, add this the dtd for annotator
                                            app_hotpot.vpp.add_iaa_ann(ann, iaa_id);
                                        }
                                    })(new_fn, iaa_id));
                                }
                            }
                        }


                        
                    }
        
                }
            })(iaa_id), false);
        }
        
    },
    
});

Object.assign(app_hotpot.vpp_methods, {
    clear_iaa_all: function(which) {
        if (typeof(which) == 'undefined') {
            which = null;
        }
        // clear everything related to iaa
        if (which == null || which == 0) {
            // just clear a
            this.iaa_ann_list[0].anns = [];
        }
        if (which == null || which == 1) {
            // just clear b
            this.iaa_ann_list[1].anns = [];
        }

        this.iaa_dict = null;
        this.iaa_gs_dict = null;

        this.iaa_display_tag_name = '__all__';
        this.iaa_display_hashcode = null;
    },

    add_iaa_ann: function(ann, iaa_id) {
        this.iaa_ann_list[iaa_id].anns.push(ann);
    },

    calc_iaa: function() {
        var iaa_dict = iaa_calculator.evaluate_anns_on_dtd(
            this.dtd,
            this.iaa_ann_list[0].anns,
            this.iaa_ann_list[1].anns,
            this.iaa_match_mode,
            this.iaa_overlap_ratio / 100,
            this.iaa_use_attributes?
                this.iaa_use_tag_attrs:
                null,
            this.iaa_remove_tag_b_when_low_overlap
        );
        this.iaa_dict = iaa_dict;
        console.log('* iaa result:', iaa_dict);

        // and create
        this.make_iaa_gs_dict();
    },

    iaa_sort_filelist_by: function(sort_by) {
        this.iaa_sort_anns_by = sort_by;
    },

    iaa_get_sort_by: function() {
        if (this.hasOwnProperty('iaa_sort_anns_by')) {
            return this.iaa_sort_anns_by;
        } else {
            return 'default';
        }
    },
    
    iaa_get_sort_by_label: function(sort_by) {
        return {
            'default': 'Sort',
            'label': 'Label',
            'f1_asc': 'F1 0-1',
            'f1_desc': 'F1 1-0',

            // for A
            'a.alphabet': 'A|A-Z',
            'a.alphabet_r': 'A|Z-A',

            // for B
            'b.alphabet': 'B|A-Z',
            'b.alphabet_r': 'B|Z-A',
        }[sort_by];
    },

    iaa_sort_v_anns: function(iaa_dict) {
        var sort_by = this.iaa_get_sort_by();

        // a virtual list of ann, just contain the file name
        // this is prepared for sorting only
        // because the sort is an in-place sort
        // we can't modify the order in the original anns
        var v_anns = [];
        for (const ann_hashcode in iaa_dict.ann) {
            const ann_rst = iaa_dict.ann[ann_hashcode];
            v_anns.push({
                // hashtag
                ann_hashcode: ann_hashcode,

                // the f1
                f1: this.iaa_display_tag_name == '__all__'? 
                    ann_rst.rst.all.f1 : ann_rst.rst.tag[this.iaa_display_tag_name].f1,

                // number of annotated tags
                ann_a: {
                    _filename: ann_rst.anns[0]._filename
                },
                ann_b: {
                    _filename: ann_rst.anns[1]._filename
                }
            });
        }

        // now sort
        if (sort_by == 'default') {
            return v_anns;

        } else if (sort_by == 'f1_asc') {
            console.log('* sorting f1_asc', isNaN(0));
            v_anns.sort(function(a, b) {
                var v = (isNaN(a.f1)?0:a.f1) - (isNaN(b.f1)?0:b.f1);
                return v;
            });
            return v_anns;

        } else if (sort_by == 'f1_desc') {
            console.log('* sorting f1_desc', isNaN(NaN));
            v_anns.sort(function(a, b) {
                var v = (isNaN(b.f1)?0:b.f1) - (isNaN(a.f1)?0:a.f1);
                return v;
            });
            return v_anns;

        } else if (sort_by == 'a.alphabet') {
            v_anns.sort(function(a, b) {
                return a.ann_a._filename.localeCompare(
                    b.ann_a._filename
                )
            });
            return v_anns;

        } else if (sort_by == 'a.alphabet_r') {
            v_anns.sort(function(a, b) {
                return -a.ann_a._filename.localeCompare(
                    b.ann_a._filename
                )
            });
            return v_anns;
            
        } else if (sort_by == 'b.alphabet') {
            v_anns.sort(function(a, b) {
                return a.ann_b._filename.localeCompare(
                    b.ann_b._filename
                )
            });
            return v_anns;

        } else if (sort_by == 'b.alphabet_r') {
            v_anns.sort(function(a, b) {
                return -a.ann_b._filename.localeCompare(
                    b.ann_b._filename
                )
            });
            return v_anns;
            
        } else {
            return v_anns;
        }
    },

    get_rst: function(obj) {
        if (this.iaa_display_tag_name == '__all__') {
            return obj.all;
        } else {
            return obj.tag[this.iaa_display_tag_name];
        }
    },

    on_change_iaa_settings: function(event) {
        console.log('* changed attr in', event.target);
        
    },

    on_change_iaa_use_attributes: function(event) {
        console.log('* changed iaa_use_attributes=', this.iaa_use_attributes);

        // update the settings of iaa_use_tag_attrs
        if (this.dtd == null) {
            return;
        }

        if (Object.keys(this.iaa_use_tag_attrs).length != 0) {
            // which means this has been inited
            return;
        }

        this.init_iaa_use_tag_attrs();
    },

    init_iaa_use_tag_attrs: function() {
        // update the values
        for (const tag_name in this.dtd.tag_dict) {
            if (Object.hasOwnProperty.call(this.dtd.tag_dict, tag_name)) {
                const tag = this.dtd.tag_dict[tag_name];
                this.iaa_use_tag_attrs[tag_name] = {};

                // update all the attributes
                for (let i = 0; i < tag.attlists.length; i++) {
                    const att = tag.attlists[i];
                    // set all to true
                    this.iaa_use_tag_attrs[tag_name][att.name] = true;
                }
            }
        }
    },

    set_iaa_display_measure: function(m) {
        this.iaa_display_measure = m;
    },

    set_all_iaa_use_tag_attrs: function(selection) {
        for (const tag_name in this.iaa_use_tag_attrs) {
            if (Object.hasOwnProperty.call(this.iaa_use_tag_attrs, tag_name)) {
                const tag_attrs = this.iaa_use_tag_attrs[tag_name];
                for (const att_name in tag_attrs) {
                    if (Object.hasOwnProperty.call(tag_attrs, att_name)) {
                        this.iaa_use_tag_attrs[tag_name][att_name] = selection;
                    }
                }
            }
        }

        // due to deep update, need to update manually
        this.$forceUpdate();
    },

    toggle_iaa_tag_attrs: function(tag_name, att_name) {
        if (this.iaa_use_tag_attrs.hasOwnProperty(tag_name)) {
            if (this.iaa_use_tag_attrs[tag_name].hasOwnProperty(att_name)) {
                this.iaa_use_tag_attrs[tag_name][att_name] = 
                    !this.iaa_use_tag_attrs[tag_name][att_name];
            }
        }
        // console.log('* set iaa_use_tag_attrs['+tag_name+']['+att_name+']='+this.iaa_use_tag_attrs[tag_name][att_name]);

        // due to deep update, need to update manually
        this.$forceUpdate();
    },

    transfer_to_annotation_tab: function() {
        // confirm first if there are annotations
        var len = app_hotpot.vpp.$data.anns.length;
        if (len > 0) {
            var msg = 'There are ' + len + ' documents in your annotation tab. Editing adjudication copy needs to remove those documents. Are you sure to continue?';
            var ret = app_hotpot.confirm(msg);
            if (ret) {

            } else {
                // ok, let's stop
                return;
            }
        }

        // check iaa_gs_dict status
        if (this.iaa_gs_dict == null) {
            // OK, nothing to do with an empty iaa_gs_dict

            // maybe say something?
            app_hotpot.msg('Adjudication copy is not found', 'warning');
            return;
        }

        // convert the current gs dict
        var gs_list = Object.values(
            this.iaa_gs_dict
        );

        // then create ann list for update
        var anns = [];

        // check each item in this iaa_gs
        for (let i = 0; i < gs_list.length; i++) {
            const gs = gs_list[i];

            // create a new ann
            var ann = gs.ann;

            // copy the rst of initial 
            for (const tag_name in gs.rst) {
                if (Object.hasOwnProperty.call(gs.rst, tag_name)) {
                    const r = gs.rst[tag_name];
                    // check each cm, fn, fp, and tp
                    for (const cm in r) {
                        if (Object.hasOwnProperty.call(r, cm)) {
                            const ds = r[cm];
                            for (let j = 0; j < ds.length; j++) {
                                const d = ds[j];

                                // it's possible that this decision have been removed
                                if (d == null) {
                                    continue;
                                }
                                // there are two attributes:
                                // from: a or b
                                // tag: the tag itself
                                // copy a new one
                                var tag = JSON.parse(JSON.stringify(d.tag));

                                // then need to update the id?
                                var etag_def = this.get_tag_def(tag_name);
                                if (etag_def == null) {
                                    // what????
                                } else {
                                    var new_tag_id = ann_parser.get_next_tag_id(
                                        ann,
                                        etag_def
                                    );
                                    tag.id = new_tag_id;
                                }

                                // update the tag info for annotator
                                if (cm == 'tp') {
                                    // which means this tag is agreed by both
                                    tag._annotator = 'AB';
                                } else {
                                    // which means this tag is added by A or B
                                    // or they don't have an agreement
                                    tag._annotator = d.from;
                                }

                                // save this tag
                                ann.tags.push(tag);
                            }
                        }
                    }
                }
            }
            
            anns.push(ann);
        }

        // replace 
        this.set_ann_idx(null);
        this.anns = [];

        // set to span tag mode
        this.cm.mark_mode = 'span';

        // bind the ann
        this.anns = anns;

        // update the UI
        this.ann_idx = 0;

        // switch to ann tab
        this.switch_mui('annotation');
    },

    make_iaa_gs_dict: function() {
        this.iaa_gs_dict = iaa_calculator.get_default_gs_dict(
            this.dtd, this.iaa_dict
        );
    },

    download_gs_file: function(hashcode) {
        // get this gs
        const ann_rst = this.iaa_gs_dict[hashcode];
        
        // change to an ann obj
        var ann = iaa_calculator.make_ann_by_rst(
            ann_rst, 
            this.dtd
        );

        // get the xmlText
        var xml_doc = ann_parser.ann2xml(ann, this.dtd);
        var xml_text = ann_parser.xml2str(xml_doc);

        // download this xml
        var blob = new Blob([xml_text], {type: "text/xml;charset=utf-8"});
        var fn = ann_rst.ann._filename;
        saveAs(blob, fn);            
    },

    download_all_gs: function() {
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = this.get_gs_zipfile_folder_name();

        // add files to zip pack
        for (const hashcode in this.iaa_gs_dict) {
            if (Object.hasOwnProperty.call(this.iaa_gs_dict, hashcode)) {
                const ann_rst = this.iaa_gs_dict[hashcode];
                
                // change to an ann obj
                var ann = iaa_calculator.make_ann_by_rst(
                    ann_rst, 
                    this.dtd
                );

                // get the xmlText
                var xml_doc = ann_parser.ann2xml(ann, this.dtd);
                var xml_text = ann_parser.xml2str(xml_doc);

                // put this xml in folder (virtually)
                var ffn = folder_name + '/' + ann._filename;
                
                // put this xml to zip
                zip.file(ffn, xml_text);
            }
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(
                content, 
                app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + 
                '-' +
                app_hotpot.vpp.get_date_now() + 
                '.zip'
            );
        });
    },

    download_all_iaa_anns: function() {
        // create an empty zip pack
        var zip = new JSZip();
        var folder_name = this.get_gs_zipfile_folder_name() + '_ALL';

        // add files to zip pack
        for (const hashcode in this.iaa_gs_dict) {
            if (Object.hasOwnProperty.call(this.iaa_gs_dict, hashcode)) {
                const ann_rst = this.iaa_gs_dict[hashcode];
                const ann_iaa = this.iaa_dict.ann[hashcode];
                
                // change to an ann obj
                var ann = iaa_calculator.make_ann_by_iaa(
                    ann_rst, 
                    ann_iaa,
                    this.dtd
                );

                // get the xmlText
                var xml_doc = ann_parser.ann2xml(ann, this.dtd);
                var xml_text = ann_parser.xml2str(xml_doc);

                // put this xml in folder (virtually)
                var ffn = folder_name + '/' + ann._filename;
                
                // put this xml to zip
                zip.file(ffn, xml_text);
            }
        }

        // create zip file
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(
                content, 
                app_hotpot.vpp.get_new_xmls_zipfile_folder_name() + 
                '-' +
                app_hotpot.vpp.get_date_now() + 
                '-ALL.zip'
            );
        });
    },

    export_iaa_report: function() {
        
        // // Acquire Data (reference to the HTML table)
        // var table_elt = document.getElementById("table_cohen_kappa_confusion_matrix");

        // // Extract Data (create a workbook object from the table)
        // var workbook = XLSX.utils.table_to_book(table_elt);

        // // Process Data (add a new row)
        // var ws_cohen = workbook.Sheets["Sheet1"];

        // create each sheet
        // sheet 1. the summary
        // var ws_summary = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_summary = iaa_calculator.get_iaa_report_summary_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 1.1 the cohen's kappa
        var ws_cohen = iaa_calculator.get_iaa_report_cohen_kappa_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 2. the files
        // var ws_files = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_files = iaa_calculator.get_iaa_report_files_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 3. the tags
        // var ws_tags = XLSX.utils.json_to_sheet([{'a':1}]);
        var ws_tags = iaa_calculator.get_iaa_report_tags_excelws(
            this.iaa_dict,
            this.dtd
        );

        // sheet 4. the adjudication
        var ws_adj = iaa_calculator.get_iaa_report_adjudication_excelws(
            this.iaa_dict,
            this.dtd
        );

        // create wb for download
        var wb = {
            SheetNames: [
                "F1-Score",
                "Cohen Kappa",
                "Files",
                "Tags",
                "Adjudication"
            ],
            Sheets: {
                "F1-Score": ws_summary,
                "Cohen Kappa": ws_cohen,
                Files: ws_files,
                Tags: ws_tags,
                Adjudication: ws_adj
            }
        };
        console.log(wb);

        // decide the file name for this export
        var fn = this.dtd.name + '-iaa-report.xlsx';

        // download this wb
        XLSX.writeFile(wb, fn);
    },

    get_gs_zipfile_folder_name: function() {
        return this.dtd.name + '-goldstandards';
    },

    count_gs_tags: function(ann_hashcode) {
        if (this.iaa_display_tag_name == '__all__') {
            return this.count_iaa_gs_notnull(this.iaa_gs_dict[ann_hashcode]);
        } else {
            return this.count_iaa_gs_tag_notnull(
                this.iaa_gs_dict[ann_hashcode].rst[this.iaa_display_tag_name]
            );
        }
    },

    count_iaa_gs_notnull: function(ann_rst) {
        var cnt = 0;
        for (const tag_name in ann_rst.rst) {
            if (Object.hasOwnProperty.call(ann_rst.rst, tag_name)) {
                const tag_rst = ann_rst.rst[tag_name];
                cnt += this.count_iaa_gs_tag_notnull(tag_rst);
            }
        }
        return cnt;
    },

    count_iaa_gs_tag_notnull: function(tag_rst) {
        var cnt = 0;
        for (const cm in tag_rst) {
            if (Object.hasOwnProperty.call(tag_rst, cm)) {
                const tags = tag_rst[cm];
                
                for (let i = 0; i < tags.length; i++) {
                    if (tags[i] != null) {
                        cnt += 1;
                    }
                }
            }
        }
        return cnt;
    },

    accept_iaa_tag: function(hashcode, tag_name, cm, tag_idx, from) {
        console.log('* accept', hashcode, tag_name, cm, tag_idx, from);
        this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = {
            tag: this.iaa_dict.ann[hashcode].rst.tag[tag_name].cm.tags[cm][tag_idx][
                {'A':0, 'B':1}[from]
            ],
            from: from
        };
        this.force_module_update = Math.random();
    },

    reject_iaa_tag: function(hashcode, tag_name, cm ,tag_idx) {
        console.log('* reject', hashcode, tag_name, cm, tag_idx);
        this.iaa_gs_dict[hashcode].rst[tag_name][cm][tag_idx] = null;
        this.force_module_update = Math.random();
    },

    count_tags_in_anns: function(anns) {
        var cnt = 0;
        for (let i = 0; i < anns.length; i++) {
            const ann = anns[i];
            cnt += ann.tags.length;
        }
        return cnt;
    },
});

// extend the App with converter
/**
 * This is an extension for converter 
 */

/////////////////////////////////////////////////////////////////
// Corpus converter related variables
/////////////////////////////////////////////////////////////////
Object.assign(app_hotpot.vpp_data, {
    converter_corpus_task: 'medtagger',

    // for medtagger
    converter_corpus_medtagger_txt_files: [],
    converter_corpus_medtagger_ann_files: [],
    converter_corpus_medtagger_results: []
});

/////////////////////////////////////////////////////////////////
// Corpus converter related functions
/////////////////////////////////////////////////////////////////

Object.assign(app_hotpot, {
    // events for loading text files
    bind_dropzone_converter_medtagger_txt: function() {
        let filelist_dropzone = document.getElementById('mui_converter_medtagger_txt_filelist');
        filelist_dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        filelist_dropzone.addEventListener(
            "drop", 
            app_hotpot.on_drop_converter_medtagger_txt, 
            false
        );
    },

    // callback for loading text files
    on_drop_converter_medtagger_txt: function(event) {
        // prevent the default download event
        event.preventDefault();

        // prevent other event
        if (event.srcElement.nodeName.toLocaleUpperCase() != 'DIV') {
            return;
        }

        let items = event.dataTransfer.items;
        for (let i=0; i<items.length; i++) {
            if (isFSA_API_OK) {
                // get this item as a FileSystemHandle Object
                // this could be used for saving the content back
                // let item = items[i].webkitGetAsEntry();
                let item = items[i].getAsFileSystemHandle();

                // read this handle
                item.then(function(fh) {
                    if (fh.kind == 'file') {
                        app_hotpot.parse_file_fh(
                            fh, 
                            app_hotpot.on_get_converter_medtagger_txt_file
                        );
                    } else {
                        // so item is a directory?
                        app_hotpot.parse_dir_fh(
                            fh, 
                            app_hotpot.on_get_converter_medtagger_txt_file
                        );
                    }
                });
            } else {
                // do nothing without
                console.log('* no FSA API');
                return;
            }
            
        }
    },

    on_get_converter_medtagger_txt_file: function(file) {
        // check duplication
        if (app_hotpot.vpp.exists_converter_corpus_file(
            file.fh.name,
            app_hotpot.vpp.$data.converter_corpus_medtagger_txt_files
        )) {
            app_hotpot.toast('Skip [' + fh.name + '] due to duplicated file name');
            return;
        }
        app_hotpot.vpp.$data.converter_corpus_medtagger_txt_files.push(file);
    },

    // events for loading ann files
    bind_dropzone_converter_medtagger_ann: function() {
        let filelist_dropzone = document.getElementById('mui_converter_medtagger_ann_filelist');
        filelist_dropzone.addEventListener("dragover", function(event) {
            event.preventDefault();
        }, false);

        filelist_dropzone.addEventListener(
            "drop", 
            app_hotpot.on_drop_converter_medtagger_ann, 
            false
        );
    },

    // callback for loading ann files
    on_drop_converter_medtagger_ann: function(event) {
        // prevent the default download event
        event.preventDefault();

        // prevent other event
        if (event.srcElement.nodeName.toLocaleUpperCase() != 'DIV') {
            return;
        }

        let items = event.dataTransfer.items;
        for (let i=0; i<items.length; i++) {
            if (isFSA_API_OK) {
                // get this item as a FileSystemHandle Object
                // this could be used for saving the content back
                // let item = items[i].webkitGetAsEntry();
                let item = items[i].getAsFileSystemHandle();

                // read this handle
                item.then(function(fh) {
                    if (fh.kind == 'file') {
                        app_hotpot.parse_file_fh(
                            fh, 
                            app_hotpot.on_get_converter_medtagger_ann_file
                        );


                    } else {
                        // so item is a directory?
                        app_hotpot.parse_dir_fh(
                            fh, 
                            app_hotpot.on_get_converter_medtagger_ann_file
                        );
                    }
                });
            } else {
                // do nothing without
                console.log('* no FSA API');
                return;
            }
            
        }
    },

    on_get_converter_medtagger_ann_file: function(file) {
        // for ann, we need the lines
        file.text = file.text.trim();
        file.lines = file.text.split('\n');

        // save this 
        app_hotpot.vpp.$data.converter_corpus_medtagger_ann_files.push(file);
    }
});


Object.assign(app_hotpot.vpp_methods, {
    switch_corpus: function(corpus_task) {
        this.converter_corpus_task = corpus_task;
    },

    clear_converter_corpus_all: function() {
        // remove the medtagger files
        this.converter_corpus_medtagger_txt_files = [];
        this.converter_corpus_medtagger_ann_files = [];
        this.converter_corpus_medtagger_results = [];
    },

    exists_converter_corpus_file: function(fn, files) {
        for (let i = 0; i < files.length; i++) {
            const _f = files[i];
            if (_f.fh.name == fn) {
                return true;
            }
        }

        return false;
    },

    convert_from_medtagger_txt_and_ann: function() {
        if (this.dtd == null) {
            app_hotpot.toast('Conversion is terminated. The annotation schema (.dtd) is needed for conversion. Please load the schema file first in the annotation tab', 'alert');
            return;
        }
        if (this.converter_corpus_medtagger_txt_files.length == 0) {
            app_hotpot.toast('Conversion is terminated. The .txt text files are needed for conversion.', 'alert');
            return;
        }
        if (this.converter_corpus_medtagger_txt_files.length == 0) {
            app_hotpot.toast('Conversion is terminated. The .ann output files are needed for conversion.', 'alert');
            return;
        }
        this.converter_corpus_medtagger_results = medtagger_toolkit.convert_medtagger_files_to_anns(
            this.converter_corpus_medtagger_txt_files,
            this.converter_corpus_medtagger_ann_files,
            this.dtd
        );
    },

    download_converted_files_as_zip: function() {
        if (this.converter_corpus_medtagger_results.length == 0) {
            app_hotpot.toast('Download is terminated. No converted files are found for conversion.', 'alert');
            return;
        }

        // get the results, which are the ann files 
        var anns = [];
        for (let i = 0; i < this.converter_corpus_medtagger_results.length; i++) {
            const r = this.converter_corpus_medtagger_results[i];
            // the medtator_ann contains the ann objects for MedTator
            anns.push(r.medtator_ann);
        }

        // create filename
        var fn = 'Converted-' + 
            this.converter_corpus_task + 
            '-' +
            this.get_date_now() +
            '.zip';
        
        var file_list = nlp_toolkit.download_dataset_raw(
            anns,
            this.dtd,
            fn,
            true
        );
        
        console.log('* downloaded converted files as a zip:', file_list);   
    },

    show_converter_how_to_user: function() {
        window.open(
            'https://github.com/OHNLP/MedTator/wiki/Manual#converter-tab',
            '_blank'
        );
    },
});

// The Tag Info Vue Module
Vue.component('iaa-tag-info', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {
        /**
         * Create a context HTML for showing the tag information
         * @param {Object} tag the annotated tag
         * @param {Object} ann the ann object
         */
         get_iaa_context_html: function(tag, ann) {
            // first, convert the tag spans for locating
            var loc = iaa_calculator.spans2loc(tag.spans);
            var spans_text = tag.text;

            // get the context start
            var c_start = loc[0] - 200;
            if (c_start < 0) { c_start = 0; }

            // get the context end
            var c_end = loc[1] + 200;
            if (c_end > ann.text.length) { c_end = ann.text.length; }

            // now create a text
            var html = [
                // the context before tag spans
                ann.text.substring(c_start, loc[0]),

                // the tag itself
                '<span class="mark-tag mark-tag-' + tag.tag + '">',
                spans_text,
                '</span>',

                // the context after tag spans
                ann.text.substring(loc[1], c_end)
            ];

            return html.join('');
        },

        accept_tag: function(hashcode, tag_name, cm, tag_idx, from) {
            // call app_hotpot directly
            app_hotpot.vpp.accept_iaa_tag(hashcode, tag_name, cm, tag_idx, from);
        },

        get_tag_spans_html: function(tag) {
            if (tag.spans == '-1~-1') {
                return 'DOCLEVEL';
            } else {
                return tag.spans;
            }
        }
    },

    computed: {
        
    },

    props: [
        'cm',
        'hashcode',
        'from',
        'tag',
        'tag_idx',
        'ann',
        'dtd',
        'iaa_display_tags_context',
        'force_module_update',
    ],

    template: `
<div class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-' + cm"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">

        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Accept this [' + tag.text + '] in goldstandard'"
                v-on:click="accept_tag(hashcode, tag.tag, cm, tag_idx, from)">
                Accept This
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-ab mr-2">
            <span class="mr-1"
                v-bind:class="'mark-tag-' + tag.tag">
                {{ tag.id }}
            </span>
            <span>
                {{ get_tag_spans_html(tag) }}: 
                <b>
                    {{ tag.text }}
                </b>
            </span>
        </div>
        
        <div v-for="(attlist, attlist_idx) in dtd.tag_dict[tag.tag].attlists"
            v-if="!['id','spans','text','tag'].contains(attlist.name)"
            class="iaa-tag-attlist mr-1 ml-1 d-flex flex-column">

            <div class="iaa-tag-attlist-name">
                &nbsp;{{ attlist.name }}:
            </div> 

            <div>
                &nbsp;{{ tag[attlist.name] }}
            </div>
            
        </div>
    </div>

    <div v-if="iaa_display_tags_context"
        v-html="get_iaa_context_html(tag, ann)"
        class="iaa-tag-context mt-1">
    </div>  
</div>   
`
});

// The Tag Info Vue Module for Gold Standard
Vue.component('iaa-tag-info-gs', {
    data: function () {
        return {
            update: 0,
        }
    },
    methods: {

        reject_tag: function(hashcode, tag_name, cm, tag_idx) {
            // call app_hotpot directly
            tag_idx = parseInt(tag_idx);
            app_hotpot.vpp.reject_iaa_tag(hashcode, tag_name, cm, tag_idx);
        },

        upper: function(v) {
            return v.toLocaleUpperCase();
        }
    },

    computed: {
        
    },

    props: [
        'cm',
        'from',
        'hashcode',
        'tag_obj',
        'tag_idx',
        'ann',
        'dtd',
        'force_module_update',
    ],

    template: `
<div v-if="tag_obj != null"
    class="iaa-tag-detail-info w-100 d-flex flex-column" 
    v-bind:class="'iaa-tag-detail-info-gs'"
    :force_module_update="force_module_update">
    <div class="d-flex flex-row flex-wrap flex-align-end">
    
        <div class="iaa-tag-detail-oper">
            <button class="btn btn-xs"
                :title="'Remove this [' + tag_obj.tag.text + ']'"
                v-on:click="reject_tag(hashcode, tag_obj.tag.tag, cm, tag_idx)">
                Remove
            </button>
        </div>

        <div class="iaa-tag-detail-info-text-gs mr-2">
            <span class="mr-1">
                <i class="fa fa-user"></i>
                <b>
                {{ upper(tag_obj.from) }}
                </b>
            </span>
            <span>
                {{ tag_obj.tag.spans }}: 
                <b>
                    {{ tag_obj.tag.text }}
                </b>
            </span>
        </div>
        
    </div>
</div>
<div v-else
    class="iaa-tag-detail-info w-100 d-flex flex-column">
    Rejected or Not Decided
</div>
`
});

var jarvis = {
    init: function() {
        // too bad ...
        if (isIE) { 
            this.ssmsg(_NOT_SUPPORT_MSG);
            return 0; 
        }

        app_hotpot.init();

        if (isCHROME) { 

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);

            } else {
                // this can be many reasons
                if (isHTTPS) {
                    // 2022-03-24: Thanks to Adam Cross@UIC who reported this bug!
                    jarvis.ssmsg(_DISABLED_API_MSG);

                } else if (isLOCALFILE) {
                    // 2022-03-24: Thanks to Adam Cross@UIC who reported this bug!
                    jarvis.ssmsg(_DISABLED_API_MSG);

                } else if (!isLOCALHOST) {
                    // not HTTPs and not localhost
                    // so can not use FSA API
                    jarvis.ssmsg(_SEC_LMT_MSG);

                } else {
                    // ?
                    jarvis.ssmsg(_DISABLED_API_MSG);
                }
            }
        } else {

            if (isFSA_API_OK) {
                jarvis.ssmsg('Initializated')
                setTimeout('jarvis.ssclose();', 500);
                
            } else {
                jarvis.ssmsg(_LMT_SUPPORT_MSG);
            }

        }

        $(window).resize(function() {
            app_hotpot.resize();
        });

        // get some settings here

        // the default sample dataset for demo
        var sample_ds = this.get_url_paramter('ds');
        if (sample_ds == '') {
            sample_ds = 'MINIMAL_TASK';
        }

        // show sample dataset at beginning or not
        var show_sample = this.get_url_paramter('ss');
        if (show_sample == 'yes') {
            app_hotpot.vpp.load_sample_ds(sample_ds);
        }

        // show the tour?
        var show_tour = this.get_url_paramter('st');
        if (show_tour == 'yes') {
            setTimeout('app_hotpot.start_tour_annotation();', 550);
        }
    },

    get_url_paramter: function(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    },

    ssmsg: function(msg) {
        $('#ss-msg').html(msg);
    },

    ssclose: function() {
        $('#start-screen').hide();
    },

    save_json: function(obj, fn) {
        var json_text = JSON.stringify(obj, null, 4);
        var blob = new Blob([json_text], {type: "text/json;charset=utf-8"});
        saveAs(blob, fn);
    },

    save_vpp_as: function(name) {
        if (app_hotpot.vpp.$data.dtd == null) {
            console.log('* no dtd yet');
        }
        var dtd_name = app_hotpot.vpp.$data.dtd.name;

        if (typeof(name) == 'undefined') {
            name = dtd_name;
        }

        // change to upper case for better looking
        name = name.toLocaleUpperCase();

        // save it!
        this.save_json(
            app_hotpot.vpp.$data,
            'vpp_data_'+name+'.json'
        );
    }
}

jarvis.sample_text = {
    'covid_vax': `Positive COVID-19 test with symptoms; 

The patient had MS and was immune compromised; 

This is a spontaneous report from a contactable consumer (patient). This female consumer of unspecified age received the first single dose of BNT162B2 (PFIZER-BIONTECH COVID-19 VACCINE) on 04Jan2021, for COVID-19 immunization. She had MS and was immune compromised. Concomitant medications were not reported. On 07Jan2021 the patient woke up with headache, runny nose, groggy and muscle aches. She went to pharmacy and got a rapid COVID test that resulted positive. She was asking if the 1st dose could have caused her to be positive on the test. Events outcome was unknown.  

Information on the batch/lot number has been requested.

Sender's Comments: 

Based on the information available, a possible contributory role of the suspect products cannot be excluded for the reported event of positive for corona virus infection for the lack of efficacy of the vaccine. However, based on the mechanism of action of the vaccine, it is unlikely the patient would have fully developed immunity for the vaccine to be effective, due to the number of days passed since the vaccine is given. Case will be reevaluated based on follow-up information
    `
};

jarvis.changelog_latest = `
1.2.41 (2022-06-23)

- Added meta-data structure for annotation file
- Added color label to annotation file
- Added functions for updating annotator for adjudication
- Added download all tags for adjudication
- Added sorting by label color
- Added MedTagger ann format converter
- Added UI for converting MedTagger results
- Added folder drag and drop for converter
- Added folder drag and drop for adjudication
- Updated IAA drop box width
- Updated code structure for better extension
- Updated wiki pages
- Fixed meta copy bug when generating adjudicated copy


`;


// extend the App with data if needed

// init the whole document
$(document).ready(function () {
    jarvis.init();
})
</script>

    
</body>
</html>